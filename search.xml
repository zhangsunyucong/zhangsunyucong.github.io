<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从矩阵来看颜色变换</title>
    <url>/2018/04/18/android-color-matrix/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>之前从矩阵的角度分析了平移，旋转，缩放，对称的变换，文章在<a href="https://zhangsunyucong.top/2018/02/07/android-animation-matrix/">从矩阵来看Android中的一些动画变换</a>。</p>
<p>在android中，图片的对象主要是bitmap，它是由点阵和颜色值组成的。<br>1、点阵是一个图片宽*图片高的矩阵，矩阵中的每一个元素对应着图片的一个像素。根据点阵可以计算出图片占用的内存大小。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALPHA_8：  每个像素占用1byte内存</span><br><span class="line">ARGB_4444: 每个像素占用2byte内存</span><br><span class="line">ARGB_8888: 每个像素占用4byte内存</span><br><span class="line">RGB_565:   每个像素占用2byte内存</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图片占用内存 = 图片高度显示像素 * 图片宽度显示像素 * 每个像素占用的内存大小</span><br><span class="line"></span><br><span class="line">显示像素 = 图片实际像素 * 手机density / 图片density </span><br><span class="line"></span><br><span class="line">假设有一张长宽为800*600、通道为ARGB_8888的图片，那么它占的内存为：</span><br><span class="line">800*600*4byte = 1875KB = 1.83M</span><br></pre></td></tr></table></figure>
<p>2、颜色值，是由三原色和透明度决定的，即ARGB，分别对应着四个颜色通道，每个通道用8byte定义，所以一个颜色值就是一个int整型，可以表示256x256x256种颜色值。</p>
<p>在android中和颜色有关的几个常量：ARGB_8888、ARGB_4444、RGB_565。<br>ARGB_8888，是图片的透明度、R、G、B的每个颜色值占8bit，可以表示256x256x256种颜色，也就是可以表示最多的颜色值，图片质量也是最好的。</p>
<p>ARGB_4444，是图片的透明度、R、G、B的每个颜色值占4bit，可以表示16x16x16种颜色，相对ARGB_8888，它节省了空间，却失去了很多色彩。</p>
<p>RGB_565，它只有R、G、B三个颜色通道，没有透明度通道，可以表达32x64x32种颜色。</p>
<p>四个颜色通道是由一个4x5的变换矩阵控制的。</p>
<h3 id="颜色矩阵变换"><a href="#颜色矩阵变换" class="headerlink" title="颜色矩阵变换"></a>颜色矩阵变换</h3><p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/b06767699e9203117a1f/color_matrix_1.webp" alt="推导"></p>
<p>所以，可以知道，红色通道由第一行控制。<br>绿色通道由第二行控制。<br>蓝色通道由第三行控制。<br>透明度通道由第四行控制。<br>另外的，第五列是每个通道的偏移量。注意倍数和相加的影响，每个通道最后的值不应该大于256.</p>
<p>在android中，有一个和颜色矩阵相关的android.graphics.Matrix类，该类中有与颜色变换相关的方法。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/5a5e614c6e9b8f62fc98/color_matrix_2.webp" alt="方法"></p>
<p>关于Matrix方法的使用这里就不详细讲了。</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Bitmap testBitmap(Bitmap bitmap)</span><br><span class="line">&#123;</span><br><span class="line">       Bitmap output = Bitmap.createBitmap(bitmap.getWidth(),</span><br><span class="line">               bitmap.getHeight(), Config.RGB_565);</span><br><span class="line"></span><br><span class="line">       Canvas canvas = new Canvas(output);</span><br><span class="line"></span><br><span class="line">       Paint paint = new Paint();        </span><br><span class="line">       ColorMatrix cm = new ColorMatrix();</span><br><span class="line">       float[] array = &#123;1,0,0,0,100,</span><br><span class="line">               0,1,0,0,100,</span><br><span class="line">               0,0,1,0,0,</span><br><span class="line">               0,0,0,1,0&#125;;</span><br><span class="line">       cm.set(array);</span><br><span class="line">       paint.setColorFilter(new ColorMatrixColorFilter(cm));</span><br><span class="line"></span><br><span class="line">       canvas.drawBitmap(bitmap, 0, 0, paint);</span><br><span class="line">       return output;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="JNI图片压缩"><a href="#JNI图片压缩" class="headerlink" title="JNI图片压缩"></a>JNI图片压缩</h3><p>在上面提到过一张图片占用多大内存的计算，现在我们的手机拍出来的照片占的内存越来越大，所以在开发的过程中，我们就很有必要对图片压缩后再上传。而比较好的压缩方法是JNI压缩。</p>
<p><a href="https://github.com/zhangsunyucong/JniCompressImage.git" target="_blank" rel="noopener">github地址</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式之结构型设计模式</title>
    <url>/2018/04/10/java-pattern-structure/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章主要讲23种设计模式中的7种结构型设计模式，包括适配器模式，装饰者模式，代理模式，外观模式，桥接模式，组合模式，享元模式。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式是将一个类的方法接口转换成客户端期望的接口表示。我们可以约定，把客户端期望的接口叫做目标Targetable，被转换的类叫source。适配器模式可以分为：类的适配器模式，对象的适配器，接口的适配器。</p>
<a id="more"></a>
<h4 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h4><p>已有的被转换的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SourceClass &#123;</span><br><span class="line"></span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.print(&quot;Hi, I am a method in sourceClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>期望的目标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Targetable &#123;</span><br><span class="line">    void method1();</span><br><span class="line">    void method2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现目标，进行适配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdapterClass extends SourceClass implements Targetable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.print(&quot;Hi All, I am a method in adapterClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子就将SourceClass按照意愿Targetable适配转换成了AdapterClass，AdapterClass具有了SourceClass的所有的功能，同时也达到了扩展SourceClass。由于类的适配器模式是通过继承实现的，它具有了继承的优缺点。关于缺点，比如通过AdapterClass对象可以调用属于SourceClass而在Targetable接口中没有的方法。</p>
<h4 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h4><p>对象的适配器模式，就是将原来类的对象转换为目标接口的对象。对象适配器模式没有继承被转换类，而是持有被转换类的对象。这可以避免继承被带来的副作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdapterObjectClass implements Targetable&#123;</span><br><span class="line"></span><br><span class="line">    private SourceClass mSourceClass;</span><br><span class="line"></span><br><span class="line">    public AdapterObjectClass(SourceClass mSourceClass) &#123;</span><br><span class="line">        this.mSourceClass = mSourceClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.print(&quot;hi all, i am a method in AdapterObjectClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        mSourceClass.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h4><p>当一个接口有很多的抽象方法时，当我们写这个接口的实现类，必须实现该接口的全部方法。而有时候接口中并不是所有的抽象方法都是我们必须的，而我们只需要实现其中的某一些方法。为了解决这个问题，我们可以使用接口的适配器模式，引入一个抽象类，这个抽象类提供了接口所有抽象方法的空实现。我们可以继承这个抽象类，并只重写我们需要的方法即可。</p>
<p>比如，在上面我们只要Targetable的method2方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AdapterInterfaceClass implements Targetable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdapterWraper extends AdapterInterfaceClass &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.print(&quot;hi all, I am a method in AdapterWraper class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者模式的核心思想是，装饰者和被装饰者实现同一个接口，将被装饰者注入装饰者中，可以在装饰者中扩展被装饰者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Person &#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被装饰者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Man implements Person &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.print(&quot;There is a man who is eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装饰者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ManDecorator implements Person &#123;</span><br><span class="line"></span><br><span class="line">    private Person mPerson;</span><br><span class="line"></span><br><span class="line">    public ManDecorator(Person person) &#123;</span><br><span class="line">        mPerson = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        mPerson.eat();</span><br><span class="line">        drinkWater();</span><br><span class="line">        System.out.print(&quot;I finish my lunch&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void drinkWater() &#123;</span><br><span class="line">        System.out.print(&quot;Man is drinking water&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Man man = new Man();</span><br><span class="line">ManDecorator manDecorator = new ManDecorator(man);</span><br><span class="line">manDecorator.eat();</span><br></pre></td></tr></table></figure></p>
<p>输出的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">There is a man who is eating</span><br><span class="line">Man is drinking water</span><br><span class="line">I finish my lunch</span><br></pre></td></tr></table></figure>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>注意区别代理模式和动态代理。</p>
<p>生活中代理的例子。比如如果你要租房子，你可能不知道该地区的房子信息，这时你可以找一个熟悉的人来帮忙，这个帮你的人就是代理；又比如，打官司时，我们可能并不精通法律知识，这时我们可以找一个代理律师来帮我们。等等。。对于，代理的工作可以抽象为一个接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface WorkInterface &#123;</span><br><span class="line">    void rentHouse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个房东：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LandLady implements WorkInterface &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void rentHouse() &#123;</span><br><span class="line">        System.out.print(&quot;您好！我是房东。我这里有房子出租！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代理房东的代理类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Proxy implements WorkInterface &#123;</span><br><span class="line"></span><br><span class="line">    private LandLady mLandLady;</span><br><span class="line"></span><br><span class="line">    public Proxy() &#123;</span><br><span class="line">        mLandLady = new LandLady();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void rentHouse() &#123;</span><br><span class="line">        mLandLady.rentHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>租客去找代理租房子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkInterface proxy = new Proxy();</span><br><span class="line">proxy.rentHouse();</span><br></pre></td></tr></table></figure>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>在医院里的前台接待员就是一个外观模式的体现。由于病人来到医院可能对医院内部和流程并不熟悉，那么可以由熟悉这些的接待员来帮病人来完成这些事情。</p>
<p>部门1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ModuleA &#123;</span><br><span class="line"></span><br><span class="line">    //提供给外部调用的方法</span><br><span class="line">    public void a1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //内部完成工作的实现</span><br><span class="line">    private void a2() &#123;&#125;</span><br><span class="line">    private void a3() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部门2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ModuleB &#123;</span><br><span class="line"></span><br><span class="line">    //提供给外部调用的方法</span><br><span class="line">    public void b1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //内部完成工作的实现</span><br><span class="line">    private void b2() &#123;&#125;</span><br><span class="line">    private void b3() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>部门3<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ModuleC &#123;</span><br><span class="line"></span><br><span class="line">    //提供给外部调用的方法</span><br><span class="line">    public void c1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //内部完成工作的实现</span><br><span class="line">    private void c2() &#123;&#125;</span><br><span class="line">    private void c3() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>外观类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ModuleFacade &#123;</span><br><span class="line"></span><br><span class="line">    private ModuleA mModuleA = new ModuleA();</span><br><span class="line">    private ModuleB mMBModuleB = new ModuleB();</span><br><span class="line">    private ModuleC mMCModuleC = new ModuleC();</span><br><span class="line"></span><br><span class="line">    public void a1() &#123;</span><br><span class="line">        mModuleA.a1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void b1() &#123;</span><br><span class="line">        mMBModuleB.b1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void c1() &#123;</span><br><span class="line">        mMCModuleC.c1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要ModuleA，ModuleB， ModuleC的功能时，我们并不直接和他们打交道，也不需要了解部门的功能是如何实现的，而我们只需要去找外观类沟通即可。</p>
<p>外观模式的关键点是整合。</p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式，提供一个解耦或者连接抽象化和实现化的一个桥梁，使得二者可以独立变化。</p>
<p>一个接口作为桥，一个抽象类持有桥。桥和抽象类两者可以独立变化。</p>
<p>桥：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Qiao &#123;</span><br><span class="line">    void toArea();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class FromArea &#123;</span><br><span class="line">    public Qiao qiao;</span><br><span class="line">    abstract public void fromArea();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QiaoC.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class QiaoC implements Qiao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void toArea() &#123;</span><br><span class="line">        System.out.print(&quot;I want to go Area C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QiaoD.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class QiaoD implements Qiao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void toArea() &#123;</span><br><span class="line">        System.out.print(&quot;I want to go Area D&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FromAreaA.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FromAreaA extends FromArea &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fromArea() &#123;</span><br><span class="line">        System.out.print(&quot;I come from area A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FromAreaB.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FromAreaB extends FromArea &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fromArea() &#123;</span><br><span class="line">        System.out.print(&quot;I come from area B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FromAreaA fromAreaA = new FromAreaA();</span><br><span class="line">QiaoC qiaoC = new QiaoC();</span><br><span class="line">fromAreaA.qiao = qiaoC;</span><br><span class="line"></span><br><span class="line">fromAreaA.fromArea();</span><br><span class="line">fromAreaA.qiao.toArea();</span><br><span class="line"></span><br><span class="line">QiaoD qiaoD = new QiaoD();</span><br><span class="line">fromAreaA.qiao = qiaoD;</span><br><span class="line"></span><br><span class="line">fromAreaA.fromArea();</span><br><span class="line">fromAreaA.qiao.toArea();</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，Qiao和FromArea两者是独立变化的，它们的抽象和实现是分离的。</p>
<p>如果有更多的Qiao和FromArea的实现，只要扩展它们即可。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式，又叫“整体-部分设计模式”。它一般用于实现树形结构。</p>
<p>节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private TreeNode parent;</span><br><span class="line">    private Vector&lt;TreeNode&gt; children = new Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public TreeNode(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setParent(TreeNode parent) &#123;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode getParent() &#123;</span><br><span class="line">        return parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addChild(TreeNode child) &#123;</span><br><span class="line">        children.add(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeChild(TreeNode child) &#123;</span><br><span class="line">        return children.remove(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Enumeration&lt;TreeNode&gt; getChildren() &#123;</span><br><span class="line">        return children.elements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体，建立一棵树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Tree &#123;</span><br><span class="line">    TreeNode root = null;</span><br><span class="line"></span><br><span class="line">    public Tree(String name) &#123;</span><br><span class="line">        root = new TreeNode(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Tree tree = new Tree(&quot;A&quot;);</span><br><span class="line">        TreeNode nodeB = new TreeNode(&quot;B&quot;);</span><br><span class="line">        TreeNode nodeC = new TreeNode(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">        nodeB.addChild(nodeC);</span><br><span class="line">        tree.root.addChild(nodeB);</span><br><span class="line">        System.out.println(&quot;build the tree finished!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式主要是实现对象的共享。联想数据库的连接池。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConnectionPool &#123;  </span><br><span class="line">      </span><br><span class="line">    private Vector&lt;Connection&gt; pool;  </span><br><span class="line">      </span><br><span class="line">    /*公有属性*/  </span><br><span class="line">    private String url = &quot;jdbc:mysql://localhost:3306/test&quot;;  </span><br><span class="line">    private String username = &quot;root&quot;;  </span><br><span class="line">    private String password = &quot;root&quot;;  </span><br><span class="line">    private String driverClassName = &quot;com.mysql.jdbc.Driver&quot;;  </span><br><span class="line">  </span><br><span class="line">    private int poolSize = 100;  </span><br><span class="line">    private static ConnectionPool instance = null;  </span><br><span class="line">    Connection conn = null;  </span><br><span class="line">  </span><br><span class="line">    /*构造方法，做一些初始化工作*/  </span><br><span class="line">    private ConnectionPool() &#123;  </span><br><span class="line">        pool = new Vector&lt;Connection&gt;(poolSize);  </span><br><span class="line">  </span><br><span class="line">        for (int i = 0; i &lt; poolSize; i++) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Class.forName(driverClassName);  </span><br><span class="line">                conn = DriverManager.getConnection(url, username, password);  </span><br><span class="line">                pool.add(conn);  </span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; catch (SQLException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* 返回连接到连接池 */  </span><br><span class="line">    public synchronized void release() &#123;  </span><br><span class="line">        pool.add(conn);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* 返回连接池中的一个数据库连接 */  </span><br><span class="line">    public synchronized Connection getConnection() &#123;  </span><br><span class="line">        if (pool.size() &gt; 0) &#123;  </span><br><span class="line">            Connection conn = pool.get(0);  </span><br><span class="line">            pool.remove(conn);  </span><br><span class="line">            return conn;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            return null;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式之创建型模式</title>
    <url>/2018/04/09/java-pattern-builder-factory-clone/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是介绍5种创建型模式中，除了单例模式外的其他创建型模式，包括建造者模式，工厂模式，抽象工厂模式，原型模式。</p>
<p>1、建造者模式，可以将对象的表现和创建（实现）分离开来，根据不同的创建步骤可以产生不同的对象，而对象的创建也是一次性的，创建后的对象是不可变。<br><a id="more"></a></p>
<p>2、工厂模式，根据形式的不同，工厂模式可以分为简单工厂方法模式、多工厂方法模式和抽象工厂方法模式。在简单工厂方法模式中只有一个工厂方法，工厂方法根据不同的条件生产不同的对象。多工厂方法模式，为每一个对象都提供一个工厂方法。抽象工厂方法模式，就是在多工厂方法模式的基础上将每个普通工厂方法变为静态工厂方法。另外，可以使用反射来生产产品。</p>
<p>3、抽象工厂模式，它是工厂模式的进一步抽象，它将产品和工厂都抽象为一个接口，每个具体的工厂生产一种具体的产品。</p>
<p>其实它们的特点是，简单工厂方法模式，用一个方法来生产各种产品。多工厂方法模式，一种对象对应一个方法。抽象工厂方法模式，在多工厂方法模式的基础上，进一步的将每个方法都变为静态的，这样子就不需要创建工厂对象了。抽象工厂模式，它将产品和工厂都进一步抽象为一个类或者接口。</p>
<p>一个方法=》多个方法=》多个静态方法=》抽象类（接口）</p>
<p>4、原型模式，就是从一个已经存在的对象（原型）通过克隆和复制创建一个对象。复制分为浅复制和深复制。</p>
<p>浅复制和深复制的区别：</p>
<p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。<br>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BuilderTest &#123;</span><br><span class="line"></span><br><span class="line">    private String basic;//地基</span><br><span class="line"></span><br><span class="line">    private String wall;//墙</span><br><span class="line"></span><br><span class="line">    private String roofed;//楼顶</span><br><span class="line"></span><br><span class="line">    private BuilderTest() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private BuilderTest(Builder builder) &#123;</span><br><span class="line">        this.basic = builder.basic;</span><br><span class="line">        this.wall = builder.wall;</span><br><span class="line">        this.roofed = builder.roofed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void doSomeThing() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line"></span><br><span class="line">        private String basic;//地基</span><br><span class="line"></span><br><span class="line">        private String wall;//墙</span><br><span class="line"></span><br><span class="line">        private String roofed;//楼顶</span><br><span class="line"></span><br><span class="line">        public Builder setBasic(String basic) &#123;</span><br><span class="line">            this.basic = basic;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setWall(String wall) &#123;</span><br><span class="line">            this.wall = wall;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setRoofed(String roofed) &#123;</span><br><span class="line">            this.roofed = roofed;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public BuilderTest create() &#123;</span><br><span class="line">            BuilderTest builderTest = new BuilderTest(this);</span><br><span class="line">            return builderTest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BuilderTest的构造函数都是私有的，只在Builder中创建它的实例。Builder是一个公开的静态内部类，它的内部成员变量都是私有的，只能调用相对应的setter方法设置，并和BuilderTest中的成员变量是一样的，每个setter方法都是返回Builder自身的，可以链式的调用，当调用create时会将变量传递给BuilderTest和一次性初始化BuilderTest实例。</p>
<p>实际使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BuilderTest builderTest = new BuilderTest.Builder()</span><br><span class="line">                .setBasic(&quot;basic&quot;)</span><br><span class="line">                .setWall(&quot;wall&quot;)</span><br><span class="line">                .setRoofed(&quot;roofed&quot;)</span><br><span class="line">                .create();</span><br><span class="line"></span><br><span class="line">builderTest.doSomeThing();</span><br></pre></td></tr></table></figure>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂方法模式"><a href="#简单工厂方法模式" class="headerlink" title="简单工厂方法模式"></a>简单工厂方法模式</h4><p>规范产品接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产品类：<br>ProductA.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductA implements Product &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.print(&quot;Helle ! My name is ProductA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductB implements Product &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.print(&quot;Hello, My name is ProductB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单工厂类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleFactoryTest &#123;</span><br><span class="line"></span><br><span class="line">    public Product createProduct(String name) &#123;</span><br><span class="line">        if(&quot;ProductA&quot;.equals(name)) &#123;</span><br><span class="line">            return new ProductA();</span><br><span class="line">        &#125; else if(&quot;ProductB&quot;.equals(name)) &#123;</span><br><span class="line">            return new ProductB();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.print(&quot;没有找到产品，请输入正确的类型！&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleFactoryTest simpleFactoryTest = new SimpleFactoryTest();</span><br><span class="line">Product productA = simpleFactoryTest.createProduct(&quot;ProductA&quot;);</span><br><span class="line">productA.sayHello();</span><br><span class="line"></span><br><span class="line">Product ProductB = simpleFactoryTest.createProduct(&quot;ProductB&quot;);</span><br><span class="line">ProductB.sayHello();</span><br></pre></td></tr></table></figure>
<h4 id="多工厂方法模式"><a href="#多工厂方法模式" class="headerlink" title="多工厂方法模式"></a>多工厂方法模式</h4><p>MultiMethodFactory.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MultiMethodFactory &#123;</span><br><span class="line"></span><br><span class="line">    public Product createProductA() &#123;</span><br><span class="line">        return new ProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Product createProductB() &#123;</span><br><span class="line">        return new ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MultiMethodFactory multiMethodFactory = new MultiMethodFactory();</span><br><span class="line">Product productA = multiMethodFactory.createProductA();</span><br><span class="line">productA.sayHello();</span><br><span class="line">        </span><br><span class="line">Product productB = multiMethodFactory.createProductB();</span><br><span class="line">productB.sayHello();</span><br></pre></td></tr></table></figure></p>
<h4 id="静态工厂方法模式"><a href="#静态工厂方法模式" class="headerlink" title="静态工厂方法模式"></a>静态工厂方法模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StaticMethodFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Product createProductA() &#123;</span><br><span class="line">        return new ProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Product createProductB() &#123;</span><br><span class="line">        return new ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Product productA = StaticMethodFactory.createProductA();</span><br><span class="line">Product productB = StaticMethodFactory.createProductB();</span><br><span class="line"></span><br><span class="line">productA.sayHello();</span><br><span class="line">productB.sayHello();</span><br></pre></td></tr></table></figure>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>产品模版：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProductA.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductA implements Product &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.print(&quot;Helle ! My name is ProductA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductB.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductB implements Product &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.print(&quot;Hello, My name is ProductB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>工厂模版：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">    Product createProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProductAFactory.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductAFactory implements Factory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProductBFactory.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductBFactory implements Factory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProductAFactory productAFactory = new ProductAFactory();</span><br><span class="line">productAFactory.createProduct();</span><br><span class="line"></span><br><span class="line">ProductBFactory productBFactory = new ProductBFactory();</span><br><span class="line">productBFactory.createProduct();</span><br></pre></td></tr></table></figure>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式的关键是实现Cloneable接口，并重写Object的clone函数，Cloneable是一个空接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PrototypeObject implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    public int intValue = 34;</span><br><span class="line"></span><br><span class="line">    public String strValue = &quot;I am the First value&quot;;</span><br><span class="line"></span><br><span class="line">    public ProductA productA = new ProductA();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        PrototypeObject prototypeObject = (PrototypeObject)super.clone();</span><br><span class="line">        return prototypeObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;intValue=&quot; + intValue</span><br><span class="line">                + &quot;strValue=&quot; + strValue</span><br><span class="line">                + &quot;helloTxt=&quot; + productA.helloTxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProductA.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductA implements Product &#123;</span><br><span class="line"></span><br><span class="line">    public String helloTxt = &quot;Helle ! My name is ProductA&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.print(&quot;Helle ! My name is ProductA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    PrototypeObject prototypeObject = new PrototypeObject();</span><br><span class="line">    PrototypeObject prototypeObjectClone =  (PrototypeObject)prototypeObject.clone();</span><br><span class="line"></span><br><span class="line">    Log.d(&quot;hyj&quot;, &quot;改变克隆对象值之前:&quot;</span><br><span class="line">            + &quot;prototypeObject=&gt;&quot; + prototypeObject.toString());</span><br><span class="line"></span><br><span class="line">    prototypeObjectClone.strValue = &quot;I am the second value&quot;;</span><br><span class="line">    prototypeObjectClone.productA.helloTxt = &quot;Hi, I am here and change something&quot;;</span><br><span class="line">    Log.d(&quot;hyj&quot;, &quot;改变克隆对象值之后:&quot;</span><br><span class="line">            + &quot;prototypeObject=&gt;&quot; + prototypeObject.toString());</span><br><span class="line">    Log.d(&quot;hyj&quot;, &quot;改变克隆对象值之后:&quot;</span><br><span class="line">            + &quot;prototypeObjectClone=&gt;&quot; + prototypeObjectClone.toString());</span><br><span class="line"></span><br><span class="line">&#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">    System.out.print(e.getCause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">改变克隆对象值之前:prototypeObject=&gt;intValue=34strValue=I am the First valuehelloTxt=Helle ! My name is ProductA</span><br><span class="line">改变克隆对象值之后:prototypeObject=&gt;intValue=34strValue=I am the First valuehelloTxt=Hi, I am here and change something</span><br><span class="line">改变克隆对象值之后:prototypeObjectClone=&gt;intValue=34strValue=I am the second valuehelloTxt=Hi, I am here and change something</span><br></pre></td></tr></table></figure>
<p>在Object中，<br>Object#clone<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">     if (!(this instanceof Cloneable)) &#123;</span><br><span class="line">         throw new CloneNotSupportedException(&quot;Class &quot; + getClass().getName() +</span><br><span class="line">                                                 &quot; doesn&apos;t implement Cloneable&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    return internalClone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Native helper method for cloning.</span><br><span class="line"> */</span><br><span class="line">private native Object internalClone();</span><br></pre></td></tr></table></figure></p>
<p>可以看出，Object的clone方法会调用native函数internalClone；</p>
<p>上面提到原型模式是一种浅复制，将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。而要彻底重新克隆和创建对象，需要使用深复制。</p>
<p>深复制，可以使用对象的序列化来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PrototypeObject implements Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public int intValue = 34;</span><br><span class="line"></span><br><span class="line">    public String strValue = &quot;I am the First value&quot;;</span><br><span class="line"></span><br><span class="line">    public ProductA productA = new ProductA();</span><br><span class="line"></span><br><span class="line">    /* 浅复制 */</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        PrototypeObject prototypeObject = (PrototypeObject)super.clone();</span><br><span class="line">        return prototypeObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 深复制 */</span><br><span class="line">    public Object deepClone() throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(this);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">        return ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;intValue=&quot; + intValue</span><br><span class="line">                + &quot;strValue=&quot; + strValue</span><br><span class="line">                + &quot;helloTxt=&quot; + productA.helloTxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>在Android中解释服务器数据</title>
    <url>/2018/04/08/android-gson-server/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在这一篇文章中，主要讲一下如何使用Gson解释服务器返回的具有固定格式的数据。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>服务器：在本地使用nodejs的express框架建立的简单服务器。它返回了的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var testArrayStr = &quot;&#123;\&quot;data\&quot;: [&#123;\&quot;cnName\&quot;: \&quot;jakewharton\&quot;,\&quot;age\&quot;: 13,\&quot;IsBoy\&quot;: true&#125;, &#123;\&quot;cnName\&quot;: \&quot;小红\&quot;,\&quot;age\&quot;: 24,\&quot;IsBoy\&quot;: false&#125;],\&quot;msg\&quot;: \&quot;\&quot;,\&quot;status\&quot;: 200&#125;&quot;;</span><br><span class="line"></span><br><span class="line">var testObjStr = &quot;&#123;\&quot;data\&quot;: &#123;\&quot;cnName\&quot;: \&quot;小红\&quot;,\&quot;age\&quot;: 24,\&quot;IsBoy\&quot;: false&#125;,\&quot;msg\&quot;: \&quot;\&quot;,\&quot;status\&quot;: 200&#125;&quot;;</span><br><span class="line"></span><br><span class="line">res.end(testObjStr);</span><br></pre></td></tr></table></figure>
 <a id="more"></a>
<p>我们可以和服务器约定返回的格式模版如下，他们的主要区别是data，可以是对象或者对象的数组形式。</p>
<p>定义解释data为对象的模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BaseObjectResult&lt;T&gt; &#123;</span><br><span class="line">    public T data;</span><br><span class="line">    public String msg;</span><br><span class="line">    public int status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义解释data为数组的模版：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BaseArrayResult&lt;T&gt; &#123;</span><br><span class="line">    public List&lt;T&gt; data;</span><br><span class="line">    public String msg;</span><br><span class="line">    public int status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实体对象：<br>TestData.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestData &#123;</span><br><span class="line">    public String cnName;</span><br><span class="line">    public int age;</span><br><span class="line">    public boolean IsBoy;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;testData:&quot; +</span><br><span class="line">                &quot;cnName=&quot; + this.cnName + &quot; &quot; +</span><br><span class="line">                &quot;age=&quot; + this.age + &quot; &quot; +</span><br><span class="line">                &quot;IsBogy=&quot; + this.IsBoy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用retrofit和gson解释"><a href="#使用retrofit和gson解释" class="headerlink" title="使用retrofit和gson解释"></a>使用retrofit和gson解释</h4><p>自定义Converter.Factory</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DecodeConverterFactory extends Converter.Factory &#123;</span><br><span class="line"></span><br><span class="line">    public static DecodeConverterFactory create() &#123;</span><br><span class="line">        return create(new Gson());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static DecodeConverterFactory create(Gson gson) &#123;</span><br><span class="line">        return new DecodeConverterFactory(gson);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final Gson gson;</span><br><span class="line"></span><br><span class="line">    private DecodeConverterFactory(Gson gson) &#123;</span><br><span class="line">        if (gson == null) throw new NullPointerException(&quot;gson == null&quot;);</span><br><span class="line">        this.gson = gson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        return new CustomResponseBodyConverter&lt;&gt;(adapter, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        return new DecodeRequestBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CustomResponseBodyConverter.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123;</span><br><span class="line">    private final TypeAdapter&lt;T&gt; adapter;</span><br><span class="line">    private Type mType;</span><br><span class="line"></span><br><span class="line">    public CustomResponseBodyConverter(TypeAdapter&lt;T&gt; adapter, Type type) &#123;</span><br><span class="line">        this.adapter = adapter;</span><br><span class="line">        this.mType = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public T convert(ResponseBody value) throws IOException &#123;</span><br><span class="line">        //解密字符串</span><br><span class="line">        if(mType == String.class) &#123;</span><br><span class="line">            return (T) value.string();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecodeRequestBodyConverter.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DecodeRequestBodyConverter&lt;T&gt; implements Converter&lt;T, RequestBody&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final MediaType MEDIA_TYPE = MediaType.parse(&quot;application/json; charset=UTF-8&quot;);</span><br><span class="line">    private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">    private final Gson gson;</span><br><span class="line">    private final TypeAdapter&lt;T&gt; adapter;</span><br><span class="line">    DecodeRequestBodyConverter(Gson gson,TypeAdapter&lt;T&gt; adapter)&#123;</span><br><span class="line">        this.gson = gson;</span><br><span class="line">        this.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public RequestBody convert(T value) throws IOException &#123;</span><br><span class="line">        Buffer buffer = new Buffer(); //value.toString()</span><br><span class="line">        Writer writer = new OutputStreamWriter(buffer.outputStream(),UTF_8);</span><br><span class="line">        JsonWriter jsonWriter = gson.newJsonWriter(writer);</span><br><span class="line">        adapter.write(jsonWriter,value);</span><br><span class="line">        jsonWriter.flush();</span><br><span class="line">        return RequestBody.create(MEDIA_TYPE,buffer.readByteString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始使用：</p>
<p>TestDataApi.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface TestDataApi &#123;</span><br><span class="line">    @GET(&quot;/&quot;)</span><br><span class="line">    Call&lt;BaseObjectResult&lt;TestData&gt;&gt; getArrayData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="当data为对象时："><a href="#当data为对象时：" class="headerlink" title="当data为对象时："></a>当data为对象时：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">        .baseUrl(&quot;http://192.168.20.168:3000&quot;)</span><br><span class="line">        .addConverterFactory(DecodeConverterFactory.create())</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">TestDataApi testDataApi = retrofit.create(TestDataApi.class);</span><br><span class="line">Call&lt;BaseObjectResult&lt;TestData&gt;&gt; resultCall = testDataApi.getArrayData();</span><br><span class="line">resultCall.enqueue(new Callback&lt;BaseObjectResult&lt;TestData&gt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(Call&lt;BaseObjectResult&lt;TestData&gt;&gt; call, Response&lt;BaseObjectResult&lt;TestData&gt;&gt; response) &#123;</span><br><span class="line">        if(response.isSuccessful()) &#123;</span><br><span class="line">            if(response.body() != null) &#123;</span><br><span class="line">                TestData testData = response.body().data;</span><br><span class="line">                Log.d(&quot;hyj&quot;, &quot;msg=&quot; +  response.body().msg + &quot;  &quot;</span><br><span class="line">                        + &quot;status=&quot; + response.body().status + &quot;  &quot;</span><br><span class="line">                        + testData.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(Call&lt;BaseObjectResult&lt;TestData&gt;&gt; call, Throwable t) &#123;</span><br><span class="line">        ToastUtil.showShort(mContext, t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<blockquote>
<p>04-08 16:04:56.053 31894-31894/com.zhangsunyucong.chanxa.testproject D/hyj: msg=  status=200  testData:cnName=小红 age=24 IsBogy=false</p>
</blockquote>
<h5 id="当data为数组时："><a href="#当data为数组时：" class="headerlink" title="当data为数组时："></a>当data为数组时：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">                .baseUrl(&quot;http://192.168.20.168:3000&quot;)</span><br><span class="line">                .addConverterFactory(DecodeConverterFactory.create())</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TestDataApi testDataApi = retrofit.create(TestDataApi.class);</span><br><span class="line">        Call&lt;BaseArrayResult&lt;TestData&gt;&gt; resultCall = testDataApi.getArrayData();</span><br><span class="line">        resultCall.enqueue(new Callback&lt;BaseArrayResult&lt;TestData&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call&lt;BaseArrayResult&lt;TestData&gt;&gt; call, Response&lt;BaseArrayResult&lt;TestData&gt;&gt; response) &#123;</span><br><span class="line">                if(response.isSuccessful()) &#123;</span><br><span class="line">                    if(response.body() != null) &#123;</span><br><span class="line">                        List&lt;TestData&gt; testData = response.body().data;</span><br><span class="line">                        if(testData != null) &#123;</span><br><span class="line">                            for(int i = 0; i &lt; testData.size(); i++) &#123;</span><br><span class="line">                                Log.d(&quot;hyj&quot;, &quot;msg=&quot; +  response.body().msg + &quot;  &quot;</span><br><span class="line">                                        + &quot;status=&quot; + response.body().status + &quot;  &quot;</span><br><span class="line">                                        + testData.get(i).toString());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call&lt;BaseArrayResult&lt;TestData&gt;&gt; call, Throwable t) &#123;</span><br><span class="line">                ToastUtil.showShort(mContext, t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<blockquote>
<p>04-08 16:11:44.703 32440-32440/com.zhangsunyucong.chanxa.testproject D/hyj: msg=  status=200  testData:cnName=jakewharton age=13 IsBogy=true<br>04-08 16:11:44.703 32440-32440/com.zhangsunyucong.chanxa.testproject D/hyj: msg=  status=200  testData:cnName=小红 age=24 IsBogy=false</p>
</blockquote>
<h4 id="手动解释"><a href="#手动解释" class="headerlink" title="手动解释"></a>手动解释</h4><p>关键的代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ParameterizedType type(final Class raw, final Type... args) &#123;</span><br><span class="line">    return new ParameterizedType() &#123;</span><br><span class="line">        public Type getRawType() &#123;</span><br><span class="line">            return raw;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Type[] getActualTypeArguments() &#123;</span><br><span class="line">            return args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Type getOwnerType() &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当data返回的是对象时：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TestDataApi testDataApi = retrofit.create(TestDataApi.class);</span><br><span class="line">        Call&lt;String&gt; resultCall = testDataApi.getArrayData();</span><br><span class="line">        resultCall.enqueue(new Callback&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123;</span><br><span class="line">                if(response.isSuccessful()) &#123;</span><br><span class="line">                    if(response.body() != null) &#123;</span><br><span class="line">                        String testDataStr = response.body();</span><br><span class="line">                        Gson gson = new Gson();</span><br><span class="line"></span><br><span class="line">                        BaseObjectResult&lt;TestData&gt; testData = gson.fromJson(testDataStr,</span><br><span class="line">                                type(BaseObjectResult.class, TestData.class));</span><br><span class="line"></span><br><span class="line">                        Log.d(&quot;hyj&quot;, &quot;msg=&quot; +  testData.msg + &quot;  &quot;</span><br><span class="line">                                + &quot;status=&quot; + testData.status + &quot;  &quot;</span><br><span class="line">                                + testData.data.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call&lt;String&gt; call, Throwable t) &#123;</span><br><span class="line">                ToastUtil.showShort(mContext, t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>当返回的data是数组时：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TestDataApi testDataApi = retrofit.create(TestDataApi.class);</span><br><span class="line">        Call&lt;String&gt; resultCall = testDataApi.getArrayData();</span><br><span class="line">        resultCall.enqueue(new Callback&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123;</span><br><span class="line">                if(response.isSuccessful()) &#123;</span><br><span class="line">                    if(response.body() != null) &#123;</span><br><span class="line">                        String testDataStr = response.body();</span><br><span class="line">                        Gson gson = new Gson();</span><br><span class="line"></span><br><span class="line">                        BaseArrayResult&lt;TestData&gt; testData = gson.fromJson(testDataStr,</span><br><span class="line">                                type(BaseArrayResult.class, TestData.class));</span><br><span class="line"></span><br><span class="line">                        if(testData != null &amp;&amp; testData.data != null) &#123;</span><br><span class="line">                            for(int i = 0; i &lt; testData.data.size(); i++) &#123;</span><br><span class="line">                                Log.d(&quot;hyj&quot;, &quot;msg=&quot; +  testData.msg + &quot;  &quot;</span><br><span class="line">                                        + &quot;status=&quot; + testData.status + &quot;  &quot;</span><br><span class="line">                                        + testData.data.get(i).toString());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call&lt;String&gt; call, Throwable t) &#123;</span><br><span class="line">                ToastUtil.showShort(mContext, t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>它们返回的结果和第一种方法的返回结果是一样的。</p>
]]></content>
  </entry>
  <entry>
    <title>23种设计模式之《单例模式》</title>
    <url>/2018/04/04/java-pattern-singleton/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>单例模式是23种设计模式中最简单和易用的模式。在某些情境下，如在一个上市公司中，有很多不同级别的员工，但是公司的CEO或者CTO都是只有一个的，CEO或者CTO在公司里就要求是一个单例。单例模式，就是某个类因实际情况的需要，要求在全局的范围内只能有唯一的实例对象，这个对象是常驻内存的，可以重复使用，降低重复创建对象的开销。</p>
<h3 id="单例模式的特点"><a href="#单例模式的特点" class="headerlink" title="单例模式的特点"></a>单例模式的特点</h3><ul>
<li>类的构造函数是私有的</li>
<li>在类内部实例化对象，并通过静态方法向外提供实例化的对象</li>
</ul>
<p>下面主要讲解实现单例模式的方法以及它们的优缺点</p>
 <a id="more"></a>
<h3 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h3><p>单例模式的目的，就是要确保在全局范围内某个类的对象是唯一的。所以实现单例模式时，我们至少要考虑两个影响对象创建的因素。</p>
<ul>
<li>在并发的环境下的线程安全</li>
<li>反序列化</li>
</ul>
<h4 id="饿汉实现"><a href="#饿汉实现" class="headerlink" title="饿汉实现"></a>饿汉实现</h4><p>在类第一次加载时，就进行对象的实例化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private final static SingletonDemo mSingletonDemo = new SingletonDemo();</span><br><span class="line"></span><br><span class="line">    private SingletonDemo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance() &#123;</span><br><span class="line">        return mSingletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="懒汉实现"><a href="#懒汉实现" class="headerlink" title="懒汉实现"></a>懒汉实现</h4><p>在类加载时不进行对象的实例化，只在对象被第一次访问时，才进行对象的实例化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonDemo mSingletonDemo;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance() &#123;</span><br><span class="line">        if(mSingletonDemo == null) &#123;</span><br><span class="line">            mSingletonDemo = new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        return mSingletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明显，在多线程的环境下，上面两种实现方式都不是线程安全的。为了实现线程安全，我们首先可以想到使用synchronized关键字。</p>
<p>线程安全的懒汉模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonDemo mSingletonDemo;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized SingletonDemo getInstance() &#123;</span><br><span class="line"></span><br><span class="line">        if(mSingletonDemo == null) &#123;</span><br><span class="line">            mSingletonDemo = new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        return mSingletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于synchronized关键字说明一下，synchronized声明的静态方法，同时只能被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。即：两个线程可以同时访问一个对象的两个不同的synchronized方法，其中一个是静态方法，一个是非静态方法。</p>
<p>所以，当有多个线程同时访问getInstance静态方法时，多个其他的线程只能等待，这时只有一个线程能够访问getInstance方法，等这个线程释放后其他线程才能访问。这样就会影响速度和效率。</p>
<p>为了提高懒汉模式的速度和效率，可以减小锁的粒度和次数。</p>
<p>双重校验锁法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonDemo mSingletonDemo;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance() &#123;</span><br><span class="line">        if(mSingletonDemo == null) &#123;</span><br><span class="line">            synchronized (SingletonDemo.class) &#123;</span><br><span class="line">                if(mSingletonDemo == null) &#123;</span><br><span class="line">                    mSingletonDemo = new SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mSingletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，只有在第一次访问时才会锁定和创建类的对象，之后的访问都是直接使用已经创建好的对象，这样减少锁定的次数和范围，以达到提高单例模式的效率。</p>
<p>但是，对象的实例化，并不是一个原子性操作。即第11行代码处，它可以分成下面三个步骤：<br>1、new SingletonDemo()，为SingletonDemo实例分配内存<br>2、调用SingletonDemo的构造器，完成初始化工作<br>3、将mSingletonDemo指向分配的内存空间</p>
<p>由于java处理器可以乱序执行，即无法保证2和3的执行顺序。这对双重校验锁法实现的单例模式有什么影响呢？<br>当第一个线程访问getInstance方法时，会锁定临界区（第9行到第13行代码），它实例化对象的顺序是1=&gt;3=&gt;2，而在这时如果有第二个线程来访问getInstance方法，由于第一个线程在处理器中执行完了3未执行2，第二个线程会马上得到实例对象，因为第一个线程的3已经执行完即mSingletonDemo已经不为空。当第二个线程使用没有初始化的对象时就会出现问题。</p>
<p>所以，双重校验锁法也不是完美的，在并发环境下依然可能出现问题。</p>
<h4 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonDemo mSingletonDemo;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final SingletonDemo INSTANCE = new SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载SingletonDemo类时并不会实例化INSTANCE，只有在第一次调用getInstance方法时，才会加载SingletonHolder内部类，创建SingletonDemo实例。这种方式不仅确保了线程安全，也保证单例对象的唯一性，同时也实现了单例对象的懒加载。</p>
<h4 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h4><p>上面几种实现方式，可能会因为反序列化而创建新的实例，所以必须重写readResolve方法，在readResolve方法中返回已经创建的单例。</p>
<p>使用枚举可以很简单的实现单例模式，这也是Effective Java中提倡的方式。因为枚举本身就是类型安全的，并且枚举实例在任何情况下都是单例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum SingletonEnumDemo &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void justDoYourThing() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举单例使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SingletonEnumDemo.INSTANCE.justDoYourThing();</span><br></pre></td></tr></table></figure></p>
<h4 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, Object&gt; singletonMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    private SingletonDemo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void registerService(String key, Object instance)     &#123;</span><br><span class="line">        if (!singletonMap.containsKey(key)) &#123;</span><br><span class="line">            singletonMap.put(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getService(String key) &#123;</span><br><span class="line">        return singletonMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的retrofit源码分析</title>
    <url>/2018/03/08/android-retrofit/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文基于的retrofit版本是：2.1.0，文章会从retrofit的使用逐渐进入它的源码进行分析。retrofit是一个基于okhttp封装的，具有RESTful风格的HTTP网络请求框架。也就是说，它只负责网络接口配置和调用的封装，实际底层调用的工作还是由okhttp完成的。可以使用它以注解的形式配置请求的地址，请求参数等，还可以添加自定义拦截器、网络拦截器和数据转换器等进行处理和扩展。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><a id="more"></a>
<p>从使用开始讲起。</p>
<p>创建retrofit实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">        baseUrl(&quot;https://heyunjian.leanapp.cn/&quot;)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></p>
<p>从形式上看，可以知道retrofit的创建使用了建造者模式。下面我们进入它的源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public final class Retrofit &#123;</span><br><span class="line">  // 网络请求配置对象（对使用时的注解进行解析后得到的对象保存在里面）</span><br><span class="line">  private final Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  //网络请求器工厂</span><br><span class="line">  final okhttp3.Call.Factory callFactory;</span><br><span class="line">  </span><br><span class="line">  //网络请求的基地址</span><br><span class="line">  final HttpUrl baseUrl;</span><br><span class="line">  </span><br><span class="line">  //数据转换工厂</span><br><span class="line">  final List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">  </span><br><span class="line">  //网络请求适配器</span><br><span class="line">  final List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line">  </span><br><span class="line">  //回调方法执行器</span><br><span class="line">  final Executor callbackExecutor;</span><br><span class="line">  final boolean validateEagerly;</span><br><span class="line"></span><br><span class="line">  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories,</span><br><span class="line">      Executor callbackExecutor, boolean validateEagerly) &#123;</span><br><span class="line">    this.callFactory = callFactory;</span><br><span class="line">    this.baseUrl = baseUrl;</span><br><span class="line">    this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.</span><br><span class="line">    this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.</span><br><span class="line">    this.callbackExecutor = callbackExecutor;</span><br><span class="line">    this.validateEagerly = validateEagerly;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;) // Single-interface proxy creation guarded by parameter safety.</span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    if (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        new InvocationHandler() &#123;</span><br><span class="line">          private final Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">          @Override public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">              throws Throwable &#123;</span><br><span class="line">            // If the method is a method from Object then defer to normal invocation.</span><br><span class="line">            if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              return method.invoke(this, args);</span><br><span class="line">            &#125;</span><br><span class="line">            if (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            return serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private final Platform platform;</span><br><span class="line">    private okhttp3.Call.Factory callFactory;</span><br><span class="line">    private HttpUrl baseUrl;</span><br><span class="line">    private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();</span><br><span class="line">    private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;();</span><br><span class="line">    private Executor callbackExecutor;</span><br><span class="line">    private boolean validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      this.platform = platform;</span><br><span class="line">      // Add the built-in converter factory first. This prevents overriding its behavior but also</span><br><span class="line">      // ensures correct behavior when using converters that consume all types.</span><br><span class="line">      converterFactories.add(new BuiltInConverters());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder() &#123;</span><br><span class="line">      this(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Builder(Retrofit retrofit) &#123;</span><br><span class="line">      platform = Platform.get();</span><br><span class="line">      callFactory = retrofit.callFactory;</span><br><span class="line">      baseUrl = retrofit.baseUrl;</span><br><span class="line">      converterFactories.addAll(retrofit.converterFactories);</span><br><span class="line">      adapterFactories.addAll(retrofit.adapterFactories);</span><br><span class="line">      // Remove the default, platform-aware call adapter added by build().</span><br><span class="line">      adapterFactories.remove(adapterFactories.size() - 1);</span><br><span class="line">      callbackExecutor = retrofit.callbackExecutor;</span><br><span class="line">      validateEagerly = retrofit.validateEagerly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">    public Retrofit build() &#123;</span><br><span class="line">      if (baseUrl == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Base URL required.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      okhttp3.Call.Factory callFactory = this.callFactory;</span><br><span class="line">      if (callFactory == null) &#123;</span><br><span class="line">        callFactory = new OkHttpClient();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Executor callbackExecutor = this.callbackExecutor;</span><br><span class="line">      if (callbackExecutor == null) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Make a defensive copy of the adapters and add the default Call adapter.</span><br><span class="line">      List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);</span><br><span class="line">      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">      // Make a defensive copy of the converters.</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);</span><br><span class="line"></span><br><span class="line">      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">          callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Retrofit#Builder类中的成员变量和Retrofit的基本是一样的，这也正是建造者模式的特点。Retrofit的成员变量已经在源码中有注释。在Builder中，主要看Platform。</p>
<p>Platform的子类：<br><img src="http://o8bym0zmt.bkt.clouddn.com/android_retrofit_01.png" alt="图片"></p>
<p>主要有两个子类，对应着retrofit支持的平台：Android和java8的平台。</p>
<p>Platform子类Android的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Android extends Platform &#123;</span><br><span class="line">  @Override public Executor defaultCallbackExecutor() &#123;</span><br><span class="line">    return new MainThreadExecutor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">    return new ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static class MainThreadExecutor implements Executor &#123;</span><br><span class="line">    private final Handler handler = new Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    @Override public void execute(Runnable r) &#123;</span><br><span class="line">      handler.post(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainThreadExecutor静态内部类中，创建了主线程的handler，用于将请求处理的结果返回给Android主线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">retrofit.create(CSDNAPIService.class);</span><br></pre></td></tr></table></figure>
<p>进入create方法源码</p>
<p>Retrofit#create</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;) // Single-interface proxy creation guarded by parameter safety.</span><br><span class="line"> public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">   Utils.validateServiceInterface(service);</span><br><span class="line">   if (validateEagerly) &#123;</span><br><span class="line">     eagerlyValidateMethods(service);</span><br><span class="line">   &#125;</span><br><span class="line">   return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">       new InvocationHandler() &#123;</span><br><span class="line">         private final Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">         @Override public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">             throws Throwable &#123;</span><br><span class="line">           // If the method is a method from Object then defer to normal invocation.</span><br><span class="line">           if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">             return method.invoke(this, args);</span><br><span class="line">           &#125;</span><br><span class="line">           if (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">             return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">           &#125;</span><br><span class="line">           ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">               (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">           OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">           return serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，上面使用了动态代理。proxy就是反射创建的类对象，method是对象要调用的方法，args是要调用方法的参数。主要分析loadServiceMethod方法。</p>
<p>Retrofit#loadServiceMethod<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  if (result != null) return result;</span><br><span class="line"></span><br><span class="line">  synchronized (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    if (result == null) &#123;</span><br><span class="line">      result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>serviceMethodCache是一个缓存，首先从缓存中取数据，没有，线程锁定，调用ServiceMethod的相关代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</span><br></pre></td></tr></table></figure>
<p>主要工作在build方法中，</p>
<p>ServiceMethod#build</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ServiceMethod build() &#123;</span><br><span class="line">  callAdapter = createCallAdapter();</span><br><span class="line">  responseType = callAdapter.responseType();</span><br><span class="line">  if (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">    throw methodError(&quot;&apos;&quot;</span><br><span class="line">        + Utils.getRawType(responseType).getName()</span><br><span class="line">        + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">  for (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (httpMethod == null) &#123;</span><br><span class="line">    throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!hasBody) &#123;</span><br><span class="line">    if (isMultipart) &#123;</span><br><span class="line">      throw methodError(</span><br><span class="line">          &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isFormEncoded) &#123;</span><br><span class="line">      throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span><br><span class="line">          + &quot;request body (e.g., @POST).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">  for (int p = 0; p &lt; parameterCount; p++) &#123;</span><br><span class="line">    Type parameterType = parameterTypes[p];</span><br><span class="line">    if (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">      throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,</span><br><span class="line">          parameterType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">    if (parameterAnnotations == null) &#123;</span><br><span class="line">      throw parameterError(p, &quot;No Retrofit annotation found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (relativeUrl == null &amp;&amp; !gotUrl) &#123;</span><br><span class="line">    throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">    throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">    throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">    throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new ServiceMethod&lt;&gt;(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要看第11行，这里主要是解析使用时的各种配置注解。</p>
<p>ServiceMethod#parseMethodAnnotation<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void parseMethodAnnotation(Annotation annotation) &#123;</span><br><span class="line">  if (annotation instanceof DELETE) &#123;</span><br><span class="line">    parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);</span><br><span class="line">  &#125; else if (annotation instanceof GET) &#123;</span><br><span class="line">    parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</span><br><span class="line">  &#125; else if (annotation instanceof HEAD) &#123;</span><br><span class="line">    parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);</span><br><span class="line">    if (!Void.class.equals(responseType)) &#123;</span><br><span class="line">      throw methodError(&quot;HEAD method must use Void as response type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (annotation instanceof PATCH) &#123;</span><br><span class="line">    parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);</span><br><span class="line">  &#125; else if (annotation instanceof POST) &#123;</span><br><span class="line">    parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);</span><br><span class="line">  &#125; else if (annotation instanceof PUT) &#123;</span><br><span class="line">    parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);</span><br><span class="line">  &#125; else if (annotation instanceof OPTIONS) &#123;</span><br><span class="line">    parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);</span><br><span class="line">  &#125; else if (annotation instanceof HTTP) &#123;</span><br><span class="line">    HTTP http = (HTTP) annotation;</span><br><span class="line">    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">  &#125; else if (annotation instanceof retrofit2.http.Headers) &#123;</span><br><span class="line">    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">    if (headersToParse.length == 0) &#123;</span><br><span class="line">      throw methodError(&quot;@Headers annotation is empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    headers = parseHeaders(headersToParse);</span><br><span class="line">  &#125; else if (annotation instanceof Multipart) &#123;</span><br><span class="line">    if (isFormEncoded) &#123;</span><br><span class="line">      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    isMultipart = true;</span><br><span class="line">  &#125; else if (annotation instanceof FormUrlEncoded) &#123;</span><br><span class="line">    if (isMultipart) &#123;</span><br><span class="line">      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    isFormEncoded = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到具体的注解。</p>
<p>分析retrofit的同步和异步请求过程：</p>
<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><p>OkHttpCall#enqueue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">  if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call call;</span><br><span class="line">  Throwable failure;</span><br><span class="line"></span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</span><br><span class="line">    executed = true;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    failure = creationFailure;</span><br><span class="line">    if (call == null &amp;&amp; failure == null) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        failure = creationFailure = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (failure != null) &#123;</span><br><span class="line">    callback.onFailure(this, failure);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call.enqueue(new okhttp3.Callback() &#123;</span><br><span class="line">    @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">      Response&lt;T&gt; response;</span><br><span class="line">      try &#123;</span><br><span class="line">        response = parseResponse(rawResponse);</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      callSuccess(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void onFailure(okhttp3.Call call, IOException e) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        callback.onFailure(OkHttpCall.this, e);</span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void callFailure(Throwable e) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        callback.onFailure(OkHttpCall.this, e);</span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void callSuccess(Response&lt;T&gt; response) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        callback.onResponse(OkHttpCall.this, response);</span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看第15行，createRawCall()创建了call，call是一个接口，它的子类有RealCall.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Call extends Cloneable</span><br><span class="line"></span><br><span class="line">final class RealCall implements Call</span><br></pre></td></tr></table></figure>
<p>进入OkHttpCall#createRawCall方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private okhttp3.Call createRawCall() throws IOException &#123;</span><br><span class="line">  Request request = serviceMethod.toRequest(args);</span><br><span class="line">  okhttp3.Call call = serviceMethod.callFactory.newCall(request);</span><br><span class="line">  if (call == null) &#123;</span><br><span class="line">    throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它用参数创建http请求对象，然后创建call，并返回。</p>
<p>分析newCall方法，是callFactory的方法，看Factory<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Factory &#123;</span><br><span class="line">    Call newCall(Request request);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>它被OkHttpClient实现，所以会到OkHttpClient的newCall</p>
<p>OkHttpClient#newCall</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">    return new RealCall(this, request, false /* for web socket */);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>现在分析到了RealCall。异步和同步请求调用的方法，都会来到RealCall调用enqueue和execute方法。</p>
<p>看异步的enqueue方法<br>RealCall#enqueue<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">      executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>看第7行，AsyncCall是一个Runnable任务，会提交给线程池执行。responseCallback是异步请求结果的回调。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class AsyncCall extends NamedRunnable</span><br><span class="line"></span><br><span class="line">public abstract class NamedRunnable implements Runnable</span><br></pre></td></tr></table></figure>
<p>responseCallback是一个Callback</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Callback &#123;</span><br><span class="line"></span><br><span class="line">  void onFailure(Call call, IOException e);</span><br><span class="line"></span><br><span class="line">  void onResponse(Call call, Response response) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AsyncCall是一个Runnable任务，那它做的任务是什么呢？</p>
<p>AsyncCall#execute<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          // Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的第4行getResponseWithInterceptorChain返回了请求的结果，其实它里面发生了整个请求的过程。等一下会进去分析它是如何责任链的调用拦截器的和它是怎样根据响应结果调用callback的回调方法的。</p>
<p>AsyncCall#execute是重写NamedRunnable中的execute方法的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class NamedRunnable implements Runnable &#123;</span><br><span class="line">  protected final String name;</span><br><span class="line"></span><br><span class="line">  public NamedRunnable(String format, Object... args) &#123;</span><br><span class="line">    this.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public final void run() &#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到，在任务的主要工作run方法中，调用了execute方法。而主要工作做了什么？就是上面的AsyncCall#execute所做的。</p>
<p>回到前面，RealCall#enqueue，进入第7行的Dispatcher的enqueue</p>
<p>Dispatcher#enqueue<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>runningAsyncCalls保存了异步执行的任务，它的解析如下的英文解释。如果同时执行的任务数没有超过线程池的最大可执行次数，就直接放到线程池中执行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  private int maxRequests = 64;</span><br><span class="line">  private int maxRequestsPerHost = 5;</span><br></pre></td></tr></table></figure></p>
<p>之前在分析AsyncCall#execute时说过，在第4行的getResponseWithInterceptorrChain中完成了整个网络请求的过程，在过程中责任链式的调用了拦截器和网络拦截器。下面从源码上分析拦截器的调用过程。</p>
<p>AsyncCall#getResponseWithInterceptorChain<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(</span><br><span class="line">      interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，是先将所有的拦截器放到了interceptors列表中。然后在第14到16行调用了拦截器。这里还有一个主要的分析工作，就是各个系统提供的拦截器在网络请求过程负责做了什么。（本篇文章没讲）</p>
<p>RealInterceptorChain#proceed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">    RealConnection connection) throws IOException &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // Call the next interceptor in the chain.</span><br><span class="line">  RealInterceptorChain next = new RealInterceptorChain(</span><br><span class="line">      interceptors, streamAllocation, httpCodec, connection, index + 1, request);</span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index刚开始是0，从第一个拦截器开始调用，在RealInterceptorChain#proceed中又创建了下一个RealInterceptorChain，然后执行当前拦截器。</p>
<p>到这里暂停一下，先了解一个拦截器是怎么样定义的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomInterceptor implements Interceptor &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        ...</span><br><span class="line">        //做拦截器做的事情</span><br><span class="line">        ...</span><br><span class="line">        return chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后那条语句正和AsyncCall#getResponseWithInterceptorChain的最后一句是一样的。这样子就形成了一条链，不断的index + 1即一个一个的按顺序执行完所有的拦截器，而每个拦截器负责自己的责任，这就是责任链模式。</p>
<h4 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h4><p>OkHttpCall#execute<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class="line">  okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</span><br><span class="line">    executed = true;</span><br><span class="line"></span><br><span class="line">    if (creationFailure != null) &#123;</span><br><span class="line">      if (creationFailure instanceof IOException) &#123;</span><br><span class="line">        throw (IOException) creationFailure;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw (RuntimeException) creationFailure;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    if (call == null) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; catch (IOException | RuntimeException e) &#123;</span><br><span class="line">        creationFailure = e;</span><br><span class="line">        throw e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同异步请求分析中一样，主要都是调用createRawCall方法，这在上面已经分析。然后会到OkHttpClient中调用的execute方法。因为是同步请求，最后在parseResponse中解析了请求返回的结果，回调给Android前端。</p>
<p>OkHttpClient#execute<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">    executed = true;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  try &#123;</span><br><span class="line">    client.dispatcher().executed(this);</span><br><span class="line">    Response result = getResponseWithInterceptorChain();</span><br><span class="line">    if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    client.dispatcher().finished(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第8行，进入源码是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */</span><br><span class="line">synchronized void executed(RealCall call) &#123;</span><br><span class="line">  runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将RealCall添加到runningSyncCalls.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */</span><br><span class="line"> private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>在第9行，同样是调用了getResponseWithInterceptorChain方法得到请求的结果，这个在异步请求分析中已经讲过。</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的布局加载器LayoutInflater</title>
    <url>/2018/02/23/android-layout-inflater/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)</p>
<p>主要是从源码角度理解下面三段代码的区别：</p>
<blockquote>
<p>mInflater.inflate(R.layout.item, null);<br>mInflater.inflate(R.layout.item, parent ,false);<br>mInflater.inflate(R.layout.item, parent ,true);</p>
</blockquote>
<p>第一句：直接返回了布局，不正确处理布局参数<br>第二句：返回布局，并能正确处理了布局参数<br>第三句：返回布局，能正确处理了布局参数，并将布局添加到parent中</p>
<a id="more"></a>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>从下面使用代码开始：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LayoutInflater layoutInflater = LayoutInflater.from(HomeAcivity.this);</span><br><span class="line">layoutInflater.inflate(R.layout.layout_rv_photo_item, null);</span><br><span class="line">layoutInflater.inflate(R.layout.layout_rv_photo_item,</span><br><span class="line">        (ViewGroup)findViewById(android.R.id.content),</span><br><span class="line">        false);</span><br><span class="line">layoutInflater.inflate(R.layout.layout_rv_photo_item,</span><br><span class="line">        (ViewGroup)findViewById(android.R.id.content),</span><br><span class="line">        true);</span><br></pre></td></tr></table></figure></p>
<p>最后会都会来到这里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    synchronized (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">        final Context inflaterContext = mContext;</span><br><span class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[0];</span><br><span class="line">        mConstructorArgs[0] = inflaterContext;</span><br><span class="line">        //result是根布局</span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // Look for the root node.</span><br><span class="line">            int type;</span><br><span class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                // Empty</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                throw new InflateException(parser.getPositionDescription()</span><br><span class="line">                        + &quot;: No start tag found!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String name = parser.getName();</span><br><span class="line"></span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                System.out.println(&quot;**************************&quot;);</span><br><span class="line">                System.out.println(&quot;Creating root view: &quot;</span><br><span class="line">                        + name);</span><br><span class="line">                System.out.println(&quot;**************************&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Temp is the root view that was found in the xml</span><br><span class="line">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                if (root != null) &#123;</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Create layout params that match root, if supplied</span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    if (!attachToRoot) &#123;</span><br><span class="line">                        // Set the layout params for temp if we are not</span><br><span class="line">                        // attaching. (If we are, we use addView, below)</span><br><span class="line">                        //第二句的关键</span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Inflate all children under temp against its context.</span><br><span class="line">                rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // We are supposed to attach all the views we found (int temp)</span><br><span class="line">                // to root. Do that now.</span><br><span class="line">                //第三句话的关键</span><br><span class="line">                if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Decide whether to return the root that was passed in or the</span><br><span class="line">                // top view found in xml.</span><br><span class="line">                //parent为空或者第三个参数为false，都是直接返回第一个参数设置的布局，</span><br><span class="line">                //否则返回parent</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">            final InflateException ie = new InflateException(e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            throw ie;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            final InflateException ie = new InflateException(parser.getPositionDescription()</span><br><span class="line">                    + &quot;: &quot; + e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            throw ie;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // Don&apos;t retain static reference on context.</span><br><span class="line">            mConstructorArgs[0] = lastContext;</span><br><span class="line">            mConstructorArgs[1] = null;</span><br><span class="line"></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerThread和IntentService</title>
    <url>/2018/02/23/android-intentservice-handlerthread/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在这一篇文章中，会看HandlerThread和IntentService的源码。为什么一起讲它们呢？在Android中有一条思路，就是从java的线程，到Android中的消息机制，到将java线程和消息机制结合就是HandlerThread，而IntentService就是在HandlerThread基础上再与service结合在一起。</p>
<p>关于Android中的异步的东西，还有AsyncTask，AsyncTask是对java中的线程池的再次封装。进一步，可以联想到Loader.</p>
<a id="more"></a>
<p>回到本篇文章主题。</p>
<p>HandlerThread是一个直接继承于Thread的，并在run方法中将线程的Looper进行常规的初始化。而我们要做的就是提供一个Handler，并将Handler与HanderThread的Looper进行关联，通过Handler发送消息和处理消息。</p>
<p>IntentService直接继承于Service，在它的内部封装了HandlerThread的使用过程：提供一个Handler（即：ServiceHandler），并将Handler与HanderThread的Looper进行关联，然后它进一步将启动Service的Intent以消息的形式，通过Handler传给onHandleIntent方法，然后IntentService优雅的结束自己。我们要做的就是在onHandleIntent中做线程要做的事情。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>HandlerThread.jva</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HandlerThread extends Thread &#123;</span><br><span class="line">    int mPriority;</span><br><span class="line">    int mTid = -1;</span><br><span class="line">    Looper mLooper;</span><br><span class="line">    private @Nullable Handler mHandler;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    protected void onLooperPrepared() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandlerThread的run方法做了主要的工作。创建Looper，在onLooperPrepare做开始循环前的初始化工作，开始Looper循环。</p>
<p>在具体使用HandlerThread时，就是创建Handler，将Handler与HandlerThread的Looper进行关联，然后通过Handler发送消息，处理消息。说明，消息是在HandlerThread线程中处理的。</p>
<p>IntentService.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class IntentService extends Service &#123;</span><br><span class="line">    private volatile Looper mServiceLooper;</span><br><span class="line">    private volatile ServiceHandler mServiceHandler;</span><br><span class="line">    private String mName;</span><br><span class="line">    private boolean mRedelivery;</span><br><span class="line"></span><br><span class="line">    private final class ServiceHandler extends Handler &#123;</span><br><span class="line">        public ServiceHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates an IntentService.  Invoked by your subclass&apos;s constructor.</span><br><span class="line">     *</span><br><span class="line">     * @param name Used to name the worker thread, important only for debugging.</span><br><span class="line">     */</span><br><span class="line">    public IntentService(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        // TODO: It would be nice to have an option to hold a partial wakelock</span><br><span class="line">        // during processing, and to have a static startService(Context, Intent)</span><br><span class="line">        // method that would launch the service &amp; hand off a wakelock.</span><br><span class="line"></span><br><span class="line">        super.onCreate();</span><br><span class="line">        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * You should not override this method for your IntentService. Instead,</span><br><span class="line">     * override &#123;@link #onHandleIntent&#125;, which the system calls when the IntentService</span><br><span class="line">     * receives a start request.</span><br><span class="line">     * @see android.app.Service#onStartCommand</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Unless you provide binding for your service, you don&apos;t need to implement this</span><br><span class="line">     * method, because the default implementation returns null.</span><br><span class="line">     * @see android.app.Service#onBind</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @Nullable</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * This method is invoked on the worker thread with a request to process.</span><br><span class="line">     * Only one Intent is processed at a time, but the processing happens on a</span><br><span class="line">     * worker thread that runs independently from other application logic.</span><br><span class="line">     * So, if this code takes a long time, it will hold up other requests to</span><br><span class="line">     * the same IntentService, but it will not hold up anything else.</span><br><span class="line">     * When all requests have been handled, the IntentService stops itself,</span><br><span class="line">     * so you should not call &#123;@link #stopSelf&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param intent The value passed to &#123;@link</span><br><span class="line">     *               android.content.Context#startService(Intent)&#125;.</span><br><span class="line">     *               This may be null if the service is being restarted after</span><br><span class="line">     *               its process has gone away; see</span><br><span class="line">     *               &#123;@link android.app.Service#onStartCommand&#125;</span><br><span class="line">     *               for details.</span><br><span class="line">     */</span><br><span class="line">    @WorkerThread</span><br><span class="line">    protected abstract void onHandleIntent(@Nullable Intent intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IntentService是一个service子类,在onCreate中初始化了HandlerThread和ServiceHandler，并将ServiceHandler与HandlerThread的Looper进行关联。在onStart中，将启动服务的Intent封装进Message中，然后发给ServiceHandler。ServiceHandler再将Intent传递给onHandleIntent，最后优雅的结束自己。</p>
<p>在具体使用IntentService时，就是在onHandleIntent中正确的处理启动service的Intent即可。说明，onHandleIntent做的事情是在HandlerThread中进行的，因为HandlerThread的Looper与ServiceHandler已经关联，onHandleIntent是在ServiceHandler中被调用的（好啰嗦）。</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>从矩阵来看Android中的一些动画变换</title>
    <url>/2018/02/07/android-animation-matrix/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>这篇博客具体的分析过程和android实例。我只是参考和根据自己的理解写的。</p>
<p>在Android中，我们可以从数学的角度来看颜色和动画的变换。这里会从矩阵变换的角度来理解平移，旋转，缩放，对称的变换。</p>
<p>这些变换的完成实际上，是操作一个3X3的矩阵的。而这四种基本变换与操作和这个矩阵有什么样的关系呢？下面会分析。<br><a id="more"></a></p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/03b9c69abfa978f94a49/animation_1.webp" alt="图片"></p>
<p>在Android中，已经为每种变换提供了pre、set和post三种操作方式。</p>
<blockquote>
<p>set  用于设置Matrix中的值。<br>pre  是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。<br>post 是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。</p>
</blockquote>
<p>另外，除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。</p>
<h4 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h4><p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/fe9aa86ab2a0bbc56eb0/animation_2.webp" alt="图片"></p>
<p>假设坐标系中有A和B两个点，从A平移到B点，它们之间的关系上图所示。</p>
<p>在x和y轴的移动增量分别是：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/cdaf9f453e2d6efb91cb/animation_3.webp" alt="图片"><br>则易得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/c5a5b8efcf6ed61221b1/animation_4.webp" alt="图片"><br>它的矩阵表示为：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/ab695a92065590057f1e/animation_5.webp" alt="图片"></p>
<h4 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h4><h5 id="1、围绕坐标原点旋转"><a href="#1、围绕坐标原点旋转" class="headerlink" title="1、围绕坐标原点旋转"></a>1、围绕坐标原点旋转</h5><p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/bcc4b62b1c1c83c66309/animation_6.webp" alt="图片"></p>
<p>由A点顺时针旋转一定角度到B点，如图所示。</p>
<p>由图易知：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/b361c4c8b5ee3ddefe0a/animation_7.webp" alt="图片"><br>由上面四个式子，可得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/4dbce83f734b2c64d752/animation_8.webp" alt="图片"><br>矩阵表示，得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/8655b94159245cf51e8e/animation_9.webp" alt="图片"></p>
<h4 id="旋转变换-1"><a href="#旋转变换-1" class="headerlink" title="旋转变换"></a>旋转变换</h4><h5 id="2、围绕某点旋转"><a href="#2、围绕某点旋转" class="headerlink" title="2、围绕某点旋转"></a>2、围绕某点旋转</h5><p>假设旋转点是：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/e39ab77b94bd83533556/animation_10.webp" alt="图片"><br>顺时针旋转，结合1、上面的推导结果，可以得到矩阵：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/1111fb5a691d659d3dde/animation_11.webp" alt="图片"><br>可以化为：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/675b73c992ddca772273/animation_12.webp" alt="图片"></p>
<p>可知，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。</p>
<h4 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h4><p>A点的x，y坐标分别放大a,b倍。则有一下关系：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/77cfb20ef5450ce3bf08/animation_13.webp" alt="图片"><br>用三维矩阵表示为：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/b402f4c6573091743b19/animation_14.webp" alt="图片"></p>
<h4 id="对称变换"><a href="#对称变换" class="headerlink" title="对称变换"></a>对称变换</h4><p>1、如果对称轴是x轴，则有：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/e3a32d63188f1f5d43ba/animation_15.webp" alt="图片"><br>用三维矩阵表示为：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/e3b88e68010c6e26a9fc/animation_16.webp" alt="图片"></p>
<p>2、如果对称轴是y轴，则有：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/eaf65efb3f2d09ca8b17/animation_17.webp" alt="图片"><br>用三维矩阵表示为：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/945035d856a64969e084/animation_18.webp" alt="图片"></p>
<p>3、如果对称轴是y = x轴，如图<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/7aa08e07c1214173aa76/animation_19.webp" alt="图片"><br>由等腰直角三角形可知：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/1987ab6a4d9cb3db1fe4/animation_20.webp" alt="图片"><br>已知中点在对称轴上，由中点坐标公式，易得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/51f091b80b174ffeb4c3/animation_21.webp" alt="图片"><br>联合两式子，2式先乘以2，再两式相加和相减，可得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/a81b88c218a63ec543b6/animation_22.webp" alt="图片"><br>用三维矩阵表示为：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/d0417081ffca826e8ad4/animation_23.webp" alt="图片"><br>4、如果对称轴是y = -x轴。<br> 同理，易推导得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/bb55d017f368ffecf989/animation_24.webp" alt="图片"></p>
<p>5、如果对称轴是y = kx时。如图</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/e63b0497138d08196f47/animation_25.webp" alt="图片"></p>
<p>由图易知：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/f91d159cf7197ae2279b/animation_26.webp" alt="图片"><br>则有：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/83c70100fc9321982825/animation_27.webp" alt="图片"><br>由直线的斜率公式，可得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/ec6e3bdf2a96312f4c1e/animation_28.webp" alt="图片"><br>中点坐标在直线上，结合中点坐标公式，易得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/43ff1ca99a16a0ae6fb9/animation_29.webp" alt="图片"><br>由上面两式，可求得：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/9c2cb132d94bc8d91594/animation_30.webp" alt="图片"><br>用三维矩阵表示为：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/ec6caffc494af243eb27/animation_31.webp" alt="图片"></p>
<p>k为任意实数，可以取特殊的值，验证前面对称推导的结果。k为1或者-1时，k为0时，k为无穷大时等等。</p>
<p>6、如果对称轴是y = kx + b时</p>
<p>只需要在5的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/0b48148baf85e06cfa6d/animation_32.webp" alt="图片"></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中绘制简单几何图形和路径Path</title>
    <url>/2018/02/06/android-simple-draw-and-path/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>马上就到2018年过年了，然后我又刚好有兴致，就来玩玩Android中的简单几何图形的绘制和使用Path类来绘制路径。</p>
<h3 id="Path和Canvas"><a href="#Path和Canvas" class="headerlink" title="Path和Canvas"></a>Path和Canvas</h3><p>在Android中，和我们平时画图一样是有画笔和画布的，Path是画笔，Canvas是画布。与画的样式属性有关，如大小或者颜色等，是由Path来完成的；<a id="more"></a>与画的形状，即画什么东西是由Canva完成的。关于这两个类的各个属性和方法的具体使用，可以浏览<a href="http://blog.csdn.net/aigestudio/article/details/41316141" target="_blank" rel="noopener">爱哥的博客</a>几篇文章。在这里，只是用它们简单的几个函数画一些简单的图形，最后还会给出一个综合一点的demo,主要是为了加强认识绘制时坐标关系。</p>
<p>先贴上我的代码：<br>布局文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:id=&quot;@+id/root_draw_view&quot;</span><br><span class="line">    android:gravity=&quot;center_horizontal&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;有点意思&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.example.hyj.ht_test.widget.draw.MyDrawView</span><br><span class="line">        android:layout_width=&quot;300dp&quot;</span><br><span class="line">        android:layout_height=&quot;300dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>MyDrawView.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyDrawView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private Paint mPointPaint;</span><br><span class="line">    private float[] mFPts;</span><br><span class="line">    private RectF mRectF;</span><br><span class="line">    private RectF mRectOvalF;</span><br><span class="line">    private RectF mRightBottomRectF;</span><br><span class="line">    private Path mPath;</span><br><span class="line">    private Path mPath1;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int mPointStrokeWidth;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mPointStrokeWidth = 20;</span><br><span class="line">        mPointPaint = new Paint();</span><br><span class="line">        mPointPaint.setColor(Color.RED);</span><br><span class="line">        mPointPaint.setStrokeWidth(mPointStrokeWidth);</span><br><span class="line">        mPointPaint.setStyle(Paint.Style.FILL);</span><br><span class="line"></span><br><span class="line">        mPath = new Path();</span><br><span class="line">        mPath1 = new Path();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        //super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int widthResult = 100;</span><br><span class="line">        int heightResult = 100;</span><br><span class="line"></span><br><span class="line">        if(widthMode != MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            widthResult = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(heightMode != MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            heightResult = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int resultSize = widthResult &gt; heightResult</span><br><span class="line">                ? heightResult : widthResult;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(resultSize, resultSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">        super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        mFPts = new float[] &#123;</span><br><span class="line">                0, 0,</span><br><span class="line">                getMeasuredWidth() / 2, 0,</span><br><span class="line">                getMeasuredWidth(), 0,</span><br><span class="line">                getMeasuredWidth(), getMeasuredHeight() / 2,</span><br><span class="line">                getMeasuredWidth(), getMeasuredHeight(),</span><br><span class="line">                getMeasuredWidth() / 2, getMeasuredHeight(),</span><br><span class="line">                0, getMeasuredHeight(),</span><br><span class="line">                0, getMeasuredHeight() /2,</span><br><span class="line">                getMeasuredHeight() / 2, getMeasuredHeight() /2</span><br><span class="line">        &#125;;</span><br><span class="line">        mRectF = new RectF(0, 0, getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">        mRectOvalF = new RectF(mPointStrokeWidth, mPointStrokeWidth,</span><br><span class="line">                getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() / 2);</span><br><span class="line">        mRightBottomRectF = new RectF(getMeasuredWidth() / 2, getMeasuredHeight() /2,</span><br><span class="line">                getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() - mPointStrokeWidth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        canvas.drawLine(mFPts[0], mFPts[1], mFPts[2], mFPts[2], mPointPaint);</span><br><span class="line">        mPointPaint.setColor(Color.BLUE);</span><br><span class="line">        canvas.drawLines(mFPts, mPointPaint);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MyDrawView中没有考虑padding的影响。</p>
<h4 id="画点"><a href="#画点" class="headerlink" title="画点"></a>画点</h4><p>几何图形中，最简单的就是点了，首先画点。</p>
<blockquote>
<p>drawPoint(float x, float y, Paint paint)<br>drawPoints(float[] pts, Paint paint)<br>drawPoints(float[] pts, int offset, int count, Paint paint)</p>
</blockquote>
<p>x是点的横坐标，y是点的纵坐标。坐标的点也可以放到数组pts中，可见数组的个数一般是偶数个，offset是开始绘制前，数组中忽略的元素个数。count是忽略了offset个点后，开始取count个元素来绘制点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawPoints(mFPts, mPointPaint);</span><br><span class="line">mPointPaint.setColor(Color.BLUE);</span><br><span class="line">canvas.drawPoint(getMeasuredWidth() / 2, 0, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/0137912d8d855b463c91/view_1.PNG" alt="图片"></p>
<h4 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h4><p>由点组成线，两点确定一条直线。</p>
<blockquote>
<p>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)<br>drawLines(float[] pts, int offset, int count, Paint paint)<br>drawLines(float[] pts, Paint paint)</p>
</blockquote>
<p>第一个是，直接指定直线的两个点坐标。pts是点的坐标，每两个数组元素确定一个点坐标，每四个元素确定直线的两个点的坐标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawLine(mFPts[0], mFPts[1], mFPts[2], mFPts[2], mPointPaint);</span><br><span class="line">mPointPaint.setColor(Color.BLUE);</span><br><span class="line">canvas.drawLines(mFPts, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/98146239cce52a2402b3/view_2.PNG" alt="图片"></p>
<h4 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h4><p>由线可以组成面。矩形可以是长方形，也可以是正方形。</p>
<p>RectF和Rect的区别是参数的类型不同，RectF的参数类型是float，Rect的参数类型是int。</p>
<blockquote>
<p>drawRect(float left, float top, float right, float bottom, Paint paint)<br>drawRect(float left, float top, float right, float bottom, Paint paint)<br>drawRect(Rect r, Paint paint)<br>drawRect( RectF rect, Paint paint)</p>
</blockquote>
<p>也就是，可以在RectF或者Rect中指定好顶点坐标再传给drawRect，也可以在drawRect方法中直接指定顶点坐标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mRectF = new RectF(0, 0, getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">canvas.drawRect(mRectF, mPointPaint);</span><br></pre></td></tr></table></figure>
<p>代码说明，第一行代码是在onSizeChanged重写方法中的，第二行代码是在onDraw方法中的。因为onDraw方法是会不断被调用的，不适合在里面创建对象。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/63050494b78ffb48f530/view_3.PNG" alt="图片"></p>
<h4 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h4><p>圆角矩形是在矩形的基础上生成的。</p>
<blockquote>
<p>drawRoundRect(RectF rect, float rx, float ry, Paint paint)<br>drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)</p>
</blockquote>
<p>rx是生成圆角的椭圆的X轴半径<br>ry是生成圆角的椭圆的Y轴半径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawRoundRect(mRectF, getMeasuredWidth() / 4, getMeasuredHeight() / 4, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/6604a82ccbc74a880f80/view_4.PNG" alt="图片"></p>
<h4 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h4><p>圆要指定圆心的坐标和半径的大小。</p>
<blockquote>
<p>drawCircle(float cx, float cy, float radius, Paint paint)</p>
</blockquote>
<p>cx和cy分别是圆心的横坐标和纵坐标，radius为半径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2,</span><br><span class="line">                getMeasuredHeight() / 2 - mPointStrokeWidth, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/a20057b311348c03cd59/view_5.PNG" alt="图片"></p>
<h4 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h4><p>椭圆是在矩形基础上生成的，以矩形的长为长轴，矩形的宽为短轴。特殊的，当长轴等于短轴时，椭圆就是圆。</p>
<blockquote>
<p>drawOval(RectF oval, @NonNull Paint paint)<br>drawOval(float left, float top, float right, float bottom, Paint paint)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mRectOvalF = new RectF(mPointStrokeWidth, mPointStrokeWidth,</span><br><span class="line">                getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() / 2);</span><br><span class="line">                </span><br><span class="line">canvas.drawOval(mRectOvalF, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/75b566b3569764fb6cbb/view_6.PNG" alt="图片"></p>
<h4 id="画弧"><a href="#画弧" class="headerlink" title="画弧"></a>画弧</h4><p>弧是在椭圆上按一定角度截取的一部分。</p>
<blockquote>
<p>drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)<br>drawArc(float left, float top, float right, float bottom, float startAngle,<br>            float sweepAngle, boolean useCenter, Paint paint)</p>
</blockquote>
<p>oval是椭圆基于的矩形顶点的矩阵，或者在方法中直接指定四个顶点，startAngle是截取的起始角度，sweepAngle是弧持续的角度，useCenter是否显示长短半径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawArc(mRectOvalF, 0, 90, true, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/afd89ebf4c491df8de37/view_7.PNG" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawArc(mRectOvalF, 0, 90, false, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/b1ea89ed3f57c9cb2570/view_8.PNG" alt="图片"></p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>在View的绘制过程中，有一个类叫做Path，Path可以帮助我们实现很多自定义形状的路径，特别是配合xfermode属性来使用的时候，可以实现很多效果。</p>
<h4 id="moveTo"><a href="#moveTo" class="headerlink" title="moveTo"></a>moveTo</h4><p>路径开始绘制的点叫起始点坐标，默认是（0，0）。可以使用moveTo将绘制路径的起始点移动到某个位置。moveTo不进行绘制，一般用来移动画笔。</p>
<h4 id="lineTo"><a href="#lineTo" class="headerlink" title="lineTo"></a>lineTo</h4><p>lineTo用来绘制一条直线路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mPath.moveTo(getMeasuredWidth()/ 2, getMeasuredHeight() / 2);</span><br><span class="line">mPath.lineTo(getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br></pre></td></tr></table></figure>
<p>直线路径的起始点是(getMeasuredWidth()/ 2, getMeasuredHeight() / 2)，终点是(getMeasuredWidth(), getMeasuredHeight())</p>
<p><img src="http://o8bym0zmt.bkt.clouddn.com/android_draw_8.png" alt="图片"></p>
<h4 id="quadTo"><a href="#quadTo" class="headerlink" title="quadTo"></a>quadTo</h4><p>quadTo用来画由一个控制点控制的贝塞尔曲线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mPath.moveTo(mPointStrokeWidth, getMeasuredHeight() / 2);</span><br><span class="line">mPath.quadTo(0, 0, getMeasuredWidth() / 2, mPointStrokeWidth);</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br></pre></td></tr></table></figure>
<p>起始点是(mPointStrokeWidth, getMeasuredHeight() / 2)，控制点是（0， 0），终点是（getMeasuredWidth() / 2, mPointStrokeWidth）</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/ed32d6ab8185f3c229dc/view_9.PNG" alt="图片"></p>
<h4 id="cubicTo"><a href="#cubicTo" class="headerlink" title="cubicTo"></a>cubicTo</h4><p>cubicTo用来画由两个控制点控制的贝塞尔曲线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mPath.moveTo(mPointStrokeWidth, getMeasuredHeight() / 2);</span><br><span class="line">mPath.cubicTo(0, 0, getMeasuredWidth() / 2, mPointStrokeWidth,</span><br><span class="line">         getMeasuredWidth(), getMeasuredHeight() / 2);</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br></pre></td></tr></table></figure>
<p>起始点是(mPointStrokeWidth, getMeasuredHeight() / 2)，两个控制点是（0， 0）和（getMeasuredWidth() / 2, mPointStrokeWidth），终点是（getMeasuredWidth(), getMeasuredHeight() / 2）。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/23c8b977f5f702b7d861/view_10.PNG" alt="图片"></p>
<h4 id="arcTo"><a href="#arcTo" class="headerlink" title="arcTo"></a>arcTo</h4><p>arcTo用来画一条圆弧路径。与前面画圆弧一样的，圆弧是截取椭圆的一部分，而椭圆是基于矩形的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mRectOvalF = new RectF(mPointStrokeWidth, mPointStrokeWidth,</span><br><span class="line">    getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() / 2);</span><br><span class="line">mPath.arcTo(mRectOvalF, 0, 90, false);</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br></pre></td></tr></table></figure>
<p>和刚开始的圆弧参数定义一样，指定基于的矩形的四个顶点，startAngle截取的起始角度，sweepAngle弧持续的角度，useCenter是否显示长短半径。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/cbab76d38d97de94d2a8/view_11.PNG" alt="图片"></p>
<h3 id="Path的addArc、addRoundRect、addOval、addRect、addCircle"><a href="#Path的addArc、addRoundRect、addOval、addRect、addCircle" class="headerlink" title="Path的addArc、addRoundRect、addOval、addRect、addCircle"></a>Path的addArc、addRoundRect、addOval、addRect、addCircle</h3><p>它们实现的几何路径,可以自己尝试一下。</p>
<h3 id="Path-Op"><a href="#Path-Op" class="headerlink" title="Path.Op"></a>Path.Op</h3><p>在开头，mPointPaint首先设置画笔的样式为描边STROKE，后面为了更好看出Path.Op的效果会改为FILL填充。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mRightBottomRectF = new RectF(getMeasuredWidth() / 2, getMeasuredHeight() /2, getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() - mPointStrokeWidth);</span><br><span class="line"></span><br><span class="line">mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2,</span><br><span class="line">    getMeasuredHeight() / 2 - mPointStrokeWidth, Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br><span class="line">mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(mPath1, mPointPaint);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/5a6e66afe4cfc65b17d3/view_12.PNG" alt="图片"></p>
<h4 id="Path-Op-DIFFERENCE"><a href="#Path-Op-DIFFERENCE" class="headerlink" title="Path.Op.DIFFERENCE"></a>Path.Op.DIFFERENCE</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2,</span><br><span class="line">                getMeasuredHeight() / 2 - mPointStrokeWidth,</span><br><span class="line">                Path.Direction.CCW);</span><br><span class="line">mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);</span><br><span class="line">mPath.op(mPath1, Path.Op.DIFFERENCE);</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/cd9ee5dbe873ce778fee/view_13.PNG" alt="图片"></p>
<h4 id="Path-Op-INTERSECT"><a href="#Path-Op-INTERSECT" class="headerlink" title="Path.Op.INTERSECT"></a>Path.Op.INTERSECT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2,</span><br><span class="line">                getMeasuredHeight() / 2 - mPointStrokeWidth,</span><br><span class="line">                Path.Direction.CCW);</span><br><span class="line">mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);</span><br><span class="line">mPath.op(mPath1, Path.Op.INTERSECT);</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/9d283ec73fe9b836fed2/view_14.PNG" alt="图片"></p>
<h4 id="Path-Op-REVERSE-DIFFERENCE"><a href="#Path-Op-REVERSE-DIFFERENCE" class="headerlink" title="Path.Op.REVERSE_DIFFERENCE"></a>Path.Op.REVERSE_DIFFERENCE</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2,</span><br><span class="line">                getMeasuredHeight() / 2 - mPointStrokeWidth,</span><br><span class="line">                Path.Direction.CCW);</span><br><span class="line">mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);</span><br><span class="line">mPath.op(mPath1, Path.Op.REVERSE_DIFFERENCE);</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/2e0fb455c160fb556ea3/view_15.PNG" alt="图片"></p>
<h4 id="Path-Op-XOR"><a href="#Path-Op-XOR" class="headerlink" title="Path.Op.XOR"></a>Path.Op.XOR</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2,</span><br><span class="line">                getMeasuredHeight() / 2 - mPointStrokeWidth,</span><br><span class="line">                Path.Direction.CCW);</span><br><span class="line">mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);</span><br><span class="line">mPath.op(mPath1, Path.Op.XOR);</span><br><span class="line">canvas.drawPath(mPath, mPointPaint);</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/0b237f28c9e72cff8a2e/view_16.PNG" alt="图片"></p>
<h3 id="最后，例子"><a href="#最后，例子" class="headerlink" title="最后，例子"></a>最后，例子</h3><p>（一）例子一<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyDrawView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private Paint mGraphPaint;</span><br><span class="line">    private Paint mPointPaint;</span><br><span class="line">    private Paint mRectPaint;</span><br><span class="line">    private RectF mRectF;</span><br><span class="line">    private Paint mLinesPaint;</span><br><span class="line">    private float mFPts[];</span><br><span class="line">    private float mFLinePts[];</span><br><span class="line">    private Path mPath;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int mPointStrokeWidth;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mGraphPaint = new Paint();</span><br><span class="line">        mGraphPaint.setColor(Color.GREEN);</span><br><span class="line">        mGraphPaint.setStrokeWidth(5);</span><br><span class="line">        mGraphPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        mGraphPaint.setShadowLayer(50, 30,30, Color.BLUE);</span><br><span class="line"></span><br><span class="line">        mPointStrokeWidth = 20;</span><br><span class="line">        mPointPaint = new Paint();</span><br><span class="line">        mPointPaint.setColor(Color.RED);</span><br><span class="line">        mPointPaint.setStrokeWidth(mPointStrokeWidth);</span><br><span class="line">        mPointPaint.setStyle(Paint.Style.FILL);</span><br><span class="line"></span><br><span class="line">        mRectPaint = new Paint();</span><br><span class="line">        mRectPaint.setColor(Color.BLACK);</span><br><span class="line">        mRectPaint.setStrokeWidth(5);</span><br><span class="line">        mRectPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line"></span><br><span class="line">        mLinesPaint = new Paint();</span><br><span class="line">        mLinesPaint.setColor(Color.GRAY);</span><br><span class="line">        mLinesPaint.setStrokeWidth(5);</span><br><span class="line">        mLinesPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line"></span><br><span class="line">        mPath = new Path();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        //super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int widthResult = 100;</span><br><span class="line">        int heightResult = 100;</span><br><span class="line"></span><br><span class="line">        if(widthMode != MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            widthResult = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(heightMode != MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            heightResult = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int resultSize = widthResult &gt; heightResult</span><br><span class="line">                ? heightResult : widthResult;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(resultSize, resultSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int num = 30;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">        super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        mRectF = new RectF(</span><br><span class="line">                num - mPointStrokeWidth / 2,</span><br><span class="line">                num - mPointStrokeWidth / 2,</span><br><span class="line">                getMeasuredWidth() - num +  mPointStrokeWidth / 2,</span><br><span class="line">                getMeasuredHeight() - num + mPointStrokeWidth / 2);</span><br><span class="line"></span><br><span class="line">        mFPts = new float[] &#123;</span><br><span class="line">                getMeasuredWidth() / 2, num,</span><br><span class="line">                getMeasuredWidth() - num, getMeasuredHeight()/ 2,</span><br><span class="line">                getMeasuredWidth() / 2 ,getMeasuredHeight() - num,</span><br><span class="line">                num, getMeasuredHeight()/ 2</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        canvas.drawCircle( getMeasuredHeight() / 2,</span><br><span class="line">                getMeasuredHeight() / 2,</span><br><span class="line">                getMeasuredHeight() / 2 - num,</span><br><span class="line">                mGraphPaint);</span><br><span class="line"></span><br><span class="line">        canvas.drawRect(mRectF, mRectPaint);</span><br><span class="line"></span><br><span class="line">        canvas.drawPoints(mFPts, mPointPaint);</span><br><span class="line"></span><br><span class="line">        canvas.drawLines(mFPts, mLinesPaint);</span><br><span class="line"></span><br><span class="line">        mPath.moveTo(mFPts[0], mFPts[1]);</span><br><span class="line">        mPath.lineTo(mFPts[2], mFPts[3]);</span><br><span class="line">        mPath.lineTo(mFPts[4], mFPts[5]);</span><br><span class="line">        mPath.lineTo(mFPts[6], mFPts[7]);</span><br><span class="line">        mPath.close();</span><br><span class="line">        canvas.drawPath(mPath, mLinesPaint);</span><br><span class="line"></span><br><span class="line">        canvas.drawLine(mFPts[0], mFPts[1], mFPts[4], mFPts[5], mLinesPaint);</span><br><span class="line">        canvas.drawLine(mFPts[2], mFPts[3], mFPts[6], mFPts[7], mLinesPaint);</span><br><span class="line"></span><br><span class="line">        mPath.moveTo(mFPts[6], mFPts[7]);</span><br><span class="line">        mPath.quadTo(mFPts[0], mFPts[1], mFPts[2], mFPts[3]);</span><br><span class="line">        canvas.drawPath(mPath, mLinesPaint);</span><br><span class="line"></span><br><span class="line">        mPath.moveTo(num - mPointStrokeWidth / 2,</span><br><span class="line">                getMeasuredHeight() - num + mPointStrokeWidth / 2);</span><br><span class="line">        mPath.cubicTo(mFPts[4], mFPts[5],</span><br><span class="line">                getMeasuredWidth() - num +  mPointStrokeWidth / 2, getMeasuredHeight() - num +</span><br><span class="line">                        mPointStrokeWidth / 2,</span><br><span class="line">                mFPts[2], mFPts[3]);</span><br><span class="line">        canvas.drawPath(mPath, mLinesPaint);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图：</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/a5636158a56d1e8659a6/view_17.PNG" alt="图片"></p>
<p>（二）例子二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyDrawView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private Paint mPaint;</span><br><span class="line"></span><br><span class="line">    private int mOffsetX;</span><br><span class="line">    private int mOffsetY;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDrawView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mPaint = new Paint();</span><br><span class="line">        mPaint.setColor(Color.RED);</span><br><span class="line">        mPaint.setStrokeWidth(5);</span><br><span class="line">        mPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        //super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int widthResult = 100;</span><br><span class="line">        int heightResult = 100;</span><br><span class="line"></span><br><span class="line">        if(widthMode != MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            widthResult = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(heightMode != MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            heightResult = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int resultSize = widthResult &gt; heightResult</span><br><span class="line">                ? heightResult : widthResult;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(resultSize, resultSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">        super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        mOffsetX = w / 2;</span><br><span class="line">        mOffsetY = h / 2 - 55;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Point getHeartPoint(float angle) &#123;</span><br><span class="line">        float t = (float) (angle / Math.PI);</span><br><span class="line">        float x = (float) (19.5 * (16 * Math.pow(Math.sin(t), 3)));</span><br><span class="line">        float y = (float) (-20 * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)));</span><br><span class="line">        return new Point(mOffsetX + (int) x, mOffsetY + (int) y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        float angle = 10;</span><br><span class="line">        while (angle &lt; 180) &#123;</span><br><span class="line">            Point p = getHeartPoint(angle);</span><br><span class="line">            canvas.drawPoint(p.x, p.y, mPaint);</span><br><span class="line">            angle = angle + 0.02f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/25043ab8dea62673f01b/view_%E5%BF%83.PNG" alt="图片"></p>
<p>关于画笔和画布的使用，到这里是未完的，其他的效果，以后有时间再补充。谢谢大家的观看。</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>初始Promise/A+规范</title>
    <url>/2018/02/02/node-async-promise/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<p><img src="http://o8bym0zmt.bkt.clouddn.com/node_promise_1.png?imageView2/2/w/600" alt="view继承关系"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章主要讲两个内容，一是，初步认识Promise，二是，Async模块和Async/Await的使用</p>
<a id="more"></a>
<h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p>Promise表示一个异步操作的最终结果。一个Promise对象有一个then方法，then方法中返回一个Promise。</p>
<h4 id="相关的概念"><a href="#相关的概念" class="headerlink" title="相关的概念"></a>相关的概念</h4><blockquote>
<ul>
<li>promise是一个包含了兼容promise规范then方法的对象或函数，</li>
<li>thenable 是一个包含了then方法的对象或函数。</li>
<li>value 是任何Javascript值。 (包括 undefined, thenable, promise等).</li>
<li>exception 是由throw表达式抛出来的值。</li>
<li>reason 是一个用于描述Promise被拒绝原因的值。</li>
</ul>
</blockquote>
<h4 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h4><p>Promise有三种状态：pending, fulfilled 或 rejected。pending是等待执行状态，fulfilled是成功执行状态，rejected是失败执行状态。</p>
<p>Promise只能从pending到fulfilled或者从pending到rejected状态，当状态发生改变时，promise.then(onFulfilled, onRejected)方法将被调用。Promise可以使用resolve或者reject将value或者reason作为下一个Promise的第一个回调参数。</p>
<p>来个简单的Promise基本用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    //do something</span><br><span class="line">    if(success)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value)&#123;</span><br><span class="line">    //成功时调用</span><br><span class="line">&#125;, function(value)&#123;</span><br><span class="line">    //失败时调用</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码只是表示Promise用法的流程.</p>
<p>使用Promise/A+规范实现以下几个功能</p>
<blockquote>
<ul>
<li>上一步的结果可以作为下一步的参数</li>
<li>出现异常时，能够捕获到异常</li>
<li>可以在每一步进行流程控制</li>
</ul>
</blockquote>
<p>Promise的具体知识，可以<a href="https://segmentfault.com/a/1190000002452115" target="_blank" rel="noopener">参考这里</a></p>
<p>下面介绍Async模块和ES7的Async/Await的使用</p>
<h3 id="Async模块"><a href="#Async模块" class="headerlink" title="Async模块"></a>Async模块</h3><p>Async模块的github地址：<a href="https://github.com/caolan/async/" target="_blank" rel="noopener">https://github.com/caolan/async/</a></p>
<p>配置好node的环境后（具体过程，自己百度），安装Async模块</p>
<blockquote>
<p>npm install –save async</p>
</blockquote>
<p>Async模块提供了很多关于集合，流程控制，工具方法，这里只体验几个常见的流程控制方法：series，parallel，waterfall，auto。其他方法的用法，可以查看官方文档：<a href="https://caolan.github.io/async/" target="_blank" rel="noopener">文档地址</a></p>
<h4 id="series的使用"><a href="#series的使用" class="headerlink" title="series的使用"></a>series的使用</h4><blockquote>
<p>series(tasks, callback)</p>
</blockquote>
<p>tasks可以是数组或者对象</p>
<p>series是串行执行tasks中的任务，如果有一个任务执行返回了错误信息，则不再继续执行后面未执行的任务，并将结果以数组或者对象的形式传给callback。具体结果的格式由你定义tasks时使用的是数组还是对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async.series([</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&quot;one&quot;);</span><br><span class="line">            callback(null, &apos;one&apos;);</span><br><span class="line">        &#125;, 300);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&quot;two&quot;);</span><br><span class="line">            callback(null, &apos;two&apos;);</span><br><span class="line">        &#125;, 200);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&quot;three&quot;);</span><br><span class="line">            callback(null, &apos;three&apos;);</span><br><span class="line">        &#125;, 100);</span><br><span class="line">    &#125;</span><br><span class="line">], function (err, results) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>one<br>two<br>three<br>null<br>[ ‘one’, ‘two’, ‘three’ ]</p>
</blockquote>
<p>当tasks是对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async.series(&#123;</span><br><span class="line">        one: function (callback) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                console.log(&quot;one&quot;);</span><br><span class="line">                callback(null, &apos;one&apos;);</span><br><span class="line">            &#125;, 300);</span><br><span class="line">        &#125;,</span><br><span class="line">        two: function (callback) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                console.log(&quot;two&quot;);</span><br><span class="line">                callback(null, &apos;two&apos;);</span><br><span class="line">            &#125;, 200);</span><br><span class="line">        &#125;,</span><br><span class="line">        three: function (callback) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                console.log(&quot;three&quot;);</span><br><span class="line">                callback(null, &apos;three&apos;);</span><br><span class="line">            &#125;, 100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, function (err, results) &#123;</span><br><span class="line">        if(err) &#123;</span><br><span class="line">            console.log(&quot;异常结束&quot; + &apos;结果为：&apos; + results);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(results);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>one<br>two<br>three<br>{ one: ‘one’, two: ‘two’, three: ‘three’ }</p>
</blockquote>
<p>上面代码中，从上到下的函数开始执行时间是逐渐减小的，而运行结果的输出顺序是one，two，three，说明series是串行执行任务的。</p>
<p>将第二个任务的代码改为以下的样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function (callback) &#123;</span><br><span class="line">    console.log(&quot;two&quot;);</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        callback(&quot;errMsg&quot;, &apos;two&apos;);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<blockquote>
<p>one<br>two<br>errMsg<br>[ ‘one’, ‘two’ ]</p>
</blockquote>
<p>可以看到，当第二个任务返回了错误信息，则不会再继续执行后面未执行的任务</p>
<h4 id="parallel的使用"><a href="#parallel的使用" class="headerlink" title="parallel的使用"></a>parallel的使用</h4><blockquote>
<p>parallel(tasks, callback)</p>
</blockquote>
<p>tasks可以是一个数组或者对象</p>
<p>parallel是并行执行多个任务，如果有一个任务执行返回了一个错误信息，则不再继续执行后面未执行的任务，并将结果以数组或者对象的形式传给callback。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async.parallel([</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            setTimeout(function() &#123;</span><br><span class="line">                console.log(&apos;one&apos;);</span><br><span class="line">                callback(null, &apos;one&apos;);</span><br><span class="line">            &#125;, 500);</span><br><span class="line">        &#125;,</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            setTimeout(function() &#123;</span><br><span class="line">                console.log(&apos;two&apos;);</span><br><span class="line">                callback(null, &apos;two&apos;);</span><br><span class="line">            &#125;, 200);</span><br><span class="line">        &#125;,</span><br><span class="line">        function (callback) &#123;</span><br><span class="line">            setTimeout(function() &#123;</span><br><span class="line">                console.log(&apos;three&apos;);</span><br><span class="line">                callback(null, &apos;three&apos;);</span><br><span class="line">            &#125;, 100);</span><br><span class="line">        &#125;</span><br><span class="line">    ], function (err, results) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">        console.log(results);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<blockquote>
<p>three<br>two<br>one<br>null<br>[ ‘one’, ‘two’, ‘three’ ]</p>
</blockquote>
<p>结果中的输出顺序是three,two,one，说明parallel是并行执行任务的。</p>
<p>同样，将第二个任务的代码改为：（数组定义tasks）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function (callback) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(&apos;two&apos;);</span><br><span class="line">        callback(&quot;errMsg&quot;, &apos;two&apos;);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<blockquote>
<p>three<br>two<br>errMsg<br>[ <1 empty item>, ‘two’, ‘three’ ]<br>one</1></p>
</blockquote>
<hr>
<p>将第二个任务代码改为：（数组定义tasks）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function (callback) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(&apos;two&apos;);</span><br><span class="line">        callback(&quot;errMsg&quot;, &apos;two&apos;);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>将第三个任务代码改为：（数组定义tasks）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function (callback) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(&apos;three&apos;);</span><br><span class="line">        callback(null, &apos;three&apos;);</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是，第三个的开始执行时间改成和出现错误信息的第二个任务的时间一样。</p>
<p>运行的结果为：</p>
<blockquote>
<p>two<br>errMsg<br>[ <1 empty item>, ‘two’ ]<br>three<br>one</1></p>
</blockquote>
<p>从结果中可以看出，当前面执行的未完成的任务会占一个位置，而后面未完成的任务不会占数组的位置。</p>
<blockquote>
<p>parallelLimit(tasks, limit, callback)</p>
</blockquote>
<p>parallelLimit和parallel差不多，区别是它可以指定同时并行执行任务的最大数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async.parallelLimit(&#123;</span><br><span class="line">    one: function (callback) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(&apos;one&apos;);</span><br><span class="line">            callback(null, &apos;one&apos;);</span><br><span class="line">        &#125;, 200);</span><br><span class="line">    &#125;,</span><br><span class="line">    two: function (callback) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(&apos;two&apos;);</span><br><span class="line">            callback(error, &apos;two&apos;);</span><br><span class="line">        &#125;, 200);</span><br><span class="line">    &#125;,</span><br><span class="line">    three: function (callback) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(&apos;three&apos;);</span><br><span class="line">            callback(null, &apos;three&apos;);</span><br><span class="line">        &#125;, 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 2, function (err, results) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<blockquote>
<p>one<br>two<br>errMsg<br>{ one: ‘one’, two: ‘two’ }<br>three</p>
</blockquote>
<p>如果是tasks是数组时，运行的结果是：</p>
<blockquote>
<p>two<br>errMsg<br>[ <1 empty item>, ‘two’ ]<br>one</1></p>
</blockquote>
<p>由于同时并行执行任务的最大数量是2，由于第二个任务产生错误信息，第三个任务还没开始执行。另外如果要取最后回调结果中的值，对象定义tasks可能会更好。</p>
<h4 id="waterfall的使用"><a href="#waterfall的使用" class="headerlink" title="waterfall的使用"></a>waterfall的使用</h4><blockquote>
<p>waterfall(tasks, callback)</p>
</blockquote>
<p>tasks只能是数组类型</p>
<p>waterfall会串行执行tasks中的任务，前一个任务的结果可以作为下一个任务的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async.waterfall([</span><br><span class="line">    function (callback) &#123;</span><br><span class="line">        console.log(&quot;one&quot;);</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            callback(null, &apos;one&apos;, &apos;two&apos;);</span><br><span class="line">        &#125;, 200);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (arg1, arg2, callback) &#123;</span><br><span class="line">        console.log(&quot;two&quot; + &apos;参数：&apos; + &quot;arg1是&quot; + arg1 + &quot;arg2是&quot; + arg2);</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            callback(null, &apos;three&apos;);</span><br><span class="line">        &#125;, 200);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (arg3, callback) &#123;</span><br><span class="line">        console.log(&quot;three&quot; + &apos;参数：&apos; + &quot;arg3是&quot; + arg3);</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            callback(null, &apos;done&apos;, &apos;done1&apos;);</span><br><span class="line">        &#125;, 200);</span><br><span class="line">    &#125;</span><br><span class="line">], function (err, results) &#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">        console.log(&quot;异常结束&quot; + &apos;结果为：&apos; + results);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行的结果是：</p>
<blockquote>
<p>one<br>two参数：arg1是onearg2是two<br>three参数：arg3是three<br>done</p>
</blockquote>
<p>输出的结果的顺序是one，two， three，是串行执行的。前一个任务的结果可以作为下一个任务的参数。</p>
<p>注意一下，代码中控制台输出的one，two，three代码是移到了定时器的外面。</p>
<h4 id="auto的使用"><a href="#auto的使用" class="headerlink" title="auto的使用"></a>auto的使用</h4><blockquote>
<p>auto(tasks, concurrencyopt, callback)</p>
</blockquote>
<p>auto可以串行和并行执行任务，可以定义任务之间的依赖关系。没有依赖关系的任务会尽可能快的开始并行执行，串行是由于任务的依赖关系而实现的。concurrencyopt指定的是并行执行任务的最大数量。tasks只能是对象类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async.auto(&#123;</span><br><span class="line">    task1: function(callback) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(&apos;task1&apos;);</span><br><span class="line">            callback(null, &apos;data&apos;, &apos;data1&apos;);</span><br><span class="line">        &#125;, 200);</span><br><span class="line">    &#125;,</span><br><span class="line">    task2: function(callback) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&apos;task2&apos;);</span><br><span class="line">            callback(null, &apos;data2&apos;);</span><br><span class="line">        &#125;, 100)</span><br><span class="line">    &#125;,</span><br><span class="line">    task3: [&apos;task1&apos;, &apos;task2&apos;, function(results, callback) &#123;</span><br><span class="line">        console.log(&apos;task3&apos;, JSON.stringify(results));</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&apos;task3&apos;);</span><br><span class="line">            callback(null, &apos;data3&apos;);</span><br><span class="line">        &#125;, 200);</span><br><span class="line"></span><br><span class="line">    &#125;],</span><br><span class="line">    task4: [&apos;task3&apos;, function(results, callback) &#123;</span><br><span class="line">        console.log(&apos;task4&apos;, JSON.stringify(results));</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&apos;task4&apos;);</span><br><span class="line">            callback(null, &#123;&apos;task2&apos;:results.task2, &apos;task4&apos;:&apos;data4&apos;&#125;);</span><br><span class="line">        &#125;, 100);</span><br><span class="line"></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, function(err, results) &#123;</span><br><span class="line">    console.log(&apos;err = &apos;, err);</span><br><span class="line">    console.log(&apos;results = &apos;, results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行的结果是：</p>
<blockquote>
<p>task2<br>task1<br>task3 {“task2”:”data2”,”task1”:[“data”,”data1”]}<br>task3<br>task4 {“task2”:”data2”,”task1”:[“data”,”data1”],”task3”:”data3”}<br>task4<br>err =  null<br>results =  { task2: ‘data2’,<br>  task1: [ ‘data’, ‘data1’ ],<br>  task3: ‘data3’,<br>  task4: { task2: ‘data2’, task4: ‘data4’ } }</p>
</blockquote>
<p>task1和task2是不依赖于任何其他任务的，它们会尽可能的开始，而且由于它们是并行执行的，task2的开始时间较短，所以task2比task1先开始。task3依赖于task1和task2，所以task3等到task1和task2执行完毕后再执行。task4依赖task3，所以task4要等到task3执行完毕后再执行。</p>
<h3 id="ES7的Async-Await"><a href="#ES7的Async-Await" class="headerlink" title="ES7的Async/Await"></a>ES7的Async/Await</h3><p>主要看它们的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var task1 = function () &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            resolve(&quot;result&quot;);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var excTask1 = async function () &#123;</span><br><span class="line">    console.log(&quot;start&quot;);</span><br><span class="line">    console.log(await task1());</span><br><span class="line">    console.log(&quot;end&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function awaitDemo() &#123;</span><br><span class="line">    excTask1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连续点击运行四次，运行的结果为：</p>
<blockquote>
<p>start<br>start<br>start<br>start<br>result<br>end<br>result<br>end<br>result<br>end<br>result<br>end</p>
</blockquote>
<p>async代表是一个async函数，await只能用在async函数中，await等待一个Promise的返回，直到Promise返回了才会继续执行await后面的代码。这里的Promise利用setTimeout模拟异步任务。</p>
<p>从输出结果中可以看出，每次执行都是到await时，就停止等待Promise的返回，后再继续执行await后面的代码。</p>
]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的消息机制</title>
    <url>/2018/02/01/android-handler/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> Android中的消息机制是指线程之间的通信机制。我们都知道，如果我们在UI主线程中做耗时的操作而无法及时处理时，程序会弹出ANR全名Application Not Responding, 也就是”应用无响应”的对话框。</p>
<p> 首先来一张图，从整体上来看一下android消息机制。</p>
<p> <img src="http://lc-2YPqqc43.cn-n1.lcfile.com/510f83afb499ea0ae228/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6.webp" alt="view继承关系"></p>
<p>Handler：用于发送消息和处理消息<br>MessageQueue: 一个先进先出的消息队列<br>Looper：循环者，它不断的循环的遍历查询消息队列</p>
 <a id="more"></a>
<p>Looper中会创建一个消息队列，并进入消息循环，不断的从消息队列中取出消息，然后分发消息给对应的消息处理函数，如果消息队列为空，它会进入阻塞等待，直到有新的消息到来，然后被唤醒。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是Looper的创建函数，它创建了一个Looper实例并放到ThreadLocal中。<br>ThreadLocal是一个线程共享和线程安全的，ThreadLocal变量在不同的线程中有不同的副本。</p>
<p>这里，首先检查线程是否有Looper，如果已经有，就报”Only one Looper may be created per thread”异常。也就是说一个线程只能有一个Looper，不能重复创建。</p>
<p>进入Looper的构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper的构造函数中主要是创建了一个消息队列，和赋值当前线程变量。</p>
<p>开启消息循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    //取出循环者</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    //开始循环之前，必须先创建循环者</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //从循环者中取出消息队列</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line">    //进入循环，不断的从消息队列中取出消息，如果没有消息会进入阻塞状态</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging = me.mLogging;</span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">        final long traceTag = me.mTraceTag;</span><br><span class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">        final long end;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将消息分发给对应的handler处理</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class="line">            final long time = end - start;</span><br><span class="line">            if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class="line">                        + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class="line">                        msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        if (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        //释放资源</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper#loop方法的工作，在代码中已经进行注释说明。</p>
<p>Looper#loop中会将消息分发给对应的handler处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msg.target.dispatchMessage(msg);</span><br></pre></td></tr></table></figure>
<p>现在我们进入handler。</p>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handler handler = new Handler(Looper.myLooper());</span><br></pre></td></tr></table></figure>
<p>首先看Handler的构造函数，可以知道Handler是怎么和Looper取得关联的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Handler(Looper looper, Callback callback, boolean async) </span><br><span class="line">&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要为Handler的四个变量赋值，其中确定了Handler是和哪一个Looper关联，和Handler发送消息到对应的哪个消息队列。可以知道，一个Handler只有一个Looper和对应的MessageQueue。而不同的Handler可以共享同一个Looper和MessageQueue，这就看你在初始化Handler时与哪个Looper关联了。</p>
<p>Handler无参数的构造函数是和哪个Looper关联呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //取出当前线程的循环者</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    if (mLooper == null) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Handler无参数的构造函数仍然主要是为那四个变量赋值。它会首先取出当前线程的消息循环者，如果线程没有循环者，会报一个异常。</p>
<p>发送消息到循环队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean sendMessage(Message msg)</span><br><span class="line">&#123;</span><br><span class="line">    return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">&#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;</span><br><span class="line">        delayMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    if (queue == null) &#123;</span><br><span class="line">        RuntimeException e = new RuntimeException(</span><br><span class="line">            this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessage中会调用sendMessageDelayed，sendMessageDelayed再调用sendMessageAtTime，最后会调用enqueueMessage将消息入队。post开头的方法是调用相应send开头的方法的。</p>
<p>进入Handler#enqueueMessage<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在分析Looper#loop时，其中有将消息的分发给相应的Handler处理的逻辑，而正是在第2行代码时，它们取得联系的。然后将消息放入Handler关联的Looper中的消息队列。</p>
<p>在MessageQueue#enqueueMessage中，消息入队时，如果消息队列是阻塞休眠状态，会唤醒消息队列。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">    // New head, wake up the event queue if blocked.</span><br><span class="line">    msg.next = p;</span><br><span class="line">    mMessages = msg;</span><br><span class="line">    needWake = mBlocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Looper#loop中，会将消息分发给对应的Handler处理函数dispatchMessage处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msg.target.dispatchMessage(msg);</span><br></pre></td></tr></table></figure>
<p>进入Handler#dispatchMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java.lang.Callback<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Handler#Callback<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Callback &#123;</span><br><span class="line">    public boolean handleMessage(Message msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优先调用Message的callback接口，如果Handler有Callback，调用Callback，否则会调用handleMessage方法。</p>
<p>Handler#handleMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个空方法，具体的消息逻辑由我们自己定义。</p>
<p>到此，这个流程已经解释完毕</p>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>在非UI线程中只要找好时机也是可以更新UI的。这个会在源码再分析。</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中Activity的启动流程</title>
    <url>/2018/01/31/android-activity-start-up/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在这篇文章中，将会基于android 26源码上分析Activity从启动到显示到屏幕和Decorview添加到Window中的过程。另外在本文中，省略了很多内容，目的只是从源码中找到一条启动的线索。迟点再补充上流程图。</p>
<h3 id="从startActivity开始说起"><a href="#从startActivity开始说起" class="headerlink" title="从startActivity开始说起"></a>从startActivity开始说起</h3><p>在应用层开发时，Acitvity跳转会写出下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void startAtcivity(BaseActivity activity) &#123;</span><br><span class="line">        if(activity != null) &#123;</span><br><span class="line">            Intent intent = new Intent(activity, HomeAcivity.class);</span><br><span class="line">            activity.startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
 <a id="more"></a>
<p>首先看下activity的继承关系：</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/0b8535b979ac7f48b2b7/activity_start_up_1.webp" alt="context继承关系"></p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/7ca3bf659993403fd8ac/activity_start_up_2.webp" alt="activity继承关系"></p>
<p>第一张图，知道activity是context的子类，第二张图，我们可以知道各种activity的关系。<br>另外会写一片文章，介绍context。</p>
<p>现在我们进入activity#startActivity<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void startActivity(Intent intent) &#123;</span><br><span class="line">    this.startActivity(intent, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">    if (options != null) &#123;</span><br><span class="line">        startActivityForResult(intent, -1, options);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Note we want to go through this call for compatibility with</span><br><span class="line">        // applications that may have overridden the method.</span><br><span class="line">        startActivityForResult(intent, -1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着调用activity#startActivityForResult<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">        @Nullable Bundle options) &#123;</span><br><span class="line">    </span><br><span class="line">    if (mParent == null) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        //1、Instrumentation</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        if (ar != null) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">     ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在1、中，出现了Instrumentation，并调用了execStartActivity方法<br>进入Instrumentation#execStartActivity<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">   ...</span><br><span class="line">    if (mActivityMonitors != null) &#123;</span><br><span class="line">        synchronized (mSync) &#123;</span><br><span class="line">            final int N = mActivityMonitors.size();</span><br><span class="line">            for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                final ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                ActivityResult result = null;</span><br><span class="line">                if (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                    result = am.onStartActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        //1、进入ActivityManagerService中</span><br><span class="line">        int result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                    requestCode, 0, null, options);</span><br><span class="line">        //2、检查创建actiity过程是否产生了异常            </span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在1、中，出现了ActivityManager。取到IActivityManager，这里有涉及binder机制，ActivityManager.getService()得到的就是ActivityManagerService，ActivityManagerService实现了IActivityManager.Stub，而ActivityManager中有IActivityManager.Stub.asInterface的远程调用。<br>ActivityManager#getService<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public static IActivityManager getService() &#123;</span><br><span class="line">     return IActivityManagerSingleton.get();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">         new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             protected IActivityManager create() &#123;</span><br><span class="line">                 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                 final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                 return am;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在2、中，Instrumentation#checkStartActivityResult方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** @hide */</span><br><span class="line">public static void checkStartActivityResult(int res, Object intent) &#123;</span><br><span class="line">    if (!ActivityManager.isStartResultFatalError(res)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (res) &#123;</span><br><span class="line">        case ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">        case ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">            if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null)</span><br><span class="line">            //1、出现没有注册异常</span><br><span class="line">                throw new ActivityNotFoundException(</span><br><span class="line">                        &quot;Unable to find explicit activity class &quot;</span><br><span class="line">                        + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                        + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;);</span><br><span class="line">            throw new ActivityNotFoundException(</span><br><span class="line">                    &quot;No Activity found to handle &quot; + intent);</span><br><span class="line">        case ActivityManager.START_PERMISSION_DENIED:</span><br><span class="line">            throw new SecurityException(&quot;Not allowed to start activity &quot;</span><br><span class="line">                    + intent);</span><br><span class="line">        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:</span><br><span class="line">            throw new AndroidRuntimeException(</span><br><span class="line">                    &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;);</span><br><span class="line">        case ActivityManager.START_NOT_ACTIVITY:</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;PendingIntent is not an activity&quot;);</span><br><span class="line">        case ActivityManager.START_NOT_VOICE_COMPATIBLE:</span><br><span class="line">            throw new SecurityException(</span><br><span class="line">                    &quot;Starting under voice control not allowed for: &quot; + intent);</span><br><span class="line">        case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Session calling startVoiceActivity does not match active session&quot;);</span><br><span class="line">        case ActivityManager.START_VOICE_HIDDEN_SESSION:</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Cannot start voice activity on a hidden session&quot;);</span><br><span class="line">        case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Session calling startAssistantActivity does not match active session&quot;);</span><br><span class="line">        case ActivityManager.START_ASSISTANT_HIDDEN_SESSION:</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;Cannot start assistant activity on a hidden session&quot;);</span><br><span class="line">        case ActivityManager.START_CANCELED:</span><br><span class="line">            throw new AndroidRuntimeException(&quot;Activity could not be started for &quot;</span><br><span class="line">                    + intent);</span><br><span class="line">        default:</span><br><span class="line">            throw new AndroidRuntimeException(&quot;Unknown error code &quot;</span><br><span class="line">                    + res + &quot; when starting &quot; + intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是检查在启动activity过程中，可能出现的异常。比如，启动的Acitivity没有在AndroidManifest.xml中注册，会出现代码中1、的异常。</p>
<p>继续，回到在execStartActivity的1、进入ActivityManagerService#startActivity</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int startActivity(IBinder whoThread, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, Bundle bOptions) &#123;</span><br><span class="line">    checkCaller();</span><br><span class="line"></span><br><span class="line">    int callingUser = UserHandle.getCallingUserId();</span><br><span class="line">    TaskRecord tr;</span><br><span class="line">    IApplicationThread appThread;</span><br><span class="line">    synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">        tr = mStackSupervisor.anyTaskForIdLocked(mTaskId);</span><br><span class="line">        if (tr == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unable to find task ID &quot; + mTaskId);</span><br><span class="line">        &#125;</span><br><span class="line">        //1、IApplicationThread</span><br><span class="line">        appThread = IApplicationThread.Stub.asInterface(whoThread);</span><br><span class="line">        if (appThread == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Bad app thread &quot; + appThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //2、ActivityStarter</span><br><span class="line">    return mActivityStarter.startActivityMayWait(appThread, -1, callingPackage, intent,</span><br><span class="line">            resolvedType, null, null, null, null, 0, 0, null, null,</span><br><span class="line">            null, bOptions, false, callingUser, null, tr, &quot;AppTaskImpl&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在1、处，出现了IApplicationThread，这里涉及到了binder机制，IApplicationThread的实现是在ActivityThread中的内部类ApplicationThread</p>
<p>ActivityThread#ApplicationThread</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">   </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">     private void updatePendingConfiguration(Configuration config) &#123;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void schedulePauseActivity(IBinder token, boolean finished,</span><br><span class="line">          ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleStopActivity(IBinder token, boolean showWindow,</span><br><span class="line">             int configChanges) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleWindowVisibility(IBinder token, boolean showWindow) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">     public final void scheduleResumeActivity(IBinder token, int processState,</span><br><span class="line">             boolean isForward, Bundle resumeArgs) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleSendResult(IBinder token, List&lt;ResultInfo&gt; results) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">             ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">             CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">             int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">             List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">             boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public final void scheduleRelaunchActivity(IBinder token,</span><br><span class="line">             List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">             int configChanges, boolean notResumed, Configuration config,</span><br><span class="line">             Configuration overrideConfig, boolean preserveWindow) &#123;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleNewIntent(</span><br><span class="line">             List&lt;ReferrerIntent&gt; intents, IBinder token, boolean andPause) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleDestroyActivity(IBinder token, boolean finishing,</span><br><span class="line">             int configChanges) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleReceiver(Intent intent, ActivityInfo info,</span><br><span class="line">             CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras,</span><br><span class="line">             boolean sync, int sendingUser, int processState) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">     public final void scheduleCreateService(IBinder token,</span><br><span class="line">             ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleBindService(IBinder token, Intent intent,</span><br><span class="line">             boolean rebind, int processState) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleUnbindService(IBinder token, Intent intent) &#123;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleServiceArgs(IBinder token, ParceledListSlice args) &#123;</span><br><span class="line">         List&lt;ServiceStartArgs&gt; list = args.getList();</span><br><span class="line"> ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void scheduleStopService(IBinder token) &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">             List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">             ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">             IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">             IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">             boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">             boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">             CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="line">             String buildSerial) &#123;</span><br><span class="line">...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">     public void scheduleConfigurationChanged(Configuration config) &#123;</span><br><span class="line">         updatePendingConfiguration(config);</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">     public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</span><br><span class="line">             int resultCode, String dataStr, Bundle extras, boolean ordered,</span><br><span class="line">             boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void scheduleActivityConfigurationChanged(</span><br><span class="line">             IBinder token, Configuration overrideConfig) &#123;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在ApplicationThread中，有很多与Activity，service，Application生命周期有关的方法。<br>其中scheduleLaunchActivity()应该就是负责Activity创建的。</p>
<p>ActivityManagerService#startActivity的2、处，调用了ActivityStarter的startActivityMayWait方法，它又调用了startActivityLocked方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1、</span><br><span class="line">   int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">       mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">               aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">               callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">               options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">               container, inTask);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">       return mLastStartActivityResult;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   2、</span><br><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">           String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">           IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">           String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">           ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">           ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span><br><span class="line">           TaskRecord inTask) &#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">       return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,</span><br><span class="line">               options, inTask, outActivity);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   3、</span><br><span class="line">   private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">      ...</span><br><span class="line">       try &#123;</span><br><span class="line">           mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">           result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                   startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在3、中，调用了startActivityUnchecked方法，startActivityUnchecked又调用了ActivityStackSupervisor#resumeFocusedStackTopActivityLocked方法，</p>
<p>ActivityStackSupervisor#resumeFocusedStackTopActivityLocked<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line">    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    if (r == null || r.state != RESUMED) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">    &#125; else if (r.state == RESUMED) &#123;</span><br><span class="line">        // Kick off any lingering app transitions form the MoveTaskToFront operation.</span><br><span class="line">        mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面方法中，接着调用ActivityStack的resumeTopActivityUncheckedLocked方法，<br>ActivityStack#resumeTopActivityUncheckedLocked<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        // Don&apos;t even start recursing.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean result = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Protect against recursion.</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = true;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = false;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着调用resumeTopActivityInnerLocked方法，在resumeTopActivityInnerLocked中调用ActivityStackSupervisor的startSpecificActivityLocked方法</p>
<p>ActivityStackSupervisor#startSpecificActivityLocked<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">        boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                    || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">            &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法中调用了realStartActivityLocked方法，它里面有下面的代码：</p>
<p>ActivityStackSupervisor#realStartActivityLocked<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">		System.identityHashCode(r), r.info,</span><br><span class="line">		// TODO: Have this take the merged configuration instead of separate global and</span><br><span class="line">        // override configs.</span><br><span class="line">        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">        r.persistentState, results, newIntents, !andResume,</span><br><span class="line">         mService.isNextTransitionForward(), profilerInfo);</span><br></pre></td></tr></table></figure></p>
<p>上面的app.thread就是ApplicationThread,并调用scheduleLaunchActivity。</p>
<p>上面曾经说过ApplicationThread是AcitivityThread的内部类。</p>
<p>进入ApplicationThread的scheduleLaunchActivity方法，它最后会发送一个消息给名为H的handler</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sendMessage(H.LAUNCH_ACTIVITY, r);</span><br></pre></td></tr></table></figure>
<p>H.LAUNCH_ACTIVITY的消息处理逻辑是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">                    r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                &#125; break;</span><br></pre></td></tr></table></figure>
<p>调用handleLaunchActivity方法。在handleLaunchActivity主要是分别调用performLaunchActivity和handleResumeActivity方法</p>
<p>进入ActivityThread#performLaunchActivity</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);</span><br><span class="line">        //1、收集创建Acitivity的信息</span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">        if (r.packageInfo == null) &#123;</span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        //2、创建Context的实现者ContextImpl</span><br><span class="line">        ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">			//3、通Instrumentation创建activity</span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //4、创建Application</span><br><span class="line">            Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line">                //5、调用activity的attach方法</span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">                ...</span><br><span class="line">                </span><br><span class="line">               if (theme != 0) &#123;</span><br><span class="line">                    activity.setTheme(theme);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                activity.mCalled = false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    //6、调用Activity的OnCreate方法</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;            </span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                //7、调用Activity的OnStart方法</span><br><span class="line">                 if (!r.activity.mFinished) &#123;</span><br><span class="line">                    activity.performStart();</span><br><span class="line">                    r.stopped = false;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            r.paused = true;</span><br><span class="line"></span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">        &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在3、中，会调用Instrumentation#newActivity</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Activity newActivity(ClassLoader cl, String className,</span><br><span class="line">            Intent intent)</span><br><span class="line">            throws InstantiationException, IllegalAccessException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        return (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出是通过类加载器通过反射创建Activity实例的。</p>
<p>在4、中，调用了LoadedApk#makeApplication方法，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br></pre></td></tr></table></figure>
<p>makeApplication方法中，和newActivity差不多，也是由Instrumentation的newApplication方法，通过反射创建Application的</p>
<p>5、中调用Acitivty的attach方法，</p>
<p>Acitivty#attach<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">        Instrumentation instr, IBinder token, int ident,</span><br><span class="line">        Application application, Intent intent, ActivityInfo info,</span><br><span class="line">        CharSequence title, Activity parent, String id,</span><br><span class="line">        NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(null /*parent*/);</span><br><span class="line"></span><br><span class="line">    mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">    ...</span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line">    ...</span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中，主要是会创建PhoneWindow。</p>
<p>在6和7中，分别调用了acitivity的生命周期方法，onCreate和onStart。</p>
<p>已经分析了在handleLaunchActivity的performLaunchActivity方法。<br>现在分析handleLaunchActivity的handleResumeActivity，在handleResumeActivity中会调用acitivity的生命周期方法onResume和将Decorview添加到Window中，并在makeVisible中显示出来。</p>
<p>Activity#handleResumeActivity<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        if (!checkAndUpdateLifecycleSeq(seq, r, &quot;resumeActivity&quot;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we are getting ready to gc after going to the background, well</span><br><span class="line">        // we are back active so skip it.</span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line">        mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">        //1、会调用Acitvity的onResume生命周期方法</span><br><span class="line">        // TODO Push resumeArgs into the activity for consideration</span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            final Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            if (!willBeVisible) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    willBeVisible = ActivityManager.getService().willActivityBeVisible(</span><br><span class="line">                            a.getActivityToken());</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    throw e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window = r.activity.getWindow();</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                //2、设置decor不可见</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                a.mDecor = decor;</span><br><span class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |= forwardBit;</span><br><span class="line">                if (r.mPreserveWindow) &#123;</span><br><span class="line">                    a.mWindowAdded = true;</span><br><span class="line">                    r.mPreserveWindow = false;</span><br><span class="line">                    // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">                    // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">                    // the decor view we have to notify the view root that the</span><br><span class="line">                    // callbacks may have changed.</span><br><span class="line">                    ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                    if (impl != null) &#123;</span><br><span class="line">                        impl.notifyChildRebuilt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (a.mVisibleFromClient) &#123;</span><br><span class="line">                    if (!a.mWindowAdded) &#123;</span><br><span class="line">                        a.mWindowAdded = true;</span><br><span class="line">                        //3、将Decorviewt添加到Window</span><br><span class="line">                        wm.addView(decor, l);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // The activity will get a callback for this &#123;@link LayoutParams&#125; change</span><br><span class="line">                        // earlier. However, at that time the decor will not be set (this is set</span><br><span class="line">                        // in this method), so no action will be taken. This call ensures the</span><br><span class="line">                        // callback occurs with the decor set.</span><br><span class="line">                        a.onWindowAttributesChanged(l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            // If the window has already been added, but during resume</span><br><span class="line">            // we started another activity, then don&apos;t yet make the</span><br><span class="line">            // window visible.</span><br><span class="line">            &#125; else if (!willBeVisible) &#123;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">                r.hideForNow = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Get rid of anything left hanging around.</span><br><span class="line">            cleanUpPendingRemoveWindows(r, false /* force */);</span><br><span class="line"></span><br><span class="line">            // The window is now visible if it has been added, we are not</span><br><span class="line">            // simply finishing, and we are not starting another activity.</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                    &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">                if (r.newConfig != null) &#123;</span><br><span class="line">                    performConfigurationChangedForActivity(r, r.newConfig);</span><br><span class="line">                    if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</span><br><span class="line">                            + r.activityInfo.name + &quot; with newConfig &quot; + r.activity.mCurrentConfig);</span><br><span class="line">                    r.newConfig = null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot;</span><br><span class="line">                        + isForward);</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                if ((l.softInputMode</span><br><span class="line">                        &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                        != forwardBit) &#123;</span><br><span class="line">                    l.softInputMode = (l.softInputMode</span><br><span class="line">                            &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                            | forwardBit;</span><br><span class="line">                    if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                        ViewManager wm = a.getWindowManager();</span><br><span class="line">                        View decor = r.window.getDecorView();</span><br><span class="line">                        wm.updateViewLayout(decor, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                r.activity.mVisibleFromServer = true;</span><br><span class="line">                mNumVisibleActivities++;</span><br><span class="line">                if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    //4、调用makeVisible</span><br><span class="line">                    r.activity.makeVisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在1、处的performResumeActivity方法中，会调用以下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r.activity.performResume();</span><br></pre></td></tr></table></figure></p>
<p>即调用activity的onResume生命周期方法。</p>
<p>在2、中，设置了Decorview为不可见<br>在3、中，将Decorview添加到window中，由于2中设置了Decorview为不可见，这时view还看不到。<br>在4、中，调用Activity的makeVisible方法。<br>Activity#makeVisible<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void makeVisible() &#123;</span><br><span class="line">    if (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = true;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，将Decorview设置为可见的。</p>
<h3 id="剩下问题"><a href="#剩下问题" class="headerlink" title="剩下问题"></a>剩下问题</h3><p>在上面过程中的哪里开始涉及视图绘制。迟点再看。<br>分析追溯到Zygote中。<br>本篇文章的排版还有点乱。</p>
<p>优秀文章：<a href="http://blog.csdn.net/dd864140130/article/details/60466394" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/60466394</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中view的位置坐标和view的滑动</title>
    <url>/2018/01/25/android-view-positon-and-scroll/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="view体系结构？"><a href="#view体系结构？" class="headerlink" title="view体系结构？"></a>view体系结构？</h3><p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/185be81d07cbb9a25fd4/view_tree.webp" alt="view继承关系"></p>
 <a id="more"></a>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/948279d5aad2a8df78ea/view_position_1.webp" alt="view继承关系1"></p>
<p>View是Android中界面层控件的一个抽象。从上图中可以看出控件层的继承关系，TextView是View的直接子类，LinearLayout是ViewGroup的直接子类，ViewGroup是View的直接子类，所以TextView和LinearLayout都是一个view，都直接或者间接继承于View。View是所有控件和控件组的子类。</p>
<h3 id="View相关的坐标"><a href="#View相关的坐标" class="headerlink" title="View相关的坐标"></a>View相关的坐标</h3><p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/373c2931dcf5cd8bb2c7/view_position_2.webp" alt="view位置关系"></p>
<p>Android手机屏幕的坐标原点（0，0）在屏幕的左上角，向右为x轴的正方向，向下为y轴的正方向。</p>
<p>View的位置由四个顶点确定，且View的位置都是相对于父控件来说的。</p>
<p>View的四个顶点分别对应于View类中的mLeft，mTop，mRight，mBottom，它们在View中都提供了相应的get方法。</p>
<blockquote>
<p>View的坐标和宽度为：<br>左上角坐标为（left， top），右下角坐标为（right，bottom）<br>宽度 = mRight - mLeft<br>高度 = mBottom - mTop</p>
</blockquote>
<p>相应的，改变View位置（四个顶点）的方法有：</p>
<blockquote>
<p>（1）View的layout(int left, int top, int right, int bottom)<br>（2）水平方向：offsetLeftAndRight，改变mLeft和mRight<br>——-垂直方法：offsetTopAndBottom，改变mTop和mBottom</p>
</blockquote>
<p>关于View的坐标，Android也提供了x，y，translationX，translationY参数，它们也是相对于父控件而言的，与上面的参数有以下关系：</p>
<blockquote>
<p>x = mLeft + translationX<br>y = mTop + translationY<br>刚开始时，translationX和translationY的默认值都是0。</p>
</blockquote>
<p>Android中的scrollX和scrollY，它们和View的边缘以及View内容的边缘有关，产生于scrollTo和scrollBy。</p>
<blockquote>
<p>当view内容的上边缘在view的上边缘的上面，scrollY为正值，反之为负值<br>当view内容的左边缘在view的左边缘的左面，scrollX为正值，反之为负值</p>
</blockquote>
<h3 id="MotionEvent相关的坐标"><a href="#MotionEvent相关的坐标" class="headerlink" title="MotionEvent相关的坐标"></a>MotionEvent相关的坐标</h3><p>MotionEvent相关的坐标是用于表示事件MotionEvent发生的坐标，有getX，getY，getScrollX，getScrollY。</p>
<blockquote>
<p>相对于所在控件，有event.getX()和event.getY()<br>相对于屏幕，有event.getScrollX()和event.getScrollY()</p>
</blockquote>
<h3 id="实现View滑动的几种方法"><a href="#实现View滑动的几种方法" class="headerlink" title="实现View滑动的几种方法"></a>实现View滑动的几种方法</h3><blockquote>
<p>（1）使用View的scrollTo和scrollBy<br>（2）使用View的布局参数，改变外边距<br>（3）使用View的layout、offsetLeftAndRight和offsetTopAndBottom方法<br>（4）使用动画</p>
</blockquote>
<h4 id="1-使用View的scrollTo和scrollBy"><a href="#1-使用View的scrollTo和scrollBy" class="headerlink" title="(1) 使用View的scrollTo和scrollBy"></a>(1) 使用View的scrollTo和scrollBy</h4><p>scrollTo和scrollBy都是View中的方法，scrollTo是view的绝对运动，scrollBy是相对于view当前位置的相对运动。它们滑动的是View的内容。</p>
<p>从源码分析，scrollTo和scrollBy的关系</p>
<p>View#scrollTo<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void scrollTo(int x, int y) &#123;</span><br><span class="line">    if (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        int oldX = mScrollX;</span><br><span class="line">        int oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        if (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>View#scrollBy<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void scrollBy(int x, int y) &#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，scrollTo是直接赋值给mScrollX和mScrollY，并回调onScrollChanged。在scrollBy中是在原来值的基础上相加然后调用scrollTo的，即是相对于view当前位置的。</p>
<h4 id="（2）使用View的布局参数，改变外边距"><a href="#（2）使用View的布局参数，改变外边距" class="headerlink" title="（2）使用View的布局参数，改变外边距"></a>（2）使用View的布局参数，改变外边距</h4><p>这种方法就是通过设置View布局参数的Margin值实现的。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MarginLayoutParams mlp = (MarginLayoutParams)view.getLayoutParams();</span><br><span class="line">mlp.leftMargin =+ 100;</span><br><span class="line">view.setLayoutParams(mlp);</span><br></pre></td></tr></table></figure></p>
<p>向右滑动100个像素，但滑动效果几乎是瞬间完成的。</p>
<h4 id="（3）使用View的layout、offsetLeftAndRight和offsetTopAndBottom方法"><a href="#（3）使用View的layout、offsetLeftAndRight和offsetTopAndBottom方法" class="headerlink" title="（3）使用View的layout、offsetLeftAndRight和offsetTopAndBottom方法"></a>（3）使用View的layout、offsetLeftAndRight和offsetTopAndBottom方法</h4><p>上面，我们已经知道View的位置是由四个顶点决定的，通过改变它的顶点坐标就可以改变view的位置。View的layout、offsetLeftAndRight和offsetTopAndBottom都可以直接改变view顶点的值。</p>
<h4 id="（4）使用动画"><a href="#（4）使用动画" class="headerlink" title="（4）使用动画"></a>（4）使用动画</h4><p>使用动画是使用位移动画，改变translationX和translationY的值。位移动画要注意View动画和属性动画的区别，view动画并不能改变view的位置。属性动画是在Android3.0之后引入的，为了兼容之前的系统版本，可以使用nineoldandroids库。</p>
<h3 id="实现弹性的滑动"><a href="#实现弹性的滑动" class="headerlink" title="实现弹性的滑动"></a>实现弹性的滑动</h3><blockquote>
<p>（1）使用动画实现滑动<br>（2）使用scroller</p>
</blockquote>
<h4 id="（1）使用动画实现滑动"><a href="#（1）使用动画实现滑动" class="headerlink" title="（1）使用动画实现滑动"></a>（1）使用动画实现滑动</h4><p>动画本来就是在一定时间内完成的，所以使用动画可以实现弹性的滑动。</p>
<h4 id="（2）使用scroller"><a href="#（2）使用scroller" class="headerlink" title="（2）使用scroller"></a>（2）使用scroller</h4><p>scroller实现弹性滑动的原理和动画是差不多的，都是在一定的时间内，从初始值到终值点，不断的改变scrollX和scrollY。</p>
<p>scroller实现滑动的经典代码段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1、初始化Scroller</span><br><span class="line">mScroller = new Scroller(context);</span><br><span class="line"></span><br><span class="line">//2、设置初始值、终点值、滑动的时间</span><br><span class="line"> public void smoothScrollTo(int destX,int destY)&#123;</span><br><span class="line">    int scrollX=getScrollX();</span><br><span class="line">    int delta=destX-scrollX;</span><br><span class="line">    //1000秒内滑向destX</span><br><span class="line">    mScroller.startScroll(scrollX,0,delta,0,1000);</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3、重写computeScroll</span><br><span class="line">@Override</span><br><span class="line">public void computeScroll() &#123;</span><br><span class="line">    super.computeScroll();</span><br><span class="line">    if(mScroller.computeScrollOffset())&#123;</span><br><span class="line">        ((View) getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</span><br><span class="line">        //通过不断的重绘不断的调用computeScroll方法</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scroller是如何不断的改变scrollX和scrollY呢？</p>
<p>首先看View#startScroll</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123;</span><br><span class="line">    mMode = SCROLL_MODE;</span><br><span class="line">    mFinished = false;</span><br><span class="line">    mDuration = duration;</span><br><span class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">    mStartX = startX;</span><br><span class="line">    mStartY = startY;</span><br><span class="line">    mFinalX = startX + dx;</span><br><span class="line">    mFinalY = startY + dy;</span><br><span class="line">    mDeltaX = dx;</span><br><span class="line">    mDeltaY = dy;</span><br><span class="line">    mDurationReciprocal = 1.0f / (float) mDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startScroll其实只是设置滑动的始点值和根据滑动的距离计算终点值、及滑动的总时间等。接着就调用invalidate方法重绘，重绘会调用view的draw方法。在view的draw方法中会调用computeScroll方法。</p>
<p>进入computeScroll方法，首先是看computeScrollOffset源码<br>Scroller#computeScrollOffset</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean computeScrollOffset() &#123;</span><br><span class="line">    //返回false，结束</span><br><span class="line">    if (mFinished) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算消逝的时间</span><br><span class="line">    int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</span><br><span class="line"></span><br><span class="line">    if (timePassed &lt; mDuration) &#123;</span><br><span class="line">        switch (mMode) &#123;</span><br><span class="line">            case SCROLL_MODE:</span><br><span class="line">                //有点类似插值器，根据消逝的事件计算百分比</span><br><span class="line">                final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</span><br><span class="line">                //有点类似估值器，根据消逝的时间百分比计算实际值</span><br><span class="line">                mCurrX = mStartX + Math.round(x * mDeltaX);</span><br><span class="line">                mCurrY = mStartY + Math.round(x * mDeltaY);</span><br><span class="line">                break;</span><br><span class="line">            case FLING_MODE:</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;</span><br><span class="line">                    mFinished = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        mCurrX = mFinalX;</span><br><span class="line">        mCurrY = mFinalY;</span><br><span class="line">        mFinished = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>computeScrollOffset判断滑动是否结束和计算滑动的值，而在computeScroll中接着会不断获取计算后的滑动值，使用scrollTo进行滑动，然后再调用invalidate方法重绘，即再调用view的draw方法。在view的draw方法中会调用computeScroll方法，如此反复…</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义波纹WaveView</title>
    <url>/2018/01/18/android-wave-view/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p>首先直接上效果图：<br><img src="http://o8bym0zmt.bkt.clouddn.com/android_wave_view.gif?imageView2/2/w/400" alt="图片"></p>
<h3 id="源码和分析"><a href="#源码和分析" class="headerlink" title="源码和分析"></a>源码和分析</h3><p>简单分析，首先画一个半径固定为R的颜色填充的圆，再画一些半径从R逐渐增大的圆就形成圆形不断的向外扩大的效果，并且这些圆形的透明度是与半径的相关的。最后在圆形的中心画文本。</p>
<a id="more"></a>
<p>自定义属性</p>
<p>attrs.xml<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;declare-styleable name=&quot;waveView&quot;&gt;</span><br><span class="line">       &lt;attr name=&quot;text&quot; format=&quot;string&quot;/&gt;</span><br><span class="line">       &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot;/&gt;</span><br><span class="line">       &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">       &lt;attr name=&quot;color&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">&lt;/declare-styleable&gt;</span><br></pre></td></tr></table></figure></p>
<p>text是圆形中心的文本，textSize是文本的大小，textColor是文本的颜色，color是WaveView的颜色。</p>
<p>WaveView.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WaveView extends View &#123;</span><br><span class="line">    private int mRippleViewWidth;</span><br><span class="line">    private int mRippleViewRadius;</span><br><span class="line">    private Paint mRipplePaint = new Paint();</span><br><span class="line">    private boolean isStartRipple;</span><br><span class="line">    private int rippleFirstRadius = 0;</span><br><span class="line">    private int rippleSecondRadius = -33;</span><br><span class="line">    private int rippleThirdRadius = -66;</span><br><span class="line">    private Paint textPaint = new Paint();</span><br><span class="line">    private String mText=&quot;扫描中...&quot;;</span><br><span class="line">    private int mDefaultColor = Color.parseColor(&quot;#54FF9F&quot;);</span><br><span class="line">    private int mColor = mDefaultColor;</span><br><span class="line">    private int mDefaultTextColor = Color.WHITE;</span><br><span class="line">    private int mTextColor = mDefaultTextColor;</span><br><span class="line">    private float mDefaultTextSize = 26;</span><br><span class="line">    private float mTextSize = mDefaultTextSize;</span><br><span class="line">    private int mDefaultWidth = 300;</span><br><span class="line">    private Handler handler = new Handler();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param context</span><br><span class="line">     */</span><br><span class="line">    public WaveView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @param context</span><br><span class="line">     * @param attrs</span><br><span class="line">     */</span><br><span class="line">    public WaveView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        getAttrs(context, attrs);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @param context</span><br><span class="line">     * @param attrs</span><br><span class="line">     * @param defStyleAttr</span><br><span class="line">     */</span><br><span class="line">    public WaveView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        getAttrs(context, attrs);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getAttrs(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.waveView);</span><br><span class="line">        for(int i = 0; i &lt; a.getIndexCount(); i++) &#123;</span><br><span class="line">            int attrIndex = a.getIndex(i);</span><br><span class="line">            switch (attrIndex) &#123;</span><br><span class="line">                case R.styleable.waveView_text:</span><br><span class="line">                    mText = a.getString(attrIndex);</span><br><span class="line">                    break;</span><br><span class="line">                case R.styleable.waveView_textColor:</span><br><span class="line">                    mTextColor = a.getColor(attrIndex, mDefaultTextColor);</span><br><span class="line">                    break;</span><br><span class="line">                case R.styleable.waveView_textSize:</span><br><span class="line">                    mTextSize = a.getDimension(attrIndex, mDefaultTextSize);</span><br><span class="line">                    break;</span><br><span class="line">                case R.styleable.waveView_color:</span><br><span class="line">                    mColor = a.getColor(attrIndex, mDefaultColor);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init(Context context) &#123;</span><br><span class="line">        mRipplePaint.setColor(mColor);</span><br><span class="line">        mRipplePaint.setAntiAlias(true);</span><br><span class="line">        mRipplePaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        textPaint.setTextSize(mTextSize);</span><br><span class="line">        textPaint.setAntiAlias(true);</span><br><span class="line">        textPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        textPaint.setColor(mTextColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onAttachedToWindow() &#123;</span><br><span class="line">        super.onAttachedToWindow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDetachedFromWindow() &#123;</span><br><span class="line">        super.onDetachedFromWindow();</span><br><span class="line">        if(handler != null) &#123;</span><br><span class="line">            handler.removeCallbacksAndMessages(null);</span><br><span class="line">            handler = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Runnable mRunnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            invalidate();</span><br><span class="line">            if (isStartRipple) &#123;</span><br><span class="line">                rippleFirstRadius++;</span><br><span class="line">                if (rippleFirstRadius &gt; 100) &#123;</span><br><span class="line">                    rippleFirstRadius = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                rippleSecondRadius++;</span><br><span class="line">                if (rippleSecondRadius &gt; 100) &#123;</span><br><span class="line">                    rippleSecondRadius = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                rippleThirdRadius++;</span><br><span class="line">                if (rippleThirdRadius &gt; 100) &#123;</span><br><span class="line">                    rippleThirdRadius = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(handler != null) &#123;</span><br><span class="line">                handler.postDelayed(mRunnable, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int measureWidth = 0;</span><br><span class="line">        int measureHeight = 0;</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        measureWidth = widthSize;</span><br><span class="line">        measureHeight = heightSize;</span><br><span class="line">        if(widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            measureWidth = mDefaultWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        if(heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            measureHeight = mDefaultWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        mRippleViewWidth = Math.min(measureWidth, measureHeight);</span><br><span class="line">        float f1 = 7 * mRippleViewWidth / 20;</span><br><span class="line">        mRippleViewRadius = (mRippleViewWidth - (2*(int)(Math.floor(f1))))/2 ;</span><br><span class="line">        setMeasuredDimension(mRippleViewWidth, mRippleViewWidth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        if (isStartRipple) &#123;</span><br><span class="line">            float f1 = 7 * mRippleViewWidth / 20;</span><br><span class="line">            mRipplePaint.setAlpha(255);</span><br><span class="line">            //固定半径的圆形</span><br><span class="line">            canvas.drawCircle(mRippleViewWidth / 2, mRippleViewWidth / 2,</span><br><span class="line">                    mRippleViewRadius, mRipplePaint);</span><br><span class="line">            //第一个扩散的圆形</span><br><span class="line">            int i1 = (int) (220.0F - (220.0F - 0.0F) / 100.0F</span><br><span class="line">                    * rippleFirstRadius);</span><br><span class="line">            mRipplePaint.setAlpha(i1);</span><br><span class="line">            canvas.drawCircle(mRippleViewWidth / 2, mRippleViewWidth / 2,</span><br><span class="line">                    mRippleViewRadius + f1 * rippleFirstRadius / 100.0F - 2,</span><br><span class="line">                    mRipplePaint);</span><br><span class="line">            //第二个扩散的圆形</span><br><span class="line">            if (rippleSecondRadius &gt;= 0) &#123;</span><br><span class="line">                int i3 = (int) (220.0F - (220.0F - 0.0F) / 100.0F</span><br><span class="line">                        * rippleSecondRadius);</span><br><span class="line">                mRipplePaint.setAlpha(i3);</span><br><span class="line">                canvas.drawCircle(mRippleViewWidth / 2, mRippleViewWidth / 2,</span><br><span class="line">                        mRippleViewRadius + f1 * rippleSecondRadius / 100.0F - 2,</span><br><span class="line">                        mRipplePaint);</span><br><span class="line">            &#125;</span><br><span class="line">            //第三个扩散的圆形</span><br><span class="line">            if (rippleThirdRadius &gt;= 0) &#123;</span><br><span class="line">                int i2 = (int) (220.0F - (220.0F - 0.0F) / 100.0F</span><br><span class="line">                        * rippleThirdRadius);</span><br><span class="line">                mRipplePaint.setAlpha(i2);</span><br><span class="line">                canvas.drawCircle(mRippleViewWidth / 2, mRippleViewWidth / 2,</span><br><span class="line">                        mRippleViewRadius + f1 * rippleThirdRadius / 100.0F -2,</span><br><span class="line">                        mRipplePaint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        float length = textPaint.measureText(mText);</span><br><span class="line">        canvas.drawText(mText, (mRippleViewWidth - length) / 2,</span><br><span class="line">                mRippleViewWidth / 2 + 5, textPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stratWave() &#123;</span><br><span class="line">        isStartRipple = true;</span><br><span class="line">        handler.post(mRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一共画了三个不断扩散的圆形。用了R的二十分之六的宽度作为第一个固定圆形的半径，三个圆形从固定半径向两边增大至R。三个圆形从里到外的时间相隔33个单位，透明度是从220递减到0。减去2是为了扩散的效果更好看一点。</p>
<p>布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.christmas.stickyheaderview.WaveView</span><br><span class="line">        android:id=&quot;@+id/rippleview&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        app:text=&quot;正在扫描中啦&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>WaveActivity.java中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mWaveView =(WaveView) findViewById(R.id.rippleview);</span><br><span class="line">mWaveView.stratWave();</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Androiod中View的工作原理</title>
    <url>/2018/01/15/view-meassure/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章主要讲解view的工作原理中的三大流程，包括测量流程，布局流程，绘制流程。这些都是自定义控件的基础。下面先对三大流程的职责做简要的概述：</p>
<p>测量流程确定了控件的测量的大小；<br>布局流程确定了控件在父控件中的四个位置的坐标和控件的实际大小；<br>绘制流程负责控件的绘制并显示在屏幕上。</p>
<h3 id="view的绘制流程是从哪里开始的？"><a href="#view的绘制流程是从哪里开始的？" class="headerlink" title="view的绘制流程是从哪里开始的？"></a>view的绘制流程是从哪里开始的？</h3><p>View的绘制流程是从ViewRoot的performTraversals开始的。在performTraversals经过一堆的逻辑，会分别调用performMeasure，performLayout，performDraw。<br>然后在view树中，先后调用一下的方法：<br><a id="more"></a><br>performMeasure，measure onMeasure<br>performLayout，layout, onLayout<br>performDraw, draw, onDraw, dispatchDraw(绘制子view)</p>
<p>ViewRoot的实现类是ViewRootImpl，在ActivityThread中创建。</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>MeasureSpec是view的测量规格，是一个int数值。在java中的int是32位的，所以MeasureSpec可以利用32位的一个数值来表示view的大少size和规格mode。在ViewRootImpl.java中提供了MeasureSpec组合和分解的方法。MeasureSpec是ViewRootImpl.java中的一个公开静态内部类，源码如下：</p>
<p>ViewRootImpl#MeasureSpec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class MeasureSpec &#123;</span><br><span class="line">    private static final int MODE_SHIFT = 30;</span><br><span class="line">    private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    /** @hide */</span><br><span class="line">    @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="line">    @Retention(RetentionPolicy.SOURCE)</span><br><span class="line">    public @interface MeasureSpecMode &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Measure specification mode: The parent has not imposed any constraint</span><br><span class="line">     * on the child. It can be whatever size it wants.</span><br><span class="line">     */</span><br><span class="line">    public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Measure specification mode: The parent has determined an exact size</span><br><span class="line">     * for the child. The child is going to be given those bounds regardless</span><br><span class="line">     * of how big it wants to be.</span><br><span class="line">     */</span><br><span class="line">    public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Measure specification mode: The child can be as large as it wants up</span><br><span class="line">     * to the specified size.</span><br><span class="line">     */</span><br><span class="line">    public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,</span><br><span class="line">                                      @MeasureSpecMode int mode) &#123;</span><br><span class="line">        if (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            return size + mode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    @MeasureSpecMode</span><br><span class="line">    public static int getMode(int measureSpec) &#123;</span><br><span class="line">        //noinspection ResourceType</span><br><span class="line">        return (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getSize(int measureSpec) &#123;</span><br><span class="line">        return (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面，MODE_SHIFT为什么是30？因为它是使用高2位表示mode，低30为表示size。<br>MODE_MASK为0x3，二进制表示是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0011</span><br></pre></td></tr></table></figure></p>
<p>它左移30位后为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1100 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure></p>
<p>由MODE_MASK理解组合makeMeasureSpec中的(size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size &amp; ~MODE_MASK，就是</span><br><span class="line"></span><br><span class="line">size &amp; ~MODE_MASK = size &amp; 0011 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">当size=32时，</span><br><span class="line">100000 &amp; ~MODE_MASK = 100000 &amp; 0011 1111 1111 1111 1111 1111 1111 1111 = 0000 0000 0000 0000 0000 0000 0010 0000 = 32</span><br><span class="line"></span><br><span class="line">同理可知mode</span><br><span class="line"></span><br><span class="line">最后做与运算，将它们相加</span><br></pre></td></tr></table></figure>
<p>从源码中可以看出，mode有UNSPECIFIED，EXACTLY，AT_MOST。其中UNSPECIFIED等于0，AT_MOST是小于0，EXACTLY等于0。</p>
<h3 id="MeasureSpec的创建和测量流程"><a href="#MeasureSpec的创建和测量流程" class="headerlink" title="MeasureSpec的创建和测量流程"></a>MeasureSpec的创建和测量流程</h3><p>MeasureSpec是由父容器的约束和布局参数LayoutParams共同决定的。它在DecorView和普通view中创建也是不一样的。DecorView的父容器是Window，所以DecorView的MeasureSpec由窗口大小和布局参数共同决定的。普通view是由父容器的MeasureSpec和布局参数共同决定的。</p>
<p>（1）在DecorView中</p>
<p>ViewRootImpl#measureHierarchy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ViewRootImpl#getRootMeasureSpec</span><br><span class="line">private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</span><br><span class="line">        int measureSpec;</span><br><span class="line">        switch (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">        case ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">            // Window can&apos;t resize. Force root view to be windowSize.</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">            break;</span><br><span class="line">        case ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">            // Window can resize. Set max size for root view.</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            // Window wants to be an exact size. Force root view to be that size.</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return measureSpec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当view设置MATCH_PARENT时，measureSpec的mode是MeasureSpec.EXACTLY，size是windowSize窗口大小。<br>当view设置WRAP_CONTENT时，measureSpec的mode是MeasureSpec.AT_MOST，size是windowSize窗口大小。<br>当view设置具体大小时，measureSpec的mode是MeasureSpec.EXACTLY，size是view设置的具体大小。</p>
<p>（2）在普通view中</p>
<p>ViewGroup#measureChildWithMargins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">            int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">            int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                        + widthUsed, lp.width);</span><br><span class="line">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                        + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在ViewGroup#getChildMeasureSpec<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">        int specMode = MeasureSpec.getMode(spec);</span><br><span class="line">        int specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">        int size = Math.max(0, specSize - padding);</span><br><span class="line"></span><br><span class="line">        int resultSize = 0;</span><br><span class="line">        int resultMode = 0;</span><br><span class="line"></span><br><span class="line">        switch (specMode) &#123;</span><br><span class="line">        // Parent has imposed an exact size on us</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size. So be it.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">                // bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // Parent has imposed a maximum size on us</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                // Child wants a specific size... so be it</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size, but our size is not fixed.</span><br><span class="line">                // Constrain child to not be bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">                // bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // Parent asked to see how big we want to be</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                // Child wants a specific size... let him have it</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size... find out how big it should</span><br><span class="line">                // be</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size.... find out how</span><br><span class="line">                // big it should be</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //noinspection ResourceType</span><br><span class="line">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在getChildMeasureSpec中列出了在父容器MeasureSpec和view的布局参数下创建MeasureSpec的各种情况。得到MeasureSpec后，在measureChildWithMargins中将它传递给child的measure方法。在measure方法再传给onMeasure方法。这就是onMeasure方法中两个参数的来源。</p>
<p>View#onMeasure</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>View#setMeasuredDimension中会调用setMeasuredDimensionRaw方法<br>View#setMeasuredDimensionRaw<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里就已经确定的view测量的大小。通过getMeasuredWidth()和getMeasuredHeight()就可以得到它们的值。</p>
<p>View#getSuggestedMinimumWidth<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int getSuggestedMinimumWidth() &#123;</span><br><span class="line">        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是说，控件是否设置了背景和最小大小。对应于android:background和android:minWidth。</p>
<p>View#getDefaultSize<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</span><br><span class="line">    int result = size;</span><br><span class="line">    int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">    case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        break;</span><br><span class="line">    case MeasureSpec.AT_MOST:</span><br><span class="line">    case MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UNSPECIFIED据说一般是用于表示内部正处于测量的状态。在普通view中我们只要关注AT_MOST和EXACTLY。当view设置match_parent和具体大小时，是EXACTLY，wrap_content时是AT_MOST。为什么会是这样？可以看getChildMeasureSpec方法中各种情况。</p>
<p>所以当我们自定义view时，如果不处理AT_MOST情况，即wrap_content时，控件的大少就是父控件的大小。EXACTLY是可以正常被getDefaultSize处理的。</p>
<p>在ViewGroup中是没有重写onMeasure方法的，因为ViewGroup的大小还与ViewGroup的具体的布局特性有关。如LinearLayout和RelativeLayout的onMeasure不一样的。所以自定义ViewGroup时，要重写onMeasure方法。</p>
<p>但是，ViewGroup提供了测量子view的方法的，measureChildren和measureChildWithMargins，measureChild。</p>
<p>ViewGroup#measureChildren</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    final int size = mChildrenCount;</span><br><span class="line">    final View[] children = mChildren;</span><br><span class="line">    for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">        final View child = children[i];</span><br><span class="line">        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup#measureChild<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void measureChild(View child, int parentWidthMeasureSpec,</span><br><span class="line">        int parentHeightMeasureSpec) &#123;</span><br><span class="line">    final LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ViewGroup#measureChildWithMargins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">            int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">            int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                        + widthUsed, lp.width);</span><br><span class="line">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                        + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>measureChild在measureChildren被循环遍历子view时调用。measureChildren和measureChildWithMargins的区别是，measureChildren是减去父控件的padding，而measureChildWithMargins减去了父控件的padding和view的margin。这直接影响了测量的大小是否包含了padding和margin。也就是view可以设置的最大大小是减去父控件的padding和view的内边距。</p>
<p>综上所述，在view中，就可以确定view的大小，提供了默认的onMeasure方法，但是默认的onMeasure方法不能正确处理AT_MOST（Wrap_content）的情况。在ViewGroup中，因为ViewGroup的具体大小和ViewGroup的布局特性有关，自定义ViewGroup要重写该方法。</p>
<h3 id="布局流程"><a href="#布局流程" class="headerlink" title="布局流程"></a>布局流程</h3><p>View#layout<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    int oldL = mLeft;</span><br><span class="line">    int oldT = mTop;</span><br><span class="line">    int oldB = mBottom;</span><br><span class="line">    int oldR = mRight;</span><br><span class="line"></span><br><span class="line">    boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在layout中分别调用了setFrame或者setOpticalFrame和onLayout。</p>
<p>setFrame或者setOpticalFrame中，赋值给mLeft，mTop，mRight，mBottom，确定了view的四个顶点，通过它们的get方法可以得到相应的值。这就确定了view在父控件中的位置坐标和view的宽和高。</p>
<p>View#onLayout是一个空实现。因为view只需要确定自己在父控件的位置即可。onLayout是用于在ViewGroup中确定子view的位置的。而onLayout的实现同样是与具体的ViewGroup的布局特性有关的。需要在自定义ViewGroup实现。</p>
<h3 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">         * in the appropriate order:</span><br><span class="line">         *</span><br><span class="line">         *      1. Draw the background</span><br><span class="line">         *      2. If necessary, save the canvas&apos; layers to prepare for fading</span><br><span class="line">         *      3. Draw view&apos;s content</span><br><span class="line">         *      4. Draw children</span><br><span class="line">         *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">         *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        // Step 1, draw the background, if needed</span><br><span class="line">        int saveCount;</span><br><span class="line"></span><br><span class="line">        if (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">        final int viewFlags = mViewFlags;</span><br><span class="line">        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class="line">        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class="line">        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            // Step 3, draw the content</span><br><span class="line">            if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            // Step 4, draw the children</span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            // Overlay is part of the content and draws beneath Foreground</span><br><span class="line">            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line">            ...</span><br><span class="line">        &#125;  </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>draw过程就是主要就是，上面源码所说的那几个步骤。</p>
<p>1、如果需要背景，绘制背景<br>2、onDraw中，绘制自身<br>3、dispatchDraw中，绘制子view<br>4、onDrawForeground中绘制装饰</p>
<p>在自定义ViewGroup时，可以在dispatchDraw中遍历子view进行绘制。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;com.example.hyj.ht_test.widget.custom.CustomViewGroup</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;com.example.hyj.ht_test.widget.custom.CustomViewGroup1</span><br><span class="line">        android:orientation=&quot;vertical&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line">       &lt;com.example.hyj.ht_test.widget.custom.CustomView</span><br><span class="line">           android:id=&quot;@+id/btn&quot;</span><br><span class="line">           android:background=&quot;@color/common_color&quot;</span><br><span class="line">           android:layout_margin=&quot;10dp&quot;</span><br><span class="line">           android:layout_width=&quot;match_parent&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/com.example.hyj.ht_test.widget.custom.CustomViewGroup1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/com.example.hyj.ht_test.widget.custom.CustomViewGroup&gt;</span><br></pre></td></tr></table></figure>
<p>CustomViewGroup1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomViewGroup1 extends ViewGroup &#123;</span><br><span class="line"></span><br><span class="line">    private Context mContext;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;CustomViewGroup&quot;;</span><br><span class="line"></span><br><span class="line">    ....构造函数...</span><br><span class="line"></span><br><span class="line">    public static class CustomLayoutParams extends MarginLayoutParams &#123;</span><br><span class="line"></span><br><span class="line">        public CustomLayoutParams(MarginLayoutParams source) &#123;</span><br><span class="line">            super(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public CustomLayoutParams(android.view.ViewGroup.LayoutParams source) &#123;</span><br><span class="line">            super(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public CustomLayoutParams(Context c, AttributeSet attrs) &#123;</span><br><span class="line">            super(c, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public CustomLayoutParams(int width, int height) &#123;</span><br><span class="line">            super(width, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成默认的布局参数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected CustomLayoutParams generateDefaultLayoutParams() &#123;</span><br><span class="line">        return new CustomLayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成布局参数</span><br><span class="line">     * 将布局参数包装成我们的</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected android.view.ViewGroup.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams p) &#123;</span><br><span class="line">        return new CustomLayoutParams(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成布局参数</span><br><span class="line">     * 从属性配置中生成我们的布局参数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public android.view.ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</span><br><span class="line">        return new CustomLayoutParams(getContext(), attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        //measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int parentWidth = 0;</span><br><span class="line">        int parentHeight = 0;</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        if(childCount &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">                View child = getChildAt(0);</span><br><span class="line">                measureChildWithMargins(child, widthMeasureSpec, 0,</span><br><span class="line">                        heightMeasureSpec, 0);</span><br><span class="line">                CustomLayoutParams clp = (CustomLayoutParams) child.getLayoutParams();</span><br><span class="line">                if (child.getVisibility() != View.GONE) &#123;</span><br><span class="line">                    parentWidth = getPaddingLeft() + getPaddingRight() +</span><br><span class="line">                            child.getMeasuredWidth() + clp.leftMargin + clp.rightMargin ;</span><br><span class="line">                    parentHeight = getPaddingTop() + getPaddingBottom() +</span><br><span class="line">                            child.getMeasuredHeight() + clp.topMargin + clp.bottomMargin;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(parentWidth, parentHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line"></span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        int paddingTop = 0;</span><br><span class="line">        if(childCount &gt; 0) &#123;</span><br><span class="line">            for(int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">                View child = getChildAt(i);</span><br><span class="line">                if(child.getVisibility() != View.GONE) &#123;</span><br><span class="line">                    int measuredHeight = child.getMeasuredHeight();</span><br><span class="line">                    int measuredWidth = child.getMeasuredWidth();</span><br><span class="line">                    CustomLayoutParams clp = (CustomLayoutParams) child.getLayoutParams();</span><br><span class="line">                    paddingTop = paddingTop + child.getPaddingTop();</span><br><span class="line">                    child.layout(getPaddingLeft() + clp.leftMargin,</span><br><span class="line">                            getPaddingTop() + clp.topMargin,</span><br><span class="line">                            getPaddingLeft() + clp.leftMargin + measuredWidth,</span><br><span class="line">                            getPaddingTop() + clp.leftMargin + measuredHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CustomViewGroup是默认的实现可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomView extends View &#123;</span><br><span class="line"></span><br><span class="line">    public CustomView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CustomView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        setMeasuredDimension(getSize(600, widthMeasureSpec),</span><br><span class="line">                getSize(600, heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getSize(int size, int measureSpec) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">        if(specMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            result = size;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = specSize;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这些代码是<a href="https://zhangsunyucong.top/2018/01/10/android-event/">《Android的MotionEvent事件分发机制》</a>中用的代码基础上加的.</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android的MotionEvent事件分发机制</title>
    <url>/2018/01/10/android-event/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="android事件的源头在哪里？"><a href="#android事件的源头在哪里？" class="headerlink" title="android事件的源头在哪里？"></a>android事件的源头在哪里？</h3><p>当用户触摸屏幕或者按键等时，形成事件，事件经过linux底层Event节点捕获之后，一直传到android应用层。中间传递的过程不是本文的重点，我也不是很清楚（哈哈哈）。本文的重点是事件在应用层的分发机制。</p>
<h3 id="事件在View树中的分发过程"><a href="#事件在View树中的分发过程" class="headerlink" title="事件在View树中的分发过程"></a>事件在View树中的分发过程</h3><p>View树：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/5520294f89844f022b28/event_01.jpg" alt="图片"></p>
<p>在Android中，事件的分发过程就是MotionEvent在view树分发的过程。默认是中从上而下，然后从下而上的传递的，直到有view、viewgroup或者Activity处理事件为止。<br><a id="more"></a></p>
<p>为什么要先从上而下？是为了在默认情况下，屏幕上层叠的所有控件都有机会处理事件。这个阶段我们称为事件下发阶段。</p>
<p>为什么要从下而上？是为了在从上而下分发时，事件没有控件处理时，再从下而上冒泡事件，是否有控件愿意处理事件。如果中间没有控件处理，事件就只能由Acitivity处理了。这个阶段我们称为事件的冒泡阶段。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>事件序列：从用户手指触摸屏幕开始，经过滑动到手指离开屏幕。这个操作产生了一个dowm事件，一系列move事件，最后一个up事件结束。我们把这一个操作产生的事件称为一个事件序列。</p>
<p>Acitivity中和事件传递有关的函数<br>事件分发：dispatchTouchEvent<br>事件处理：onTouchEvent</p>
<p>ViewGrop中和事件传递有关的函数<br>事件分发：dispatchTouchEvent<br>事件拦截：onInterceptTouchEvent<br>事件处理：onTouchEvent</p>
<p>View中和事件传递有关的函数<br>事件分发：dispatchTouchEvent<br>事件处理：onTouchEvent</p>
<p>从上面可以看出，ViewGrop中多了事件拦截onInterceptTouchEvent函数，是为了询问自己是否拦截事件（在事件分发中询问），如果没有拦截就传递事件给直接子view，如果拦截就将事件交给自己的事件处理函数处理。View中没有事件拦截函数，因为view是在view树中的叶节点，已经没有子view。</p>
<p>下面是先进行源码分析，然后再验证得出一些结论。代码迟点上传github。<br>用图表示布局的层级关系：<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/be1f2f5062c687a7c915/event02.jpg" alt="图片"></p>
<p>这里分析事件的分发过程，是从down事件的分发开始，以及分析它在两个阶段的传递过程：下发阶段和冒泡阶段。</p>
<h3 id="事件下发阶段"><a href="#事件下发阶段" class="headerlink" title="事件下发阶段"></a>事件下发阶段</h3><p>（1）在Acitvity中的源码分析：</p>
<p>Activity#dispatchTouchEvent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第4行，Acivity将事件传递给了Window，Window是一个抽象类。在手机系统中它的实现是PhoneWindow.下面进入PhoneWindow中。</p>
<p>PhoneWindow#superDispatchTouchEvent<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，事件已经从Acitivity到PhoneWindow，再传到了DecorView。DecorView是一个继承FrameLayout的ViewGroup，从而事件进入了View树的传递。</p>
<p>重写在Acitvity中的事件传递方法</p>
<p>重写Activity#dispatchTouchEvent：<br>1、返回false，事件不分发，所有事件在Acitivity的分发函数中就中断（真的不见了），连Acitivity的事件处理函数都到达不了。<br>2、返回true，所有事件在Acitivity的分发函数中就中断，和false一样<br>3、返回父函数方法，事件就传给直接子view分发</p>
<p>进一步的，DecorView是一个FrameLayout，也即是一个ViewGruop。</p>
<p>（2）在ViewGruop中的源码分析：<br>ViewGruop#dispatchTouchEvent<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int action = ev.getAction();</span><br><span class="line">final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">// Handle an initial down.</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    // Throw away all previous state when starting a new touch gesture.</span><br><span class="line">    // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class="line">    // due to an app switch, ANR, or some other state change.</span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Check for interception.</span><br><span class="line">final boolean intercepted;</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">    || mFirstTouchTarget != null) &#123;</span><br><span class="line">        final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">        if (!disallowIntercept) &#123;</span><br><span class="line">            intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">            ev.setAction(action); // restore action in case it was changed</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            intercepted = false;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // There are no touch targets and this action is not an initial down</span><br><span class="line">    // so this view group continues to intercept touches.</span><br><span class="line">    intercepted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在5-11行，是每个新的事件系列开始前，会重置事件相关的状态。这里我们关注两个地方。第一个是第17行的disallowIntercept标志，第二个是第19行调用了事件拦截函数，询问是否拦截事件。</p>
<p>ViewGruop#onInterceptTouchEvent<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onInterceptTouchEvent的代码很简单。</p>
<p>重写在ViewGroup中的事件传递方法<br>重写ViewGroup#dispatchTouchEvent：<br>1、返回false，不分发，down事件给父ViewGroup处理，以后的事件全部直接通过父ViewGroup分发函数给父ViewGroup的事件处理函数处理。<br>2、返回true，则所有的事件都从头来到这里就中断，不见了。<br>3、返回父函数方法，看下面拦截函数</p>
<p>重写ViewGroup#onInterceptTouchEvent（询问是否拦截）：<br>1、返回true，就调用处理函数，在处理函数中是否消耗down事件<br>2、返回false，是否是最后一个view？否，down事件就分发给子View；是，就调用一次它的处理函数，进入冒泡阶段（就是一寸事件处理函数调用）<br>3、返回父函数的方法，和返回false一样</p>
<p>重写ViewGroup的onTouchEvent，当down事件来到中onTouchEvent时，<br>1、返回true，就消耗down事件，后面全部事件从头分发到处理函数（不用再询问是否拦截）。后面的事件根据是否消耗而是否消失（不消耗就消失），消失的所有事件由Acitivity处理（注意消失的事件也是从头传递到这里再传给Acitivity的）。<br>2、返回false，将down事件冒泡回去，看谁会处理。<br>3、返回父函数方法，是默认不消耗。</p>
<p>（3）在View中的源码分析：<br>View#dispatchTouchEvent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">    if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">        result = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //noinspection SimplifiableIfStatement</span><br><span class="line">    ListenerInfo li = mListenerInfo;</span><br><span class="line">    if (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class="line">        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">        result = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里关注的地方是，第9行和第13行。第9行是当前view如果设置了onTouch事件，并且它返回了true，那它就直接将result设置为true，事件就消耗了，不会再继续传递下去，只到达onTouch。第13行，是事件处理函数。可以看出onTouch是优先于onTouchEvent的。</p>
<p>View#onTouchEvent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line">...                </span><br><span class="line"></span><br><span class="line">if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">            handleTooltipUp();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!clickable) &#123;</span><br><span class="line">            removeTapCallback();</span><br><span class="line">            removeLongPressCallback();</span><br><span class="line">            mInContextButtonPress = false;</span><br><span class="line">            mHasPerformedLongPress = false;</span><br><span class="line">            mIgnoreNextUpEvent = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</span><br><span class="line">        if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</span><br><span class="line">            // take focus if we don&apos;t have it already and we should in</span><br><span class="line">            // touch mode.</span><br><span class="line">            boolean focusTaken = false;</span><br><span class="line">            if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                focusTaken = requestFocus();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (prepressed) &#123;</span><br><span class="line">                // The button is being released before we actually</span><br><span class="line">                // showed it as pressed.  Make it show the pressed</span><br><span class="line">                // state now (before scheduling the click) to ensure</span><br><span class="line">                // the user sees it.</span><br><span class="line">                setPressed(true, x, y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                // This is a tap, so remove the longpress check</span><br><span class="line">                removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                // Only perform take click actions if we were in the pressed state</span><br><span class="line">                if (!focusTaken) &#123;</span><br><span class="line">                    // Use a Runnable and post this rather than calling</span><br><span class="line">                    // performClick directly. This lets other visual state</span><br><span class="line">                    // of the view update before click actions start.</span><br><span class="line">                    if (mPerformClick == null) &#123;</span><br><span class="line">                        mPerformClick = new PerformClick();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!post(mPerformClick)) &#123;</span><br><span class="line">                        performClick();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>view根据是否可以点击等等一系列判断什么的。这里关注up事件中的第42-53行，有performClick。</p>
<p>View#performClick<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean performClick() &#123;</span><br><span class="line">    final boolean result;</span><br><span class="line">    final ListenerInfo li = mListenerInfo;</span><br><span class="line">    if (li != null &amp;&amp; li.mOnClickListener != null) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(this);</span><br><span class="line">        result = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">    notifyEnterOrExitForAutoFillIfNeeded(true);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果view设置了mOnClickListener，即点击事件，会调用view的点击事件。如果在父view中拦截了up事件，使up事件到达不了这里，会使view的点击事件失效。</p>
<p>可以知道，onTouch是优先于onTouchEvent，onTouchEvent优先于onclick。</p>
<h3 id="事件冒泡阶段"><a href="#事件冒泡阶段" class="headerlink" title="事件冒泡阶段"></a>事件冒泡阶段</h3><p>当down事件到达了最后一个子view，如果仍然没有view愿意处理它，就调用一次最后一个子view的事件处理函数，是否处理dowm事件，如果不处理，就一直冒泡回去，直到有view的onTouchEvent处理为止。如果都不处理，就只有Acitivity自己处理了。整个事件冒泡阶段就是一串onTouchEvent的回溯过程，自下而上。</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>《火影忍者》--鸣人和雏田</title>
    <url>/2017/12/28/huoying/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/8dddb62b9568789979a0/huoying_tou.jpg" alt="鸣人和雏田"></p>
<p>那个时候所有人只是把鸣人当做孤儿看待。他长相最多只能算一般，成绩吊车尾，缺家教，没才华，家世没有，血统没有，智商没有，然后还调皮爱恶作剧。<br><a id="more"></a></p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/4a7588942ae5efc53e67/huoying_4_1.jpg" alt></p>
<p>除非傻子才会喜欢那时的鸣人。但是雏田硬是喜欢上了，这一喜欢，不仅坚持了好多年，而且还因为这份喜欢，改变了自己。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/8fd660df51be779c59d9/huoying_5_2.jpg" alt></p>
<p>雏田她硬是透过了种种外在因素，一眼就看清楚了鸣人的内在：阳光，乐观，有梦想，能努力，坚持到底，不服输。可以看出她是多么强大的主见，不理会别人看法的主见。<br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/54a728ba8f1e71e4eae9/huoying_5_5.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/dcd685046054a3b8c93a/huoying_5_6.jpg" alt></p>
<p>雏田总是在默默注视着鸣人，一直支持着他，追赶着他。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/0a03080dce9656d30ca0/huoying_5_1.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/c37399b3a09435060ada/huoying_5_4.jpg" alt></p>
<p>你知道当你一个人面临绝望的时候，此时却有一个义无反顾的身影挡在你面前，保护你，是什么感觉吗？</p>
<p>在佩恩来袭，鸣人最为脆弱的时候，挡在他身前保护他。鸣人在十尾的木遁下无处可逃时，她也毅然决然的挡在他身前。<br>那么一个弱弱小小的女孩子，她的勇敢和坚毅却超乎寻常的强大。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/9bab0c3dd4952eb187ba/huoying_1_1.jpg" alt></p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/175deafafe31134833a8/huoying_1_2.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/26a293cf93de59017246/huoying_1_3.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/fda4fe4f4acdec0e4c91/huoying_1_4.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/bd80564c20d8332424c6/huoying_1_5.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/0782e24715a1c192c3c3/huoying_1_6.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/312a2940f49961f8dd5d/huoying_1_7.jpg" alt></p>
<p>两个人第一次去约会，鸣人却因为没钱请不起高级料理，不知道怎么开口。雏田用白眼看鸣人的钱包，然后主动说去吃一乐拉面。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/2ee9a429639b6b9f0441/%E7%BA%A6%E4%BC%9A.jpg" alt></p>
<p>忍界大战开始中。《宁次之死》，让雏田和鸣人打击沉重，鸣人的意志开始动摇，在鸣人内心的防线即将崩溃时，雏田强忍失去亲人的伤痛，一巴掌打醒鸣人，告诉鸣人是宁次用生命换取他活下去的用意，告诉鸣人要清醒，要秉持自己的信念，不要放弃自己的忍道，鼓励他带领大家继续战斗。<br>雏田她看似弱不禁风的外表下其实有着很强大的内心和很坚强的意志。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/c4082571be1edeafddfe/huoying_2_1.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/b66d68c3c7952caadc5f/huoying_2_2.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/af4850f264e3327a5be2/huoying_2_3.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/b224882c6d3b78ccc2aa/huoying_2_4.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/beaa430e3d730df0850e/huoying_2_5.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/6c014e21c307efc9b32b/huoying_2_6.jpg" alt></p>
<p>忍界大战胜利后，鸣人成为救世主。</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/d1e1bb95026bc70812d0/%E8%83%9C%E5%88%A9.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/5fbe8bbd42a9af47c5f1/%E8%83%9C%E5%88%A91.jpg" alt></p>
<p>多年之后，鸣人的儿子博人问鸣人：“爸爸，你年轻的时候干了什么伟大的事啊？”<br>鸣人摸了摸他的头，然后说：“我用了十五年，帮我曾经最喜欢的女生追回了她的丈夫。”儿子又问：“那妈妈呢？”鸣人眼里光线都温柔了：“妈妈坚持爱到了我爱她的那一天。“</p>
<p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/2ca111c96dea88f8a9ee/huoying_3_1.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/b8070eedeb6afa158f69/huoying_3_3.jpg" alt><br><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/48652c80d3590b42d89e/huoying_3_4.jpeg" alt></p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>android和nodejs搭建一个应用</title>
    <url>/2017/12/25/android-encryption/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为什么想写这一篇文章呢？做android的开发也有两年的时间了，就想把以前学到的一些东西记录下来。于是首先就想在github.com上开一个项目<a href="https://github.com/zhangsunyucong/MVPDemo" target="_blank" rel="noopener">MVPDemo</a>,将一些自己认为比较好的知识点都串联起来。</p>
<p>主要目的：<br>1、初步认识和使用MVP、dagger2和rxJava2<br>2、使用对称和非对称加密加强前端与后台的安全机制<br>3、前后台的socket交互实现</p>
<p>其中3、中的socket实现，我专门建了一个github仓库<a href="https://github.com/zhangsunyucong/NodeTestDemo" target="_blank" rel="noopener">NodeTestDemo</a>，这个仓库不仅仅实现了前端的普通接口，还提供了一个socket服务。<br><a id="more"></a></p>
<h3 id="android端实现"><a href="#android端实现" class="headerlink" title="android端实现"></a>android端实现</h3><p>1、采用了MVP架构，使用dagger2对象依赖注入框架解耦MVP的各个组件<br>2、界面采用了autolayout进行兼容适配，UI尺寸标准是720*1080.页面效果仿微信。<br>3、rxjava2、rxlifecycle2，rxbinding2等Rx系列的初级使用<br>4、与后台服务器接口交互使用了retrofit2，交互的数据格式为json<br>5、自定义retrofit2的ConverterFactory和Interceptor实现统一加解密交互的数据流程<br>6、事件总线eventbus3、控件注入框架butterknife、GreenDao3对象关系映射数据库的使用<br>7、socket的前端简单实现<br>8、PDF文档库android-pdf-viewer的使用<br>9、使用jsoup解析csdn网站的html页面获取博主的博客信息<br>10、接入bugly。可以使用budly跟踪异常奔溃信息和bugly基于tinker的热修复。<br>11、接入腾讯X5内核浏览器服务代替原生的webview<br>12、页面路由Arouter的初步使用<br>13、app端出现异常，在杀死应用前，启动异常页面并允许用户点击重启<br>14、Cmake的使用。可以将敏感或者需要保密的数据使用jni保护，如第三方开发者平台的appid等</p>
<h3 id="后台安全数据安全交互机制"><a href="#后台安全数据安全交互机制" class="headerlink" title="后台安全数据安全交互机制"></a>后台安全数据安全交互机制</h3><p>1、后台服务器使用了leancloud和nodejs搭建。<a href="https://github.com/zhangsunyucong/NodeTestDemo" target="_blank" rel="noopener">nodejs服务器源码</a><br>2、android端的数据加密流程：</p>
<p>nodejs使用的是node-rsa模块</p>
<p>（1）生成RSA加解密的公钥和私钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rsa = require(&apos;node-rsa&apos;);</span><br><span class="line">//create RSA-key</span><br><span class="line">var key = new rsa(&#123;b: 1024&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;私：\n&quot; +  key.exportKey(&apos;private&apos;));</span><br><span class="line">console.log(&quot;公：\n&quot; +  key.exportKey(&apos;public&apos;));</span><br></pre></td></tr></table></figure>
<p>将服务器公钥分发给前端，私钥保存好放到服务器端。</p>
<p>（2）后台为一个前端生成一对AppId和AppScrect。前后端各保存一份，建议在android端将它们放到JNI中保护。</p>
<p>AppId用于在前端参与参数签名，AppScrect用于服务器返回数据的AES加密密钥。</p>
<p>（3）在Android端，应用每次启动时生成用于参数AES加密的密钥。这样可以使AES加密密钥是动态变化的。</p>
<p>（4）、将请求参数按照key的自然顺序进行排序，构造源串。然后在源串追加AppId得到签名字符串signString，用AES密钥加密signString，得到签名sign。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 按照key的自然顺序进行排序，并返回 */</span><br><span class="line">private Map&lt;String, Object&gt; getSortedMapByKey(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">    Comparator&lt;String&gt; comparator = new Comparator&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String lhs, String rhs) &#123;</span><br><span class="line">            return lhs.compareTo(rhs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Map&lt;String, Object&gt; treeMap = new TreeMap&lt;&gt;(comparator);</span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        treeMap.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    return treeMap;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">/** 构造源串 */    </span><br><span class="line">public String getSignParamsString(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">    //map.put(&quot;nonce&quot;, getRndStr(6 + RANDOM.nextInt(8)));</span><br><span class="line">    //map.put(&quot;timestamp&quot;, &quot;&quot; + (System.currentTimeMillis() / 1000L));</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry : getSortedMapByKey(map).entrySet()) &#123;</span><br><span class="line">        sb.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue()).append(&quot;&amp;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 构造源串 */  </span><br><span class="line">public String getSign(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">    String sign = getSignParamsString(map) + &quot;appId=&quot; + AppConfig.AppId;</span><br><span class="line">    return sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：如果要求服务器只允许一定时间范围内的请求，可以在getSignParamsString方法中添加时间戳作为接口签名的一部分，防止重放攻击。</p>
<p>（4）将签名sign和签名的字符串signString进行AES加密，将AES加密密钥用服务器公钥加密，后传给服务器.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSAUtils.encryptByServerPublicKey(App.getApp().getAESKey());</span><br><span class="line">AESUtils.encryptData(App.getApp().getAESKey(), signString);</span><br><span class="line">AESUtils.encryptData(App.getApp().getAESKey(), sign);</span><br></pre></td></tr></table></figure>
<p>signString为什么在前端生成呢？<br>为了在服务器重新生成签名字符串时，防止由于前后端开发语言的不同而产生不一致。</p>
<p>（5）服务器解密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function valideReqSign(req) &#123;</span><br><span class="line"></span><br><span class="line">    var sourceSign = req.body.sign;</span><br><span class="line">    var signString = req.body.signString;</span><br><span class="line">    var key = req.body.aesKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(paramUtility.isEnpty(key)</span><br><span class="line">        || paramUtility.isEnpty(sourceSign)</span><br><span class="line">        || paramUtility.isEnpty(signString)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //a、步骤</span><br><span class="line">    key = serverPrivateKey.decrypt(key,  &apos;utf-8&apos;);</span><br><span class="line">    //b、步骤</span><br><span class="line">    signString = aesUtils.AESDec(key, signString);</span><br><span class="line">     //c、步骤</span><br><span class="line">    signString = signString + &quot;appId=&quot; + decAndEncConfig.getAppId();</span><br><span class="line">    var localSign = aesUtils.AESEnc(key, signString);</span><br><span class="line">    //d、步骤</span><br><span class="line">    if(sourceSign !== localSign) &#123;</span><br><span class="line">        var resJson = &#123;</span><br><span class="line">            &quot;data&quot;: &#123;&#125;,</span><br><span class="line">            &quot;msg&quot;: &quot;签名不正确&quot;,</span><br><span class="line">            &quot;status&quot;: 205</span><br><span class="line">        &#125;;</span><br><span class="line">        if(!paramUtility.isNULL(res)) &#123;</span><br><span class="line">            res.end(jsonUtil.josnObj2JsonString(resJson));</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a、取出参数，用服务器RSA私钥解密AES密钥<br>b、用AES密钥解密签名和签名字符串<br>c、签名字符串追加分发给前端的AppScrect后，用a、得到的AES加密重新生产签名。<br>d、对比前端传来的签名和重新生成的签名是否一致。</p>
<p>（5）根据AppId找到对应的AppScrect，用AppScrect对服务器返回的结果进行AES加密。</p>
<p>注意：确保前后端在不同开发语言情况下，AES算法的结果是一样的。</p>
<p>后面会给出我用到的java和nodejs版本的RSA和AES加解密算法源码。</p>
<p>（6）前端从JNI中取出AppScrect对响应结果进行解密即可。</p>
<h3 id="前后端加解密算法源码"><a href="#前后端加解密算法源码" class="headerlink" title="前后端加解密算法源码"></a>前后端加解密算法源码</h3><h4 id="java的RSA加解密算法"><a href="#java的RSA加解密算法" class="headerlink" title="java的RSA加解密算法"></a>java的RSA加解密算法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.security.Key;</span><br><span class="line">import java.security.KeyFactory;</span><br><span class="line">import java.security.KeyPair;</span><br><span class="line">import java.security.KeyPairGenerator;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.PrivateKey;</span><br><span class="line">import java.security.PublicKey;</span><br><span class="line">import java.security.interfaces.RSAPrivateKey;</span><br><span class="line">import java.security.interfaces.RSAPublicKey;</span><br><span class="line">import java.security.spec.InvalidKeySpecException;</span><br><span class="line">import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">import java.security.spec.RSAPrivateKeySpec;</span><br><span class="line">import java.security.spec.RSAPublicKeySpec;</span><br><span class="line">import java.security.spec.X509EncodedKeySpec;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line"></span><br><span class="line">public class RSAUtils &#123;</span><br><span class="line"></span><br><span class="line">	public static final String PRIVATE_KEY = &quot;填写自己的private ky&quot;;</span><br><span class="line">	private static final String PUBLIC_KEY = AppConfig.RSA_SERVER_PUBLIC_KEY_STR;</span><br><span class="line"></span><br><span class="line">	/** RSA最大加密明文大小 */</span><br><span class="line">	private static final int MAX_ENCRYPT_BLOCK = 117;</span><br><span class="line"></span><br><span class="line">	/** RSA最大解密密文大小 */</span><br><span class="line">	private static final int MAX_DECRYPT_BLOCK = 128;</span><br><span class="line"></span><br><span class="line">	/** 加密算法RSA */</span><br><span class="line">	private static final String KEY_ALGORITHM = &quot;RSA&quot;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 生成公钥和私钥</span><br><span class="line">	 * </span><br><span class="line">	 * @throws Exception</span><br><span class="line">	 * </span><br><span class="line">	 */</span><br><span class="line">	public static void getKeys() throws Exception &#123;</span><br><span class="line">		KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">		keyPairGen.initialize(1024);</span><br><span class="line">		KeyPair keyPair = keyPairGen.generateKeyPair();</span><br><span class="line">		RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">		RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">		String publicKeyStr = getPublicKeyStr(publicKey);</span><br><span class="line">		String privateKeyStr = getPrivateKeyStr(privateKey);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;公钥\r\n&quot; + publicKeyStr);</span><br><span class="line">		System.out.println(&quot;私钥\r\n&quot; + privateKeyStr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 使用模和指数生成RSA公钥</span><br><span class="line">	 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，不同JDK默认的补位方式可能不同，如Android默认是RSA</span><br><span class="line">	 * /None/NoPadding】</span><br><span class="line">	 * </span><br><span class="line">	 * @param modulus</span><br><span class="line">	 *            模</span><br><span class="line">	 * @param exponent</span><br><span class="line">	 *            公钥指数</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static RSAPublicKey getPublicKey(String modulus, String exponent) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			BigInteger b1 = new BigInteger(modulus);</span><br><span class="line">			BigInteger b2 = new BigInteger(exponent);</span><br><span class="line">			KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">			RSAPublicKeySpec keySpec = new RSAPublicKeySpec(b1, b2);</span><br><span class="line">			return (RSAPublicKey) keyFactory.generatePublic(keySpec);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 使用模和指数生成RSA私钥</span><br><span class="line">	 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，不同JDK默认的补位方式可能不同，如Android默认是RSA</span><br><span class="line">	 * /None/NoPadding】</span><br><span class="line">	 * </span><br><span class="line">	 * @param modulus</span><br><span class="line">	 *            模</span><br><span class="line">	 * @param exponent</span><br><span class="line">	 *            指数</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static RSAPrivateKey getPrivateKey(String modulus, String exponent) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			BigInteger b1 = new BigInteger(modulus);</span><br><span class="line">			BigInteger b2 = new BigInteger(exponent);</span><br><span class="line">			KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">			RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(b1, b2);</span><br><span class="line">			return (RSAPrivateKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String encryptByServerPublicKey(String data) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return RSAUtils.encryptByPublicKey(data);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return &quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String decryptByClentPrivateKey(String data) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return RSAUtils.decryptByPrivateKey(data);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//</span><br><span class="line">	private String schel = &quot;RSA/ECB/OAEPWithSHA1AndMGF1Padding&quot;;</span><br><span class="line">	/**</span><br><span class="line">	 * 公钥加密</span><br><span class="line">	 *&quot;RSA/ECB/PKCS1Padding&quot;</span><br><span class="line">	 * @param data</span><br><span class="line">	 * @return</span><br><span class="line">	 * @throws Exception</span><br><span class="line">	 */</span><br><span class="line">	private static String encryptByPublicKey(String data) throws Exception &#123;</span><br><span class="line">		byte[] dataByte = data.getBytes();</span><br><span class="line">		byte[] keyBytes = Base64Utils.decode(PUBLIC_KEY);</span><br><span class="line">		X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);</span><br><span class="line">		KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">		Key publicK = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">		// 对数据加密</span><br><span class="line">		// Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">		Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);</span><br><span class="line">		cipher.init(Cipher.ENCRYPT_MODE, publicK);</span><br><span class="line">		int inputLen = dataByte.length;</span><br><span class="line">		ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">		int offSet = 0;</span><br><span class="line">		byte[] cache;</span><br><span class="line">		int i = 0;</span><br><span class="line">		// 对数据分段加密</span><br><span class="line">		while (inputLen - offSet &gt; 0) &#123;</span><br><span class="line">			if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line">				cache = cipher.doFinal(dataByte, offSet, MAX_ENCRYPT_BLOCK);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				cache = cipher.doFinal(dataByte, offSet, inputLen - offSet);</span><br><span class="line">			&#125;</span><br><span class="line">			out.write(cache, 0, cache.length);</span><br><span class="line">			i++;</span><br><span class="line">			offSet = i * MAX_ENCRYPT_BLOCK;</span><br><span class="line">		&#125;</span><br><span class="line">		byte[] encryptedData = out.toByteArray();</span><br><span class="line">		out.close();</span><br><span class="line">		return Base64Utils.encode(encryptedData);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 私钥解密</span><br><span class="line">	 * </span><br><span class="line">	 * @param data</span><br><span class="line">	 * @return*</span><br><span class="line">	 * @throws Exception</span><br><span class="line">	 */</span><br><span class="line">	private static String decryptByPrivateKey(String data) throws Exception &#123;</span><br><span class="line">		byte[] encryptedData = Base64Utils.decode(data);</span><br><span class="line">		byte[] keyBytes = Base64Utils.decode(PRIVATE_KEY);</span><br><span class="line">		PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">		KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM, &quot;BC&quot;);</span><br><span class="line">		Key privateK = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">		// Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">		Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);</span><br><span class="line"></span><br><span class="line">		cipher.init(Cipher.DECRYPT_MODE, privateK);</span><br><span class="line">		int inputLen = encryptedData.length;</span><br><span class="line">		ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">		int offSet = 0;</span><br><span class="line">		byte[] cache;</span><br><span class="line">		int i = 0;</span><br><span class="line">		// 对数据分段解密</span><br><span class="line">		while (inputLen - offSet &gt; 0) &#123;</span><br><span class="line">			if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">				cache = cipher</span><br><span class="line">						.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				cache = cipher</span><br><span class="line">						.doFinal(encryptedData, offSet, inputLen - offSet);</span><br><span class="line">			&#125;</span><br><span class="line">			out.write(cache, 0, cache.length);</span><br><span class="line">			i++;</span><br><span class="line">			offSet = i * MAX_DECRYPT_BLOCK;</span><br><span class="line">		&#125;</span><br><span class="line">		byte[] decryptedData = out.toByteArray();</span><br><span class="line">		out.close();</span><br><span class="line">		return new String(decryptedData);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 获取模数和密钥</span><br><span class="line">	 * </span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static Map&lt;String, String&gt; getModulusAndKeys() &#123;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			InputStream in = RSAUtils.class</span><br><span class="line">					.getResourceAsStream(&quot;/rsa.properties&quot;);</span><br><span class="line">			Properties prop = new Properties();</span><br><span class="line">			prop.load(in);</span><br><span class="line"></span><br><span class="line">			String modulus = prop.getProperty(&quot;modulus&quot;);</span><br><span class="line">			String publicKey = prop.getProperty(&quot;publicKey&quot;);</span><br><span class="line">			String privateKey = prop.getProperty(&quot;privateKey&quot;);</span><br><span class="line"></span><br><span class="line">			in.close();</span><br><span class="line"></span><br><span class="line">			map.put(&quot;modulus&quot;, modulus);</span><br><span class="line">			map.put(&quot;publicKey&quot;, publicKey);</span><br><span class="line">			map.put(&quot;privateKey&quot;, privateKey);</span><br><span class="line"></span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 从字符串中加载公钥</span><br><span class="line">	 * </span><br><span class="line">	 * @param publicKeyStr</span><br><span class="line">	 *            公钥数据字符串</span><br><span class="line">	 * @throws Exception</span><br><span class="line">	 *             加载公钥时产生的异常</span><br><span class="line">	 */</span><br><span class="line">	public static PublicKey loadPublicKey(String publicKeyStr) throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			byte[] buffer = Base64Utils.decode(publicKeyStr);</span><br><span class="line">			KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">			X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);</span><br><span class="line">			return (RSAPublicKey) keyFactory.generatePublic(keySpec);</span><br><span class="line">		&#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">			throw new Exception(&quot;无此算法&quot;);</span><br><span class="line">		&#125; catch (InvalidKeySpecException e) &#123;</span><br><span class="line">			throw new Exception(&quot;公钥非法&quot;);</span><br><span class="line">		&#125; catch (NullPointerException e) &#123;</span><br><span class="line">			throw new Exception(&quot;公钥数据为空&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 从字符串中加载私钥&lt;br&gt;</span><br><span class="line">	 * 加载时使用的是PKCS8EncodedKeySpec（PKCS#8编码的Key指令）。</span><br><span class="line">	 * </span><br><span class="line">	 * @param privateKeyStr</span><br><span class="line">	 * @return</span><br><span class="line">	 * @throws Exception</span><br><span class="line">	 */</span><br><span class="line">	public static PrivateKey loadPrivateKey(String privateKeyStr)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			byte[] buffer = Base64Utils.decode(privateKeyStr);</span><br><span class="line">			// X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);</span><br><span class="line">			PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(buffer);</span><br><span class="line">			KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">			return (RSAPrivateKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line">		&#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">			throw new Exception(&quot;无此算法&quot;);</span><br><span class="line">		&#125; catch (InvalidKeySpecException e) &#123;</span><br><span class="line">			throw new Exception(&quot;私钥非法&quot;);</span><br><span class="line">		&#125; catch (NullPointerException e) &#123;</span><br><span class="line">			throw new Exception(&quot;私钥数据为空&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String getPrivateKeyStr(PrivateKey privateKey)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">		return new String(Base64Utils.encode(privateKey.getEncoded()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String getPublicKeyStr(PublicKey publicKey) throws Exception &#123;</span><br><span class="line">		return new String(Base64Utils.encode(publicKey.getEncoded()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		getKeys();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="java的AES加解密算法"><a href="#java的AES加解密算法" class="headerlink" title="java的AES加解密算法"></a>java的AES加解密算法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line">import javax.crypto.spec.IvParameterSpec;</span><br><span class="line">import javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * AES工具类，密钥必须是16位字符串</span><br><span class="line"> */</span><br><span class="line">public class AESUtils &#123;</span><br><span class="line"></span><br><span class="line">	/**偏移量,必须是16位字符串*/</span><br><span class="line">    private static final String IV_STRING = &quot;16-Bytes--String&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认的密钥</span><br><span class="line">     */</span><br><span class="line">    public static final String DEFAULT_KEY = &quot;1bd83b249a414036&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 产生随机密钥(这里产生密钥必须是16位)</span><br><span class="line">     */</span><br><span class="line">    public static String generateKey() &#123;</span><br><span class="line">        String key = UUID.randomUUID().toString();</span><br><span class="line">        key = key.replace(&quot;-&quot;, &quot;&quot;).substring(0, 16);// 替换掉-号</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密</span><br><span class="line">     * @param key</span><br><span class="line">     * @param content</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String encryptData(String key, String content) &#123;</span><br><span class="line">        byte[] encryptedBytes = new byte[0];</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] byteContent = content.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">            // 注意，为了能与 iOS 统一</span><br><span class="line">            // 这里的 key 不可以使用 KeyGenerator、SecureRandom、SecretKey 生成</span><br><span class="line">            byte[] enCodeFormat = key.getBytes();</span><br><span class="line">            SecretKeySpec secretKeySpec = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);</span><br><span class="line">            byte[] initParam = IV_STRING.getBytes();</span><br><span class="line">            IvParameterSpec ivParameterSpec = new IvParameterSpec(initParam);</span><br><span class="line">            // 指定加密的算法、工作模式和填充方式</span><br><span class="line">            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);</span><br><span class="line">            encryptedBytes = cipher.doFinal(byteContent);</span><br><span class="line">            // 同样对加密后数据进行 base64 编码</span><br><span class="line">            return Base64Utils.encode(encryptedBytes);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     * @param key</span><br><span class="line">     * @param content</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String decryptData(String key, String content) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // base64 解码</span><br><span class="line">            byte[] encryptedBytes = Base64Utils.decode(content);</span><br><span class="line">            byte[] enCodeFormat = key.getBytes();</span><br><span class="line">            SecretKeySpec secretKey = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);</span><br><span class="line">            byte[] initParam = IV_STRING.getBytes();</span><br><span class="line">            IvParameterSpec ivParameterSpec = new IvParameterSpec(initParam);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);</span><br><span class="line">            byte[] result = cipher.doFinal(encryptedBytes);</span><br><span class="line">            return new String(result, &quot;UTF-8&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">		String plainText = AESUtils.decryptData(&quot;F431E6FF9051DA07&quot;, &quot;q8jHYk6LSbwC2K4zmr/wRZo8mlH0VdMzPEcAzQadTCpSrPQ/ZnTmuIvQxiLOnUXu&quot;);</span><br><span class="line">		System.out.println(&quot;aes加密后: &quot; + plainText);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="node-js的RSA加解密算法"><a href="#node-js的RSA加解密算法" class="headerlink" title="node.js的RSA加解密算法"></a>node.js的RSA加解密算法</h4><p>使用”node-rsa”: “^0.4.2”，模块</p>
<h4 id="node-js的AES加解密算法"><a href="#node-js的AES加解密算法" class="headerlink" title="node.js的AES加解密算法"></a>node.js的AES加解密算法</h4><p>AES算法:<a href="http://o8bym0zmt.bkt.clouddn.com/aes.js" target="_blank" rel="noopener">aes.js</a></p>
<p>进一步改进，关注：<br><a href="https://blog.csdn.net/zhuanshenai/article/details/49719409" target="_blank" rel="noopener">JIN的签名验证</a>和<br><a href="https://blog.csdn.net/leifengpeng/article/details/52681196" target="_blank" rel="noopener"></a></p>
<p><a href="http://drakeet.me/android-security-guide/" target="_blank" rel="noopener">JNI_OnLoad() 方法对 APK 签名进行验证</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制和种类</title>
    <url>/2017/12/22/binary-classify/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>话回我刚刚毕业来到深圳时，作为一个android菜鸟在一个大神波哥的指导下，学到了很多东西。其中，二进制和分类就是我印象最深的。想按自己理解记录一下。</p>
<p>想一下，有这样的需求：一个物体有一个种类属性，它这个属性有很多相互独立可以相加的值，也就是它有很多种情况，而且一个物体可同时具有其中一个或者多个情况。而我们想用一个数字就表示它的所有情况（这就是数学思维，总把东西抽象化）。</p>
<p>来个具体的，用于表示一个人是否有高血压，高血糖，高血脂这种属性。这个属性可以有各种情况的值，一个人可以只是有高血压、高血糖或者高血脂，也可以有“三高”。那我们如何用一个十进制的值来表示一个人的这个属性的各种情呢？</p>
<p>我们可以让十进制数字的二进制表示的每一位代表一种情况，运用二进制的位运算来表示和判断它的各种情况。<br><a id="more"></a></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>还是上面举的例子。二进制的每一位代表一种情况，三种情况我们可以用二进制的四位表示就可以。其他更多的情况，可以用更多的位来表示。我们约定结果的格式表示为：二进制，十进制。</p>
<blockquote>
<p>高血压： 0001，1    。—表示一个人只有高血压<br>高血糖： 0010，2    。—表示一个人只有高血糖<br>高血脂： 0100，4    。—表示一个人只有高血脂</p>
</blockquote>
<p>那如何表示其他各种情况呢？</p>
<blockquote>
<p>表示一个人有高血压和高血糖：0001 | 0010 = 0011，3<br>表示一个人有高血压和高血脂：0001 | 0100 = 0101，5<br>表示一个人有高血糖和高血脂：0010 | 0100 = 0110，6<br>表示一个人有高血压、高血糖和高血脂： 0001 | 0010 | 0100 = 0111，7</p>
</blockquote>
<p>我们就说，这就是各种情况“相加”。</p>
<p>如果要从多种情况中减除一种或者多种情况，又如何操作呢？<br>比如代表“三高”的7，我们如何从中减除高血压这种情况。</p>
<blockquote>
<p>7 &amp; (~0001) = 0111 &amp; (~0001) = 0111 &amp; 1110 = 0110，6</p>
</blockquote>
<p>说明：自身取“非”是为了不影响原来其他的各种情况，只改变自身那种情况的位。减除多种情况，以此类推。这就是情况的“相减”</p>
<p>如果给我们一个十进制：7，我们又如何知道它表示有多少种情况呢？</p>
<blockquote>
<p>1、是否有高血压 0001？<br>7 &amp; 0001 = 0001 即 0111 &amp; 0001 = 0001<br>2、是否有高血糖？<br>7 &amp; 0010 = 0010 即 0111 &amp; 0010 = 0010<br>3、是否有高血脂？<br>7 &amp; 0100 = 0100 即 0111 &amp; 0100 = 0100</p>
</blockquote>
<p>这实际就是，位的与运算是否等于自身。这就是各种情况的判断方法。</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>读《人类简史》和《未来简史》</title>
    <url>/2017/12/12/about-history/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h3 id="读前提取论点"><a href="#读前提取论点" class="headerlink" title="读前提取论点"></a>读前提取论点</h3><ol>
<li>人类因为自然的一次偶然的基础而出现。智人摆脱了基因的宿命，开始用语言交流，可以说故事了，慢慢产生了各种概念，如神，社会，国家，配偶，金钱等等。</li>
<li>智慧的产生，源于人的反思和内心。</li>
<li>现在人只是生活在自己编造的故事里，正是因为故事才赋予人以意义。</li>
<li>从历史谈到现在，指出万物皆是算法，不同的算法，只是意识的有无和不同。<a id="more"></a></li>
<li>未来很多东西会被人类写的算法所取代，甚至会出现新的人类阶级：无用阶级和超人类。</li>
<li>超人类甚至可以足够强大，是长生的，可以操作万物，记忆不再只存于大脑，甚至可以存在于“云”中。</li>
</ol>
<p>最后，这两本书其实也是正在述说着故事。未完待续。。。</p>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nginx负载均衡nodejs</title>
    <url>/2017/12/06/node-and-nginx/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章适合熟悉nodejs的同学观看。主要是关于如何使用nginx做反向代理和负载均衡nodejs的多个实例的配置流程，nodejs实例可以是分布在同一台主机上或者不同的主机上的多个实例。</p>
<p>主要内容有</p>
<ul>
<li>在同一主机创建nodejs多个实例</li>
<li>详细讲解ngnix.conf文件的每项配置的作用</li>
</ul>
<h3 id="在同一主机创建nodejs多个实例"><a href="#在同一主机创建nodejs多个实例" class="headerlink" title="在同一主机创建nodejs多个实例"></a>在同一主机创建nodejs多个实例</h3><p>我的nodejs环境：</p>
<ul>
<li>window 7 64位</li>
<li>nodejs v8.1.3</li>
<li>webstorm 2017版<a id="more"></a>
</li>
</ul>
<hr>
<p>根目录/server.js文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var timeout = require(&apos;connect-timeout&apos;);</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">var cookieParser = require(&apos;cookie-parser&apos;);</span><br><span class="line">var bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// 设置模板引擎,路径在根目录+public中</span><br><span class="line">app.set(&apos;views&apos;, path.join(__dirname, &apos;public&apos;));</span><br><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;);</span><br><span class="line"></span><br><span class="line">app.use(express.static(&apos;public&apos;));</span><br><span class="line"></span><br><span class="line">app.use(express.static(path.join(__dirname, &apos;public&apos;)));</span><br><span class="line"></span><br><span class="line">// 设置默认超时时间</span><br><span class="line">app.use(timeout(&apos;15s&apos;));</span><br><span class="line">//请求体</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: false &#125;));</span><br><span class="line">//cookie</span><br><span class="line">app.use(cookieParser());</span><br><span class="line">//注册HTTP消息头部信息</span><br><span class="line">app.use(</span><br><span class="line">    function(req, res, next) &#123;</span><br><span class="line">        res.set(</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;Content-Type&apos;: &apos;text/html&apos;,</span><br><span class="line">                &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;,</span><br><span class="line">                &apos;Access-Control-Allow-Rememberme&apos;: true,</span><br><span class="line">                &apos;Access-Control-Allow-HttpOnly&apos;: false,</span><br><span class="line">                &apos;Access-Control-Allow-Methods&apos;: &apos;POST, GET, PUT, DELETE, OPTIONS&apos;,</span><br><span class="line">                &apos;Access-Control-Allow-Credentials&apos;: true, //false,</span><br><span class="line">                &apos;Access-Control-Max-Age&apos;: &apos;86400&apos;, // 24 hours</span><br><span class="line">                &apos;Access-Control-Allow-Headers&apos;: &apos;X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        //decodeURI(req.url)</span><br><span class="line">        console.log(&apos;%s %s&apos;, req.method, req.url);</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//首页</span><br><span class="line">app.get(&apos;/&apos;, function(req, res) &#123;</span><br><span class="line">    res.render(&apos;index1&apos;, &#123; currentTime: new Date() &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">    // 如果任何一个路由都没有返回响应，则抛出一个 404 异常给后续的异常处理器</span><br><span class="line">    if (!res.headersSent) &#123;</span><br><span class="line">        var err = new Error(&apos;Not Found&apos;);</span><br><span class="line">        err.status = 404;</span><br><span class="line">        next(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 错误处理</span><br><span class="line">app.use(function(err, req, res, next) &#123;</span><br><span class="line">    if (req.timedout &amp;&amp; req.headers.upgrade === &apos;websocket&apos;) &#123;</span><br><span class="line">        // 忽略 websocket 的超时</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var statusCode = err.status || 500;</span><br><span class="line">    if (statusCode === 500) &#123;</span><br><span class="line">        console.error(err.stack || err);</span><br><span class="line">    &#125;</span><br><span class="line">    if (req.timedout) &#123;</span><br><span class="line">        console.error(&apos;请求超时: url=%s, timeout=%d, 请确认方法执行耗时很长，或没有正确的 response 回调。&apos;, req.originalUrl, err.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    res.status(statusCode);</span><br><span class="line">    // 默认不输出异常详情</span><br><span class="line">    var error = &#123;&#125;;</span><br><span class="line">    if (app.get(&apos;env&apos;) === &apos;development&apos;) &#123;</span><br><span class="line">        // 如果是开发环境，则将异常堆栈输出到页面，方便开发调试</span><br><span class="line">        error = err;</span><br><span class="line">    &#125;</span><br><span class="line">    res.render(&apos;error&apos;, &#123;</span><br><span class="line">        message: err.message,</span><br><span class="line">        error: error</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function catchGlobalError(err) &#123;</span><br><span class="line">    // 注册全局未捕获异常处理器</span><br><span class="line">    process.on(&apos;uncaughtException&apos;, function(err) &#123;</span><br><span class="line">        console.error(&apos;Caught exception:&apos;, err.stack);</span><br><span class="line">    &#125;);</span><br><span class="line">    process.on(&apos;unhandledRejection&apos;, function(reason, p) &#123;</span><br><span class="line">        console.error(&apos;Unhandled Rejection at: Promise &apos;, p, &apos; reason: &apos;, reason.stack);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建两个服务器实体</span><br><span class="line">var server = require(&apos;http&apos;).createServer(app);</span><br><span class="line">var server1 = require(&apos;http&apos;).createServer(app);</span><br><span class="line"></span><br><span class="line">//服务器监听端口</span><br><span class="line">var PORT = parseInt(process.env.PORT || 3000);</span><br><span class="line">var PORT1 = PORT + 1;</span><br><span class="line"></span><br><span class="line">server.listen(PORT, function (err) &#123;</span><br><span class="line">    console.log(&apos;Node app is running on port:&apos;, PORT);</span><br><span class="line">    catchGlobalError(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server1.listen(PORT1, function (err) &#123;</span><br><span class="line">    console.log(&apos;Node app is running on port:&apos;, PORT1);</span><br><span class="line">    catchGlobalError(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>根目录/views/error.ejs<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Error&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/stylesheets/style.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&lt;%= message %&gt;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;&lt;%= error.status %&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;pre&gt;&lt;%= error.stack %&gt;&lt;/pre&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>根目录/views/index.ejs<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;title&gt;nodejs 和 nginx&lt;/title&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./stylesheets/style.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">      &lt;p&gt;&lt;h3&gt;Hello world&lt;/h3&gt;&lt;/p&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="ngnix配置文件"><a href="#ngnix配置文件" class="headerlink" title="ngnix配置文件"></a>ngnix配置文件</h3><p>nginx.config</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">	</span><br><span class="line">	upstream nodeproxy &#123;</span><br><span class="line">		server 192.168.10.137:3000 weight=10;       </span><br><span class="line">        server 127.0.0.1:3001 weight=12;   </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8089;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">			proxy_pass  http://nodeproxy; #与upstream的名称一致</span><br><span class="line">			proxy_redirect  default; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h3><p>在nginx的安装根目录下，打开命令行工具，运行。</p>
<p>启动nginx：start nginx<br>重新加载配置：nginx -s reload<br>重新打开日志：nginx -s reopen</p>
<p>关闭nginx：<br>快速停止：nginx -s stop<br>有序关闭：nginx -s quit</p>
<p>如果遇到启动不了nginx，可能是监听的端口被占用。<br>使用命令：netstat -aon | findstr :80<br>查询一下</p>
<p>用浏览器访问localhost:8089,我的测试的结果是：</p>
<blockquote>
<p>“D:\WebStorm 2017.2.1\bin\runnerw.exe” D:\nodejs\node.exe D:\collect\leancloud\jiangebuluo\NodeTestDemo\myServer.js<br>Node app is running on port: 3000<br>Node app is running on port: 3001<br>服务器监听的IP: 192.168.10.137<br>服务器监听的IP: 192.168.10.137<br>服务器监听的IP: 127.0.0.1<br>服务器监听的IP: 127.0.0.1<br>服务器监听的IP: 127.0.0.1<br>服务器监听的IP: 127.0.0.1<br>服务器监听的IP: 127.0.0.1<br>服务器监听的IP: 127.0.0.1<br>服务器监听的IP: 192.168.10.137<br>服务器监听的IP: 192.168.10.137</p>
</blockquote>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>另外贴出一个ubuntu的详细配置讲解。来自<a href="https://www.cnblogs.com/hunttown/p/5759959.html" target="_blank" rel="noopener">猎手家园</a>的博客<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="line">worker_processes 8;</span><br><span class="line"> </span><br><span class="line">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log /usr/local/nginx/logs/error.log info;</span><br><span class="line"></span><br><span class="line">#进程pid文件</span><br><span class="line">pid /usr/local/nginx/logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">#指定进程可以打开的最大描述符：数目</span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><br><span class="line">#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span><br><span class="line">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span><br><span class="line">    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    #补充说明：</span><br><span class="line">    #与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><br><span class="line">    #A）标准事件模型</span><br><span class="line">    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><br><span class="line">    #B）高效事件模型</span><br><span class="line">    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><br><span class="line">    #Epoll：使用于Linux内核2.6版本及以后的系统。</span><br><span class="line">    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><br><span class="line">    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><br><span class="line">    use epoll;</span><br><span class="line"></span><br><span class="line">    #单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span><br><span class="line">    worker_connections 65535;</span><br><span class="line"></span><br><span class="line">    #keepalive超时时间。</span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line"></span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span><br><span class="line">    #分页大小可以用命令getconf PAGESIZE 取得。</span><br><span class="line">    #[root@web001 ~]# getconf PAGESIZE</span><br><span class="line">    #4096</span><br><span class="line">    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">    open_file_cache max=65535 inactive=60s;</span><br><span class="line"></span><br><span class="line">    #这个是指多长时间检查一次缓存的有效信息。</span><br><span class="line">    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span><br><span class="line">    open_file_cache_valid 80s;</span><br><span class="line"></span><br><span class="line">    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><br><span class="line">    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span><br><span class="line">    open_file_cache_min_uses 1;</span><br><span class="line">    </span><br><span class="line">    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span><br><span class="line">    open_file_cache_errors on;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include mime.types;</span><br><span class="line"></span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #默认编码</span><br><span class="line">    #charset utf-8;</span><br><span class="line"></span><br><span class="line">    #服务器名字的hash表大小</span><br><span class="line">    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line"></span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line">    client_header_buffer_size 32k;</span><br><span class="line"></span><br><span class="line">    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><br><span class="line">    large_client_header_buffers 4 64k;</span><br><span class="line"></span><br><span class="line">    #设定通过nginx上传文件的大小</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line"></span><br><span class="line">    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><br><span class="line">    sendfile on;</span><br><span class="line"></span><br><span class="line">    #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    autoindex on;</span><br><span class="line"></span><br><span class="line">    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">     </span><br><span class="line">    tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">    #长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout 120;</span><br><span class="line"></span><br><span class="line">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #gzip模块设置</span><br><span class="line">    gzip on; #开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k;    #最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k;    #压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2;    #压缩等级</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    #开启限制IP连接数的时候需要使用</span><br><span class="line">    #limit_zone crawler $binary_remote_addr 10m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #负载均衡配置</span><br><span class="line">    upstream piao.jd.com &#123;</span><br><span class="line">     </span><br><span class="line">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 127.0.0.1:3000 weight=3;</span><br><span class="line">        server 127.0.0.1:3001 weight=2;</span><br><span class="line"></span><br><span class="line">        #nginx的upstream目前支持4种方式的分配</span><br><span class="line">        #1、轮询（默认）</span><br><span class="line">        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br><span class="line">        #2、weight</span><br><span class="line">        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    server 192.168.0.14 weight=10;</span><br><span class="line">        #    server 192.168.0.15 weight=10;</span><br><span class="line">        #&#125;</span><br><span class="line">        #2、ip_hash</span><br><span class="line">        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 192.168.0.14:88;</span><br><span class="line">        #    server 192.168.0.15:80;</span><br><span class="line">        #&#125;</span><br><span class="line">        #3、fair（第三方）</span><br><span class="line">        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server server1;</span><br><span class="line">        #    server server2;</span><br><span class="line">        #    fair;</span><br><span class="line">        #&#125;</span><br><span class="line">        #4、url_hash（第三方）</span><br><span class="line">        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br><span class="line">        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server squid1:3128;</span><br><span class="line">        #    server squid2:3128;</span><br><span class="line">        #    hash $request_uri;</span><br><span class="line">        #    hash_method crc32;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        #tips:</span><br><span class="line">        #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 127.0.0.1:9090 down;</span><br><span class="line">        #    server 127.0.0.1:8080 weight=2;</span><br><span class="line">        #    server 127.0.0.1:6060;</span><br><span class="line">        #    server 127.0.0.1:7070 backup;</span><br><span class="line">        #&#125;</span><br><span class="line">        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span><br><span class="line"></span><br><span class="line">        #每个设备的状态设置为:</span><br><span class="line">        #1.down表示单前的server暂时不参与负载</span><br><span class="line">        #2.weight为weight越大，负载的权重就越大。</span><br><span class="line">        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br><span class="line">        #4.fail_timeout:max_fails次失败后，暂停的时间。</span><br><span class="line">        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line"></span><br><span class="line">        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br><span class="line">        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><br><span class="line">        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><br><span class="line">        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name www.jd.com jd.com;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        root /data/www/jd;</span><br><span class="line"></span><br><span class="line">        #对******进行负载均衡</span><br><span class="line">        location ~ .*.(php|php5)?$</span><br><span class="line">        &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #图片缓存时间设置</span><br><span class="line">        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #日志格式设定</span><br><span class="line">        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br><span class="line">        #$remote_user：用来记录客户端用户名称；</span><br><span class="line">        #$time_local： 用来记录访问时间与时区；</span><br><span class="line">        #$request： 用来记录请求的url与http协议；</span><br><span class="line">        #$status： 用来记录请求状态；成功是200，</span><br><span class="line">        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br><span class="line">        #$http_referer：用来记录从那个页面链接访问过来的；</span><br><span class="line">        #$http_user_agent：记录客户浏览器的相关信息；</span><br><span class="line">        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br><span class="line">        log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">        &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">        &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class="line">         </span><br><span class="line">        #定义本虚拟主机的访问日志</span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.log  main;</span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.404.log  log404;</span><br><span class="line">         </span><br><span class="line">        #对 &quot;/&quot; 启用反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             </span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             </span><br><span class="line">            #以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">            #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">            #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br><span class="line">            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br><span class="line">            client_body_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">            #表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br><span class="line">            proxy_intercept_errors on;</span><br><span class="line"></span><br><span class="line">            #后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class="line">            #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_connect_timeout 90;</span><br><span class="line"></span><br><span class="line">            #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br><span class="line">            proxy_send_timeout 90;</span><br><span class="line"></span><br><span class="line">            #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br><span class="line">            proxy_read_timeout 90;</span><br><span class="line"></span><br><span class="line">            #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br><span class="line">            proxy_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">            #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br><span class="line">            proxy_buffers 4 32k;</span><br><span class="line"></span><br><span class="line">            #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_busy_buffers_size 64k;</span><br><span class="line"></span><br><span class="line">            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br><span class="line">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log on;</span><br><span class="line">            auth_basic &quot;NginxStatus&quot;;</span><br><span class="line">            auth_basic_user_file confpasswd;</span><br><span class="line">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #本地动静分离反向代理配置</span><br><span class="line">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class="line">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br><span class="line">        pdf|xls|mp3|wma)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 15d; </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个tensorflow程序</title>
    <url>/2017/11/24/%E7%AC%AC%E4%B8%80%E4%B8%AAtensorflow%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://lc-2YPqqc43.cn-n1.lcfile.com/e3bf55baadbd565a3423/tensorflow.webp" alt="图片"><br>最近AlphaGo和AlphaZero的出现，预示着2017年成为人工智能元年，人工智能逐渐进入我们的生活和工作的方方面面，如在工作中，阿里巴巴双十一中，出现了“千人千面”智能推荐系统，鲁班AI设计师，小蜜机器人，IDC智能巡检机器人，还有京东的无人仓库等。这些都让我觉得人工智能越来越重要和越来越感兴趣，所以决定学习python和tensorflow。现在就以一个使用tensorflow构建一元线性模型开始我的人工智能学习吧。<br><a id="more"></a></p>
<p>人工智能，机器学习，深度学习关系</p>
<p>人工智能是计算机学科的一个分支，诞生于1956年。机器学习是人工智能的范畴，它包含了深度学习。深度是指多层的意思，模型经过多层的神经网络的训练，不断的学习和调整模型的参数，最后得到最优损失函数最小的模型。深度学习能够有效的处理现实生活中的“非线性”问题。tensorflow是目前最受欢迎的深度学习框架。</p>
<p>几个tensorflow的关键词语，张量，流，计算图。更多的建议阅读：《Tensorflow实战》</p>
<p>下面直接上最简单的一元线性回归模型代码：<br>电脑环境：</p>
<ul>
<li>python版本：3.6.3.</li>
<li>tensorflow版本：cpu版，1.3</li>
<li>window 7 64位</li>
<li>IDE：PyCharm</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">session = tf.Session()</span><br><span class="line"># X轴参数</span><br><span class="line">w = tf.Variable([.3], dtype=tf.float32)</span><br><span class="line"># 偏移量</span><br><span class="line">b = tf.Variable([-.3], dtype=tf.float32)</span><br><span class="line"># x轴</span><br><span class="line">x = tf.placeholder(tf.float32)</span><br><span class="line"># 一元线性模型</span><br><span class="line">linear_model = w * x + b</span><br><span class="line"># 实际值</span><br><span class="line">y = tf.placeholder(tf.float32)</span><br><span class="line"># 观测值和实际值的误差的平方差</span><br><span class="line">squared_deltas = tf.square(linear_model - y)</span><br><span class="line"># 最少二乘法。损失函数</span><br><span class="line">loss = tf.reduce_sum(squared_deltas)</span><br><span class="line"># 优化器.优化函数</span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(0.01)</span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"># 初始化所有的变量</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">session.run(init)</span><br><span class="line"># 开始训练。训练的过程就是结合优化函数使损失函数的损失最少</span><br><span class="line">x_train = [1,2,3,4]</span><br><span class="line">y_train = [0, -1,-2,-3]</span><br><span class="line">for i in range(1000):</span><br><span class="line">    session.run(train, &#123;x: x_train, y: y_train&#125;)</span><br><span class="line"># 训练的结果</span><br><span class="line">curr_W, curr_b, curr_loss = session.run([w, b, loss], &#123;x: x_train, y: y_train&#125;)</span><br><span class="line">print(&quot;W: %s b: %s loss: %s&quot;%(curr_W, curr_b, curr_loss))</span><br></pre></td></tr></table></figure>
<p>模型输出结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W: [-0.9999969] b: [ 0.99999082] loss: 5.69997e-11</span><br></pre></td></tr></table></figure></p>
<p>公式表示是：$Y=-0.9999969X + 0.99999082$, 损失为：5.69997e-11</p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2017/11/24/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我想了许久，我建立个人博客网站，第一篇文章应该写什么呢？<br>自从毕业以来，我很久没有写过记录的文章了，加上自己的写作能力，呵呵<br>我是一个在空闲时，总是善于回忆的人。所以我决定将一首高三时对我有深刻影响的词作为博客的第一篇文章。<br><a id="more"></a></p>
<p>这首词，在我高三最迷茫自暴自弃的时候，让我重新找到努力的力量，我还可以忘记以前的一切，可以重新开始。无论你之前是如何的失败和消沉，如果你有不计自己的损失，还可以让你的心和脑再次专注，只要坚持挺住，那结果必有回响。</p>
<blockquote>
</blockquote>
<p>如果你能倾毕生心血,<br>去冒险进行孤注一掷.<br>失败后一切从头再来,<br>而绝口不提你的损失.<br>如果你曾经消沉许多,<br>还能使你的心脑重又专注.<br>坚持哪怕你一无所有,<br>惟剩一种意志在命令,挺住!</p>
<p>此词<br>    与大家共勉</p>
<div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"></div>
		<script>
			var ap = new APlayer({
				element: document.getElementById("aplayer0"),
				narrow: false,
				autoplay: false,
				showlrc: 0,
				music: {
					title: "够钟",
					author: "周柏豪",
					url: "http://o8bym0zmt.bkt.clouddn.com/%E5%91%A8%E6%9F%8F%E8%B1%AA%20-%20%E5%A4%9F%E9%92%9F.mp3",
					pic: "",
				}
			});
			window.aplayers || (window.aplayers = []);
			window.aplayers.push(ap);
		</script>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
