{"meta":{"title":"长孙雨聪--七星上将","subtitle":"相信现在是因为相信未来","description":"广西科技大学，Android工程师一枚。","author":"长孙雨聪--七星上将","url":"http://zhangsunyucong.top","root":"/"},"pages":[{"title":"关于","date":"2017-12-04T06:43:27.000Z","updated":"2023-03-05T03:03:31.490Z","comments":false,"path":"about/index.html","permalink":"http://zhangsunyucong.top/about/index.html","excerpt":"","text":"个人简介 网名：zhangsunyucong 学历：全日制本科 专业：数学与应用数学 职位：Android开发工程师， Reac Native开发 所在地：深圳南山区科技园 技术背景 android，Reac Native开发，nodejs后台开发，Flutter"},{"title":"音乐","date":"2017-12-15T09:55:49.000Z","updated":"2023-03-04T15:21:14.544Z","comments":true,"path":"music/index.html","permalink":"http://zhangsunyucong.top/music/index.html","excerpt":"","text":"var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"够钟\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/64239c308b9dd1cb1432.jpg\",\"author\":\"周柏豪\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/f105e0c99854679f7604.mp3\"},{\"title\":\"宏愿\",\"author\":\"周柏豪\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/64239c308b9dd1cb1432.jpg\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/824cc268ae2ffd81210d.mp3\"},{\"title\":\"自由意志\",\"author\":\"周柏豪\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/64239c308b9dd1cb1432.jpg\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/40eecd3c150c53ab7dd3.mp3\"},{\"title\":\"Beautiful In White\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/550c430a6fa549cf073f.jpg\",\"author\":\"Westlife\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/ac76e098324ab7272347.mp3\"},{\"title\":\"456Wing\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/4a62ddb66cd46d79a164.jpg\",\"author\":\"农夫\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/c32169860760ad96d783.mp3\"},{\"title\":\"伟大航道 (Live)\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/4a62ddb66cd46d79a164.jpg\",\"author\":\"C 君\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/3ce9ca19080d7ec22fdc.mp3\"},{\"title\":\"揿钱\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/4a62ddb66cd46d79a164.jpg\",\"author\":\"农夫\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/4a7ecdb8dc337e8cad96.mp3\"},{\"title\":\"24\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/4a62ddb66cd46d79a164.jpg\",\"author\":\"农夫\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/a35a3eaf43668ee3b20c.mp3\"},{\"title\":\"话太普通\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/4a62ddb66cd46d79a164.jpg\",\"author\":\"农夫\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/9fe348edf9584fb64a88.mp3\"},{\"title\":\"P.S. I Love You\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/0db75ef59dcdcf7907fb.jpg\",\"author\":\"Supper Moment\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/9ceabc0202cf6849b2c1.mp3\"},{\"title\":\"一生爱你一个 (Live)\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/64239c308b9dd1cb1432.jpg\",\"author\":\"周柏豪\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/cbfa9aacfb793b2a41fa.mp3\"},{\"title\":\"一生爱你一个\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/77e8a25b671b73ff2987.jpg\",\"author\":\"郑伊健\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/91ddb47b3966a3baccd8.mp3\"},{\"title\":\"陈展鹏 - 差半步（TVB 电视剧《单恋双城》插曲）\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/8d923f263ea32d621d1c.jpg\",\"author\":\"陈展鹏\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/0126b59ff1b1b8574f03.mp3\"},{\"title\":\"慢慢喜欢你\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/77e8a25b671b73ff2987.jpg\",\"author\":\"赵家豪\",\"url\":\"http://www.ytmp3.cn/down/51159.mp3\"},{\"title\":\"写你太难\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/f5a42e4c229056693404.jpg\",\"author\":\"陈咏谦\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/d8be801d518c3e8af2f7.mp3\"},{\"title\":\"裂痕\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/f5a42e4c229056693404.jpg\",\"author\":\"陈咏谦\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/ba78376be860baeffa4f.mp3\"},{\"title\":\"哪里只得你共我\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/fcfe0c0c5005ae531c77.jpg\",\"author\":\"Dear Jane\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/88e487aa3853ae191a73.mp3\"},{\"title\":\"子华说\",\"pic\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/899a7f31fb6414efc256.jpg\",\"author\":\"古巨基\",\"url\":\"http://lc-2YPqqc43.cn-n1.lcfile.com/f7e4c4e74763310bda95.mp3\"}]}; options.element = document.getElementById(\"aplayer-iBIiAZhA\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"标签","date":"2023-03-04T13:23:02.858Z","updated":"2020-02-22T09:42:54.000Z","comments":false,"path":"tags/index.html","permalink":"http://zhangsunyucong.top/tags/index.html","excerpt":"","text":""},{"title":"简历","date":"2018-01-23T06:51:58.000Z","updated":"2020-02-22T09:42:54.000Z","comments":false,"path":"rusume/index.html","permalink":"http://zhangsunyucong.top/rusume/index.html","excerpt":"","text":"个人简历点击我的简历查看。在电脑浏览器点击，会直接打开。在手机上点击，会先下载后自己打开。"}],"posts":[{"title":"Flutter——Row, Column布局实例详解","slug":"flutter-layout","date":"2020-03-15T07:21:32.000Z","updated":"2023-03-04T15:14:51.412Z","comments":true,"path":"2020/03/15/flutter-layout/","link":"","permalink":"http://zhangsunyucong.top/2020/03/15/flutter-layout/","excerpt":"开篇Row 和 Column 分别是 Flutter 中的水平和垂直布局，它们都是 MultiChildRenderObjectWidget，所以它们都是可以渲染多个孩子的控件，而它们是如何渲染孩子的大小和位置的则是有 renderObject 定义的。它们的继承关系图如下：","text":"开篇Row 和 Column 分别是 Flutter 中的水平和垂直布局，它们都是 MultiChildRenderObjectWidget，所以它们都是可以渲染多个孩子的控件，而它们是如何渲染孩子的大小和位置的则是有 renderObject 定义的。它们的继承关系图如下： MainAxisAlignment 和 CrossAxisAlignmentRow、Column 的布局特性和 MainAxisAlignment（主轴）和 CrossAxisAlignment（交叉轴）有关。主轴是与当前控件方向一致的轴，而交叉轴就是与当前控件方向垂直方向的轴。主轴和交叉轴是相对于的，它们主要用于控制 Row，Column 的子控件排列位置。因此，在 Row 中，MainAxisAlignment 的方向是水平的，默认的起始位置在左边，排列方向是从左至右；而 CrossAxisAlignment 的方向则是垂直的，默认的起始位置在中间，排列方向是从上到下。相对的，在 Column 中，MainAxisAlignment 的方向是垂直的，默认起始位置在上边，排列方向是从上至下；CrossAxisAlignment 的方向则是水平的，默认的起始位置在中间，排列方向是从左到右。另外，textDirection 和 verticalDirection 可以分别改变水平和垂直方向的起始位置和排列方向。 MainAxisAlignment 的值： enum MainAxisAlignment {//将子控件放在主轴的开始位置start, //将子控件放在主轴的结束位置end,//将子控件放在主轴的中间位置center,//将主轴空白位置进行均分，排列子元素，手尾没有空隙spaceBetween,//将主轴空白区域均分，使中间各个子控件间距相等，首尾子控件间距为中间子控件间距的一半spaceAround,//将主轴空白区域均分，使各个子控件间距相等spaceEvenly,} CrossAxisAlignment 取值： enum CrossAxisAlignment {//将子控件放在交叉轴的起始位置start,//将子控件放在交叉轴的结束位置end,//将子控件放在交叉轴的中间位置center,//使子控件填满交叉轴stretch,//将子控件放在交叉轴的上，并且与基线相匹配（不常用）baseline,} textDirection 取值： enum TextDirection {//从右到左排列rtl,//从左到右排列ltr,} VerticalDirection 取值 enum VerticalDirection {//从上到下up,//从下到上down,} 定义控件 Box为了实例说明的方便，这里专门封装一个 box 控件来说明 Row 和 Column 布局特性。 1234567891011121314151617181920212223242526272829303132class Box extends StatelessWidget &#123; String index; double boxSize = 100.0; Box(String index) &#123; this.index = index; &#125; @override Widget build(BuildContext context) &#123; return Container( width: boxSize, height: boxSize, alignment: Alignment.center, decoration: BoxDecoration( gradient: LinearGradient( colors: [Colors.orangeAccent, Colors.orange, Colors.deepOrange] ) ), child: Text( index, style: TextStyle( color: Colors.white, fontSize: 20, fontWeight: FontWeight.bold ), ), ); &#125;&#125; Row（1）Row 的默认情况123456789101112131415161718192021222324class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 200.0, child: Row( children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; 可以看出来，Row 的默认起始位置在左边，排列方向是从左到右。也就是: mainAxisAlignment: MainAxisAlignment.start,crossAxisAlignment: CrossAxisAlignment.center,textDirection: TextDirection.ltr,verticalDirection: VerticalDirection.down, 12345678910111213141516171819202122232425262728class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 200.0, child: Row( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; （2）使用 textDirection 和 verticalDirection 将默认值取全反为了看出 verticalDirection: VerticalDirection.up 的效果，故意把 crossAxisAlignment 设置为了 CrossAxisAlignment.start 12345678910111213141516171819202122232425262728class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 200.0, child: Row( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, textDirection: TextDirection.rtl, verticalDirection: VerticalDirection.up, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; （3）使用 verticalDirection 只改变垂直方向的默认位置和排列方向12345678910111213141516171819202122232425262728class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 200.0, child: Row( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.up, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; （4）使用 textDirection 只改变水平方向的默认位置和排列方向12345678910111213141516171819202122232425262728class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 200.0, child: Row( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, textDirection: TextDirection.rtl, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; （5）居中12345678910111213141516171819202122232425262728class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 200.0, child: Row( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; 12345678910111213141516171819202122232425262728class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 200.0, child: Row( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, textDirection: TextDirection.rtl, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; （6）填满交叉轴12345678910111213141516171819202122232425262728class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 200.0, child: Row( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.stretch, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; Column（1）Column 的默认情况12345678910111213141516171819202122232425class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 600.0, width: 400.0, child: Column( children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; 也就是 Column 的默认情况是： mainAxisAlignment: MainAxisAlignment.start,crossAxisAlignment: CrossAxisAlignment.center,textDirection: TextDirection.ltr,verticalDirection: VerticalDirection.down, 1234567891011121314151617181920212223242526272829class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 600.0, width: 400.0, child: Column( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; (2)使用 textDirection 和 verticalDirection 将默认值改为全反1234567891011121314151617181920212223242526272829class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 600.0, width: 400.0, child: Column( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, textDirection: TextDirection.rtl, verticalDirection: VerticalDirection.up, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; （3）使用 verticalDirection 只改变垂直方向的默认位置和排列方向1234567891011121314151617181920212223242526272829class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 600.0, width: 400.0, child: Column( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.up, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; （4）使用 textDirection 只改变水平方向的默认位置和排列方向1234567891011121314151617181920212223242526272829class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 600.0, width: 400.0, child: Column( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, textDirection: TextDirection.rtl, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; (5)居中1234567891011121314151617181920212223242526272829class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 600.0, width: 400.0, child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; 1234567891011121314151617181920212223242526272829class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 600.0, width: 400.0, child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.up, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125; (6)填满交叉轴1234567891011121314151617181920212223242526272829class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Container( color: Colors.green, height: 600.0, width: 400.0, child: Column( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.stretch, textDirection: TextDirection.ltr, verticalDirection: VerticalDirection.down, children: &lt;Widget&gt;[ Box(&quot;1&quot;), Box(&quot;2&quot;), Box(&quot;3&quot;), Box(&quot;4&quot;) ], ), ), ); &#125;&#125;","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://zhangsunyucong.top/tags/Flutter/"}]},{"title":"从矩阵来看颜色变换","slug":"android-color-matrix","date":"2018-04-18T08:49:03.000Z","updated":"2020-02-22T12:07:56.000Z","comments":true,"path":"2018/04/18/android-color-matrix/","link":"","permalink":"http://zhangsunyucong.top/2018/04/18/android-color-matrix/","excerpt":"开篇之前从矩阵的角度分析了平移，旋转，缩放，对称的变换，文章在从矩阵来看Android中的一些动画变换。 在android中，图片的对象主要是bitmap，它是由点阵和颜色值组成的。1、点阵是一个图片宽*图片高的矩阵，矩阵中的每一个元素对应着图片的一个像素。根据点阵可以计算出图片占用的内存大小。","text":"开篇之前从矩阵的角度分析了平移，旋转，缩放，对称的变换，文章在从矩阵来看Android中的一些动画变换。 在android中，图片的对象主要是bitmap，它是由点阵和颜色值组成的。1、点阵是一个图片宽*图片高的矩阵，矩阵中的每一个元素对应着图片的一个像素。根据点阵可以计算出图片占用的内存大小。 1234ALPHA_8： 每个像素占用1byte内存ARGB_4444: 每个像素占用2byte内存ARGB_8888: 每个像素占用4byte内存RGB_565: 每个像素占用2byte内存 123456图片占用内存 = 图片高度显示像素 * 图片宽度显示像素 * 每个像素占用的内存大小显示像素 = 图片实际像素 * 手机density / 图片density 假设有一张长宽为800*600、通道为ARGB_8888的图片，那么它占的内存为：800*600*4byte = 1875KB = 1.83M 2、颜色值，是由三原色和透明度决定的，即ARGB，分别对应着四个颜色通道，每个通道用8byte定义，所以一个颜色值就是一个int整型，可以表示256x256x256种颜色值。 在android中和颜色有关的几个常量：ARGB_8888、ARGB_4444、RGB_565。ARGB_8888，是图片的透明度、R、G、B的每个颜色值占8bit，可以表示256x256x256种颜色，也就是可以表示最多的颜色值，图片质量也是最好的。 ARGB_4444，是图片的透明度、R、G、B的每个颜色值占4bit，可以表示16x16x16种颜色，相对ARGB_8888，它节省了空间，却失去了很多色彩。 RGB_565，它只有R、G、B三个颜色通道，没有透明度通道，可以表达32x64x32种颜色。 四个颜色通道是由一个4x5的变换矩阵控制的。 颜色矩阵变换 所以，可以知道，红色通道由第一行控制。绿色通道由第二行控制。蓝色通道由第三行控制。透明度通道由第四行控制。另外的，第五列是每个通道的偏移量。注意倍数和相加的影响，每个通道最后的值不应该大于256. 在android中，有一个和颜色矩阵相关的android.graphics.Matrix类，该类中有与颜色变换相关的方法。 关于Matrix方法的使用这里就不详细讲了。 实例： 12345678910111213141516171819public static Bitmap testBitmap(Bitmap bitmap)&#123; Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Config.RGB_565); Canvas canvas = new Canvas(output); Paint paint = new Paint(); ColorMatrix cm = new ColorMatrix(); float[] array = &#123;1,0,0,0,100, 0,1,0,0,100, 0,0,1,0,0, 0,0,0,1,0&#125;; cm.set(array); paint.setColorFilter(new ColorMatrixColorFilter(cm)); canvas.drawBitmap(bitmap, 0, 0, paint); return output; &#125; JNI图片压缩在上面提到过一张图片占用多大内存的计算，现在我们的手机拍出来的照片占的内存越来越大，所以在开发的过程中，我们就很有必要对图片压缩后再上传。而比较好的压缩方法是JNI压缩。 github地址","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"23种设计模式之结构型设计模式","slug":"java-pattern-structure","date":"2018-04-10T03:00:35.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2018/04/10/java-pattern-structure/","link":"","permalink":"http://zhangsunyucong.top/2018/04/10/java-pattern-structure/","excerpt":"前言本篇文章主要讲23种设计模式中的7种结构型设计模式，包括适配器模式，装饰者模式，代理模式，外观模式，桥接模式，组合模式，享元模式。 适配器模式适配器模式是将一个类的方法接口转换成客户端期望的接口表示。我们可以约定，把客户端期望的接口叫做目标Targetable，被转换的类叫source。适配器模式可以分为：类的适配器模式，对象的适配器，接口的适配器。","text":"前言本篇文章主要讲23种设计模式中的7种结构型设计模式，包括适配器模式，装饰者模式，代理模式，外观模式，桥接模式，组合模式，享元模式。 适配器模式适配器模式是将一个类的方法接口转换成客户端期望的接口表示。我们可以约定，把客户端期望的接口叫做目标Targetable，被转换的类叫source。适配器模式可以分为：类的适配器模式，对象的适配器，接口的适配器。 类的适配器模式已有的被转换的类： 1234567public class SourceClass &#123; public void method1() &#123; System.out.print(&quot;Hi, I am a method in sourceClass&quot;); &#125;&#125; 期望的目标： 1234public interface Targetable &#123; void method1(); void method2();&#125; 实现目标，进行适配 1234567public class AdapterClass extends SourceClass implements Targetable &#123; @Override public void method2() &#123; System.out.print(&quot;Hi All, I am a method in adapterClass&quot;); &#125;&#125; 这样子就将SourceClass按照意愿Targetable适配转换成了AdapterClass，AdapterClass具有了SourceClass的所有的功能，同时也达到了扩展SourceClass。由于类的适配器模式是通过继承实现的，它具有了继承的优缺点。关于缺点，比如通过AdapterClass对象可以调用属于SourceClass而在Targetable接口中没有的方法。 对象的适配器模式对象的适配器模式，就是将原来类的对象转换为目标接口的对象。对象适配器模式没有继承被转换类，而是持有被转换类的对象。这可以避免继承被带来的副作用。 123456789101112131415161718public class AdapterObjectClass implements Targetable&#123; private SourceClass mSourceClass; public AdapterObjectClass(SourceClass mSourceClass) &#123; this.mSourceClass = mSourceClass; &#125; @Override public void method2() &#123; System.out.print(&quot;hi all, i am a method in AdapterObjectClass&quot;); &#125; @Override public void method1() &#123; mSourceClass.method1(); &#125;&#125; 接口的适配器模式当一个接口有很多的抽象方法时，当我们写这个接口的实现类，必须实现该接口的全部方法。而有时候接口中并不是所有的抽象方法都是我们必须的，而我们只需要实现其中的某一些方法。为了解决这个问题，我们可以使用接口的适配器模式，引入一个抽象类，这个抽象类提供了接口所有抽象方法的空实现。我们可以继承这个抽象类，并只重写我们需要的方法即可。 比如，在上面我们只要Targetable的method2方法。 123456789101112public abstract class AdapterInterfaceClass implements Targetable&#123; @Override public void method1() &#123; &#125; @Override public void method2() &#123; &#125;&#125; 1234567public class AdapterWraper extends AdapterInterfaceClass &#123; @Override public void method1() &#123; System.out.print(&quot;hi all, I am a method in AdapterWraper class&quot;); &#125;&#125; 装饰者模式装饰者模式的核心思想是，装饰者和被装饰者实现同一个接口，将被装饰者注入装饰者中，可以在装饰者中扩展被装饰者。 123public interface Person &#123; void eat();&#125; 被装饰者： 1234567public class Man implements Person &#123; @Override public void eat() &#123; System.out.print(&quot;There is a man who is eating&quot;); &#125;&#125; 装饰者： 12345678910111213141516171819public class ManDecorator implements Person &#123; private Person mPerson; public ManDecorator(Person person) &#123; mPerson = person; &#125; @Override public void eat() &#123; mPerson.eat(); drinkWater(); System.out.print(&quot;I finish my lunch&quot;); &#125; private void drinkWater() &#123; System.out.print(&quot;Man is drinking water&quot;); &#125;&#125; 使用： 123Man man = new Man();ManDecorator manDecorator = new ManDecorator(man);manDecorator.eat(); 输出的结果： 123There is a man who is eatingMan is drinking waterI finish my lunch 代理模式注意区别代理模式和动态代理。 生活中代理的例子。比如如果你要租房子，你可能不知道该地区的房子信息，这时你可以找一个熟悉的人来帮忙，这个帮你的人就是代理；又比如，打官司时，我们可能并不精通法律知识，这时我们可以找一个代理律师来帮我们。等等。。对于，代理的工作可以抽象为一个接口。 123public interface WorkInterface &#123; void rentHouse();&#125; 一个房东： 1234567public class LandLady implements WorkInterface &#123; @Override public void rentHouse() &#123; System.out.print(&quot;您好！我是房东。我这里有房子出租！&quot;); &#125;&#125; 代理房东的代理类： 12345678910111213public class Proxy implements WorkInterface &#123; private LandLady mLandLady; public Proxy() &#123; mLandLady = new LandLady(); &#125; @Override public void rentHouse() &#123; mLandLady.rentHouse(); &#125;&#125; 租客去找代理租房子： 12WorkInterface proxy = new Proxy();proxy.rentHouse(); 外观模式在医院里的前台接待员就是一个外观模式的体现。由于病人来到医院可能对医院内部和流程并不熟悉，那么可以由熟悉这些的接待员来帮病人来完成这些事情。 部门1 123456789public class ModuleA &#123; //提供给外部调用的方法 public void a1() &#123;&#125; //内部完成工作的实现 private void a2() &#123;&#125; private void a3() &#123;&#125;&#125; 部门2 123456789public class ModuleB &#123; //提供给外部调用的方法 public void b1() &#123;&#125; //内部完成工作的实现 private void b2() &#123;&#125; private void b3() &#123;&#125;&#125; 部门3 123456789public class ModuleC &#123; //提供给外部调用的方法 public void c1() &#123;&#125; //内部完成工作的实现 private void c2() &#123;&#125; private void c3() &#123;&#125;&#125; 外观类: 12345678910111213141516171819public class ModuleFacade &#123; private ModuleA mModuleA = new ModuleA(); private ModuleB mMBModuleB = new ModuleB(); private ModuleC mMCModuleC = new ModuleC(); public void a1() &#123; mModuleA.a1(); &#125; public void b1() &#123; mMBModuleB.b1(); &#125; public void c1() &#123; mMCModuleC.c1(); &#125;&#125; 当我们需要ModuleA，ModuleB， ModuleC的功能时，我们并不直接和他们打交道，也不需要了解部门的功能是如何实现的，而我们只需要去找外观类沟通即可。 外观模式的关键点是整合。 桥接模式桥接模式，提供一个解耦或者连接抽象化和实现化的一个桥梁，使得二者可以独立变化。 一个接口作为桥，一个抽象类持有桥。桥和抽象类两者可以独立变化。 桥： 123public interface Qiao &#123; void toArea();&#125; 抽象类： 1234public abstract class FromArea &#123; public Qiao qiao; abstract public void fromArea();&#125; QiaoC.java 1234567public class QiaoC implements Qiao &#123; @Override public void toArea() &#123; System.out.print(&quot;I want to go Area C&quot;); &#125;&#125; QiaoD.java 1234567public class QiaoD implements Qiao &#123; @Override public void toArea() &#123; System.out.print(&quot;I want to go Area D&quot;); &#125;&#125; FromAreaA.java 1234567public class FromAreaA extends FromArea &#123; @Override public void fromArea() &#123; System.out.print(&quot;I come from area A&quot;); &#125;&#125; FromAreaB.java 1234567public class FromAreaB extends FromArea &#123; @Override public void fromArea() &#123; System.out.print(&quot;I come from area B&quot;); &#125;&#125; 使用： 123456789101112FromAreaA fromAreaA = new FromAreaA();QiaoC qiaoC = new QiaoC();fromAreaA.qiao = qiaoC;fromAreaA.fromArea();fromAreaA.qiao.toArea();QiaoD qiaoD = new QiaoD();fromAreaA.qiao = qiaoD;fromAreaA.fromArea();fromAreaA.qiao.toArea(); 从上面可以看出，Qiao和FromArea两者是独立变化的，它们的抽象和实现是分离的。 如果有更多的Qiao和FromArea的实现，只要扩展它们即可。 组合模式组合模式，又叫“整体-部分设计模式”。它一般用于实现树形结构。 节点 123456789101112131415161718192021222324252627282930313233343536373839public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;&gt;(); public TreeNode(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; public TreeNode getParent() &#123; return parent; &#125; public void addChild(TreeNode child) &#123; children.add(child); &#125; public boolean removeChild(TreeNode child) &#123; return children.remove(child); &#125; public Enumeration&lt;TreeNode&gt; getChildren() &#123; return children.elements(); &#125;&#125; 整体，建立一棵树： 1234567891011121314151617public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree(&quot;A&quot;); TreeNode nodeB = new TreeNode(&quot;B&quot;); TreeNode nodeC = new TreeNode(&quot;C&quot;); nodeB.addChild(nodeC); tree.root.addChild(nodeB); System.out.println(&quot;build the tree finished!&quot;); &#125;&#125; 享元模式享元模式主要是实现对象的共享。联想数据库的连接池。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ConnectionPool &#123; private Vector&lt;Connection&gt; pool; /*公有属性*/ private String url = &quot;jdbc:mysql://localhost:3306/test&quot;; private String username = &quot;root&quot;; private String password = &quot;root&quot;; private String driverClassName = &quot;com.mysql.jdbc.Driver&quot;; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法，做一些初始化工作*/ private ConnectionPool() &#123; pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) &#123; try &#123; Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* 返回连接到连接池 */ public synchronized void release() &#123; pool.add(conn); &#125; /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() &#123; if (pool.size() &gt; 0) &#123; Connection conn = pool.get(0); pool.remove(conn); return conn; &#125; else &#123; return null; &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://zhangsunyucong.top/tags/java/"}]},{"title":"23种设计模式之创建型模式","slug":"java-pattern-builder-factory-clone","date":"2018-04-09T02:44:06.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2018/04/09/java-pattern-builder-factory-clone/","link":"","permalink":"http://zhangsunyucong.top/2018/04/09/java-pattern-builder-factory-clone/","excerpt":"前言本文主要是介绍5种创建型模式中，除了单例模式外的其他创建型模式，包括建造者模式，工厂模式，抽象工厂模式，原型模式。 1、建造者模式，可以将对象的表现和创建（实现）分离开来，根据不同的创建步骤可以产生不同的对象，而对象的创建也是一次性的，创建后的对象是不可变。","text":"前言本文主要是介绍5种创建型模式中，除了单例模式外的其他创建型模式，包括建造者模式，工厂模式，抽象工厂模式，原型模式。 1、建造者模式，可以将对象的表现和创建（实现）分离开来，根据不同的创建步骤可以产生不同的对象，而对象的创建也是一次性的，创建后的对象是不可变。 2、工厂模式，根据形式的不同，工厂模式可以分为简单工厂方法模式、多工厂方法模式和抽象工厂方法模式。在简单工厂方法模式中只有一个工厂方法，工厂方法根据不同的条件生产不同的对象。多工厂方法模式，为每一个对象都提供一个工厂方法。抽象工厂方法模式，就是在多工厂方法模式的基础上将每个普通工厂方法变为静态工厂方法。另外，可以使用反射来生产产品。 3、抽象工厂模式，它是工厂模式的进一步抽象，它将产品和工厂都抽象为一个接口，每个具体的工厂生产一种具体的产品。 其实它们的特点是，简单工厂方法模式，用一个方法来生产各种产品。多工厂方法模式，一种对象对应一个方法。抽象工厂方法模式，在多工厂方法模式的基础上，进一步的将每个方法都变为静态的，这样子就不需要创建工厂对象了。抽象工厂模式，它将产品和工厂都进一步抽象为一个类或者接口。 一个方法=》多个方法=》多个静态方法=》抽象类（接口） 4、原型模式，就是从一个已经存在的对象（原型）通过克隆和复制创建一个对象。复制分为浅复制和深复制。 浅复制和深复制的区别： 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。 建造者模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BuilderTest &#123; private String basic;//地基 private String wall;//墙 private String roofed;//楼顶 private BuilderTest() &#123;&#125; private BuilderTest(Builder builder) &#123; this.basic = builder.basic; this.wall = builder.wall; this.roofed = builder.roofed; &#125; public void doSomeThing() &#123; &#125; public static class Builder &#123; private String basic;//地基 private String wall;//墙 private String roofed;//楼顶 public Builder setBasic(String basic) &#123; this.basic = basic; return this; &#125; public Builder setWall(String wall) &#123; this.wall = wall; return this; &#125; public Builder setRoofed(String roofed) &#123; this.roofed = roofed; return this; &#125; public BuilderTest create() &#123; BuilderTest builderTest = new BuilderTest(this); return builderTest; &#125; &#125;&#125; BuilderTest的构造函数都是私有的，只在Builder中创建它的实例。Builder是一个公开的静态内部类，它的内部成员变量都是私有的，只能调用相对应的setter方法设置，并和BuilderTest中的成员变量是一样的，每个setter方法都是返回Builder自身的，可以链式的调用，当调用create时会将变量传递给BuilderTest和一次性初始化BuilderTest实例。 实际使用： 1234567BuilderTest builderTest = new BuilderTest.Builder() .setBasic(&quot;basic&quot;) .setWall(&quot;wall&quot;) .setRoofed(&quot;roofed&quot;) .create();builderTest.doSomeThing(); 工厂模式简单工厂方法模式规范产品接口： 123public interface Product &#123; void sayHello();&#125; 产品类：ProductA.java 1234567public class ProductA implements Product &#123; @Override public void sayHello() &#123; System.out.print(&quot;Helle ! My name is ProductA&quot;); &#125;&#125; ProductB.java 1234567public class ProductB implements Product &#123; @Override public void sayHello() &#123; System.out.print(&quot;Hello, My name is ProductB&quot;); &#125;&#125; 简单工厂类 1234567891011121314public class SimpleFactoryTest &#123; public Product createProduct(String name) &#123; if(&quot;ProductA&quot;.equals(name)) &#123; return new ProductA(); &#125; else if(&quot;ProductB&quot;.equals(name)) &#123; return new ProductB(); &#125; else &#123; System.out.print(&quot;没有找到产品，请输入正确的类型！&quot;); return null; &#125; &#125;&#125; 使用： 123456SimpleFactoryTest simpleFactoryTest = new SimpleFactoryTest();Product productA = simpleFactoryTest.createProduct(&quot;ProductA&quot;);productA.sayHello();Product ProductB = simpleFactoryTest.createProduct(&quot;ProductB&quot;);ProductB.sayHello(); 多工厂方法模式MultiMethodFactory.java 12345678910public class MultiMethodFactory &#123; public Product createProductA() &#123; return new ProductA(); &#125; public Product createProductB() &#123; return new ProductB(); &#125;&#125; 使用： 123456MultiMethodFactory multiMethodFactory = new MultiMethodFactory();Product productA = multiMethodFactory.createProductA();productA.sayHello(); Product productB = multiMethodFactory.createProductB();productB.sayHello(); 静态工厂方法模式12345678910public class StaticMethodFactory &#123; public static Product createProductA() &#123; return new ProductA(); &#125; public static Product createProductB() &#123; return new ProductB(); &#125;&#125; 使用： 12345Product productA = StaticMethodFactory.createProductA();Product productB = StaticMethodFactory.createProductB();productA.sayHello();productB.sayHello(); 抽象工厂模式产品模版： 123public interface Product &#123; void sayHello();&#125; ProductA.java 1234567public class ProductA implements Product &#123; @Override public void sayHello() &#123; System.out.print(&quot;Helle ! My name is ProductA&quot;); &#125;&#125; ProductB.java 1234567public class ProductB implements Product &#123; @Override public void sayHello() &#123; System.out.print(&quot;Hello, My name is ProductB&quot;); &#125;&#125; 工厂模版： 123public interface Factory &#123; Product createProduct();&#125; ProductAFactory.java 1234567public class ProductAFactory implements Factory &#123; @Override public Product createProduct() &#123; return new ProductA(); &#125;&#125; ProductBFactory.java 1234567public class ProductBFactory implements Factory &#123; @Override public Product createProduct() &#123; return new ProductB(); &#125;&#125; 使用： 12345ProductAFactory productAFactory = new ProductAFactory();productAFactory.createProduct();ProductBFactory productBFactory = new ProductBFactory();productBFactory.createProduct(); 原型模式原型模式的关键是实现Cloneable接口，并重写Object的clone函数，Cloneable是一个空接口。 123456789101112131415161718192021public class PrototypeObject implements Cloneable &#123; public int intValue = 34; public String strValue = &quot;I am the First value&quot;; public ProductA productA = new ProductA(); @Override public Object clone() throws CloneNotSupportedException &#123; PrototypeObject prototypeObject = (PrototypeObject)super.clone(); return prototypeObject; &#125; @Override public String toString() &#123; return &quot;intValue=&quot; + intValue + &quot;strValue=&quot; + strValue + &quot;helloTxt=&quot; + productA.helloTxt; &#125;&#125; ProductA.java 123456789public class ProductA implements Product &#123; public String helloTxt = &quot;Helle ! My name is ProductA&quot;; @Override public void sayHello() &#123; System.out.print(&quot;Helle ! My name is ProductA&quot;); &#125;&#125; 使用： 1234567891011121314151617try &#123; PrototypeObject prototypeObject = new PrototypeObject(); PrototypeObject prototypeObjectClone = (PrototypeObject)prototypeObject.clone(); Log.d(&quot;hyj&quot;, &quot;改变克隆对象值之前:&quot; + &quot;prototypeObject=&gt;&quot; + prototypeObject.toString()); prototypeObjectClone.strValue = &quot;I am the second value&quot;; prototypeObjectClone.productA.helloTxt = &quot;Hi, I am here and change something&quot;; Log.d(&quot;hyj&quot;, &quot;改变克隆对象值之后:&quot; + &quot;prototypeObject=&gt;&quot; + prototypeObject.toString()); Log.d(&quot;hyj&quot;, &quot;改变克隆对象值之后:&quot; + &quot;prototypeObjectClone=&gt;&quot; + prototypeObjectClone.toString());&#125; catch (CloneNotSupportedException e) &#123; System.out.print(e.getCause());&#125; 运行结果： 123改变克隆对象值之前:prototypeObject=&gt;intValue=34strValue=I am the First valuehelloTxt=Helle ! My name is ProductA改变克隆对象值之后:prototypeObject=&gt;intValue=34strValue=I am the First valuehelloTxt=Hi, I am here and change something改变克隆对象值之后:prototypeObjectClone=&gt;intValue=34strValue=I am the second valuehelloTxt=Hi, I am here and change something 在Object中，Object#clone 12345678910111213protected Object clone() throws CloneNotSupportedException &#123; if (!(this instanceof Cloneable)) &#123; throw new CloneNotSupportedException(&quot;Class &quot; + getClass().getName() + &quot; doesn&#x27;t implement Cloneable&quot;); &#125; return internalClone();&#125;/* * Native helper method for cloning. */private native Object internalClone(); 可以看出，Object的clone方法会调用native函数internalClone； 上面提到原型模式是一种浅复制，将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。而要彻底重新克隆和创建对象，需要使用深复制。 深复制，可以使用对象的序列化来实现。 1234567891011121314151617181920212223242526272829303132333435public class PrototypeObject implements Cloneable, Serializable &#123; public int intValue = 34; public String strValue = &quot;I am the First value&quot;; public ProductA productA = new ProductA(); /* 浅复制 */ @Override public Object clone() throws CloneNotSupportedException &#123; PrototypeObject prototypeObject = (PrototypeObject)super.clone(); return prototypeObject; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; @Override public String toString() &#123; return &quot;intValue=&quot; + intValue + &quot;strValue=&quot; + strValue + &quot;helloTxt=&quot; + productA.helloTxt; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://zhangsunyucong.top/tags/java/"}]},{"title":"在Android中解释服务器数据","slug":"android-gson-server","date":"2018-04-08T07:52:23.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2018/04/08/android-gson-server/","link":"","permalink":"http://zhangsunyucong.top/2018/04/08/android-gson-server/","excerpt":"前言在这一篇文章中，主要讲一下如何使用Gson解释服务器返回的具有固定格式的数据。 分析服务器：在本地使用nodejs的express框架建立的简单服务器。它返回了的数据如下： 12345var testArrayStr = &quot;&#123;\\&quot;data\\&quot;: [&#123;\\&quot;cnName\\&quot;: \\&quot;jakewharton\\&quot;,\\&quot;age\\&quot;: 13,\\&quot;IsBoy\\&quot;: true&#125;, &#123;\\&quot;cnName\\&quot;: \\&quot;小红\\&quot;,\\&quot;age\\&quot;: 24,\\&quot;IsBoy\\&quot;: false&#125;],\\&quot;msg\\&quot;: \\&quot;\\&quot;,\\&quot;status\\&quot;: 200&#125;&quot;;var testObjStr = &quot;&#123;\\&quot;data\\&quot;: &#123;\\&quot;cnName\\&quot;: \\&quot;小红\\&quot;,\\&quot;age\\&quot;: 24,\\&quot;IsBoy\\&quot;: false&#125;,\\&quot;msg\\&quot;: \\&quot;\\&quot;,\\&quot;status\\&quot;: 200&#125;&quot;;res.end(testObjStr);","text":"前言在这一篇文章中，主要讲一下如何使用Gson解释服务器返回的具有固定格式的数据。 分析服务器：在本地使用nodejs的express框架建立的简单服务器。它返回了的数据如下： 12345var testArrayStr = &quot;&#123;\\&quot;data\\&quot;: [&#123;\\&quot;cnName\\&quot;: \\&quot;jakewharton\\&quot;,\\&quot;age\\&quot;: 13,\\&quot;IsBoy\\&quot;: true&#125;, &#123;\\&quot;cnName\\&quot;: \\&quot;小红\\&quot;,\\&quot;age\\&quot;: 24,\\&quot;IsBoy\\&quot;: false&#125;],\\&quot;msg\\&quot;: \\&quot;\\&quot;,\\&quot;status\\&quot;: 200&#125;&quot;;var testObjStr = &quot;&#123;\\&quot;data\\&quot;: &#123;\\&quot;cnName\\&quot;: \\&quot;小红\\&quot;,\\&quot;age\\&quot;: 24,\\&quot;IsBoy\\&quot;: false&#125;,\\&quot;msg\\&quot;: \\&quot;\\&quot;,\\&quot;status\\&quot;: 200&#125;&quot;;res.end(testObjStr); 我们可以和服务器约定返回的格式模版如下，他们的主要区别是data，可以是对象或者对象的数组形式。 定义解释data为对象的模板： 12345public class BaseObjectResult&lt;T&gt; &#123; public T data; public String msg; public int status;&#125; 定义解释data为数组的模版： 12345public class BaseArrayResult&lt;T&gt; &#123; public List&lt;T&gt; data; public String msg; public int status;&#125; 实体对象：TestData.java 12345678910111213public class TestData &#123; public String cnName; public int age; public boolean IsBoy; @Override public String toString() &#123; return &quot;testData:&quot; + &quot;cnName=&quot; + this.cnName + &quot; &quot; + &quot;age=&quot; + this.age + &quot; &quot; + &quot;IsBogy=&quot; + this.IsBoy; &#125;&#125; 使用retrofit和gson解释自定义Converter.Factory 123456789101112131415161718192021222324252627282930public class DecodeConverterFactory extends Converter.Factory &#123; public static DecodeConverterFactory create() &#123; return create(new Gson()); &#125; public static DecodeConverterFactory create(Gson gson) &#123; return new DecodeConverterFactory(gson); &#125; private final Gson gson; private DecodeConverterFactory(Gson gson) &#123; if (gson == null) throw new NullPointerException(&quot;gson == null&quot;); this.gson = gson; &#125; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new CustomResponseBodyConverter&lt;&gt;(adapter, type); &#125; @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new DecodeRequestBodyConverter&lt;&gt;(gson, adapter); &#125;&#125; CustomResponseBodyConverter.java 1234567891011121314151617181920public class CustomResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; private final TypeAdapter&lt;T&gt; adapter; private Type mType; public CustomResponseBodyConverter(TypeAdapter&lt;T&gt; adapter, Type type) &#123; this.adapter = adapter; this.mType = type; &#125; @Override public T convert(ResponseBody value) throws IOException &#123; //解密字符串 if(mType == String.class) &#123; return (T) value.string(); &#125; else &#123; &#125; &#125;&#125; DecodeRequestBodyConverter.java 1234567891011121314151617181920212223public class DecodeRequestBodyConverter&lt;T&gt; implements Converter&lt;T, RequestBody&gt; &#123; private static final MediaType MEDIA_TYPE = MediaType.parse(&quot;application/json; charset=UTF-8&quot;); private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;); private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; DecodeRequestBodyConverter(Gson gson,TypeAdapter&lt;T&gt; adapter)&#123; this.gson = gson; this.adapter = adapter; &#125; @Override public RequestBody convert(T value) throws IOException &#123; Buffer buffer = new Buffer(); //value.toString() Writer writer = new OutputStreamWriter(buffer.outputStream(),UTF_8); JsonWriter jsonWriter = gson.newJsonWriter(writer); adapter.write(jsonWriter,value); jsonWriter.flush(); return RequestBody.create(MEDIA_TYPE,buffer.readByteString()); &#125;&#125; 开始使用： TestDataApi.java 1234public interface TestDataApi &#123; @GET(&quot;/&quot;) Call&lt;BaseObjectResult&lt;TestData&gt;&gt; getArrayData();&#125; 当data为对象时：123456789101112131415161718192021222324252627Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://192.168.20.168:3000&quot;) .addConverterFactory(DecodeConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build();TestDataApi testDataApi = retrofit.create(TestDataApi.class);Call&lt;BaseObjectResult&lt;TestData&gt;&gt; resultCall = testDataApi.getArrayData();resultCall.enqueue(new Callback&lt;BaseObjectResult&lt;TestData&gt;&gt;() &#123; @Override public void onResponse(Call&lt;BaseObjectResult&lt;TestData&gt;&gt; call, Response&lt;BaseObjectResult&lt;TestData&gt;&gt; response) &#123; if(response.isSuccessful()) &#123; if(response.body() != null) &#123; TestData testData = response.body().data; Log.d(&quot;hyj&quot;, &quot;msg=&quot; + response.body().msg + &quot; &quot; + &quot;status=&quot; + response.body().status + &quot; &quot; + testData.toString()); &#125; &#125; &#125; @Override public void onFailure(Call&lt;BaseObjectResult&lt;TestData&gt;&gt; call, Throwable t) &#123; ToastUtil.showShort(mContext, t.getMessage()); &#125;&#125;); 输出的结果是： 04-08 16:04:56.053 31894-31894/com.zhangsunyucong.chanxa.testproject D/hyj: msg= status=200 testData:cnName=小红 age=24 IsBogy=false 当data为数组时：123456789101112131415161718192021222324252627282930Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://192.168.20.168:3000&quot;) .addConverterFactory(DecodeConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); TestDataApi testDataApi = retrofit.create(TestDataApi.class); Call&lt;BaseArrayResult&lt;TestData&gt;&gt; resultCall = testDataApi.getArrayData(); resultCall.enqueue(new Callback&lt;BaseArrayResult&lt;TestData&gt;&gt;() &#123; @Override public void onResponse(Call&lt;BaseArrayResult&lt;TestData&gt;&gt; call, Response&lt;BaseArrayResult&lt;TestData&gt;&gt; response) &#123; if(response.isSuccessful()) &#123; if(response.body() != null) &#123; List&lt;TestData&gt; testData = response.body().data; if(testData != null) &#123; for(int i = 0; i &lt; testData.size(); i++) &#123; Log.d(&quot;hyj&quot;, &quot;msg=&quot; + response.body().msg + &quot; &quot; + &quot;status=&quot; + response.body().status + &quot; &quot; + testData.get(i).toString()); &#125; &#125; &#125; &#125; &#125; @Override public void onFailure(Call&lt;BaseArrayResult&lt;TestData&gt;&gt; call, Throwable t) &#123; ToastUtil.showShort(mContext, t.getMessage()); &#125; &#125;); 输出的结果是： 04-08 16:11:44.703 32440-32440/com.zhangsunyucong.chanxa.testproject D/hyj: msg= status=200 testData:cnName=jakewharton age=13 IsBogy=true04-08 16:11:44.703 32440-32440/com.zhangsunyucong.chanxa.testproject D/hyj: msg= status=200 testData:cnName=小红 age=24 IsBogy=false 手动解释####关键的代码是： 123456789101112131415private ParameterizedType type(final Class raw, final Type... args) &#123; return new ParameterizedType() &#123; public Type getRawType() &#123; return raw; &#125; public Type[] getActualTypeArguments() &#123; return args; &#125; public Type getOwnerType() &#123; return null; &#125; &#125;;&#125; 当data返回的是对象时： 12345678910111213141516171819202122232425TestDataApi testDataApi = retrofit.create(TestDataApi.class); Call&lt;String&gt; resultCall = testDataApi.getArrayData(); resultCall.enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123; if(response.isSuccessful()) &#123; if(response.body() != null) &#123; String testDataStr = response.body(); Gson gson = new Gson(); BaseObjectResult&lt;TestData&gt; testData = gson.fromJson(testDataStr, type(BaseObjectResult.class, TestData.class)); Log.d(&quot;hyj&quot;, &quot;msg=&quot; + testData.msg + &quot; &quot; + &quot;status=&quot; + testData.status + &quot; &quot; + testData.data.toString()); &#125; &#125; &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable t) &#123; ToastUtil.showShort(mContext, t.getMessage()); &#125; &#125;); 当返回的data是数组时： 1234567891011121314151617181920212223242526272829TestDataApi testDataApi = retrofit.create(TestDataApi.class); Call&lt;String&gt; resultCall = testDataApi.getArrayData(); resultCall.enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123; if(response.isSuccessful()) &#123; if(response.body() != null) &#123; String testDataStr = response.body(); Gson gson = new Gson(); BaseArrayResult&lt;TestData&gt; testData = gson.fromJson(testDataStr, type(BaseArrayResult.class, TestData.class)); if(testData != null &amp;&amp; testData.data != null) &#123; for(int i = 0; i &lt; testData.data.size(); i++) &#123; Log.d(&quot;hyj&quot;, &quot;msg=&quot; + testData.msg + &quot; &quot; + &quot;status=&quot; + testData.status + &quot; &quot; + testData.data.get(i).toString()); &#125; &#125; &#125; &#125; &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable t) &#123; ToastUtil.showShort(mContext, t.getMessage()); &#125; &#125;); 它们返回的结果和第一种方法的返回结果是一样的。","categories":[],"tags":[]},{"title":"23种设计模式之《单例模式》","slug":"java-pattern-singleton","date":"2018-04-04T00:38:20.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2018/04/04/java-pattern-singleton/","link":"","permalink":"http://zhangsunyucong.top/2018/04/04/java-pattern-singleton/","excerpt":"什么是单例模式单例模式是23种设计模式中最简单和易用的模式。在某些情境下，如在一个上市公司中，有很多不同级别的员工，但是公司的CEO或者CTO都是只有一个的，CEO或者CTO在公司里就要求是一个单例。单例模式，就是某个类因实际情况的需要，要求在全局的范围内只能有唯一的实例对象，这个对象是常驻内存的，可以重复使用，降低重复创建对象的开销。 单例模式的特点 类的构造函数是私有的 在类内部实例化对象，并通过静态方法向外提供实例化的对象 下面主要讲解实现单例模式的方法以及它们的优缺点","text":"什么是单例模式单例模式是23种设计模式中最简单和易用的模式。在某些情境下，如在一个上市公司中，有很多不同级别的员工，但是公司的CEO或者CTO都是只有一个的，CEO或者CTO在公司里就要求是一个单例。单例模式，就是某个类因实际情况的需要，要求在全局的范围内只能有唯一的实例对象，这个对象是常驻内存的，可以重复使用，降低重复创建对象的开销。 单例模式的特点 类的构造函数是私有的 在类内部实例化对象，并通过静态方法向外提供实例化的对象 下面主要讲解实现单例模式的方法以及它们的优缺点 单例模式的实现单例模式的目的，就是要确保在全局范围内某个类的对象是唯一的。所以实现单例模式时，我们至少要考虑两个影响对象创建的因素。 在并发的环境下的线程安全 反序列化 饿汉实现在类第一次加载时，就进行对象的实例化。 1234567891011public class SingletonDemo &#123; private final static SingletonDemo mSingletonDemo = new SingletonDemo(); private SingletonDemo() &#123;&#125; public static SingletonDemo getInstance() &#123; return mSingletonDemo; &#125;&#125; 懒汉实现在类加载时不进行对象的实例化，只在对象被第一次访问时，才进行对象的实例化。 1234567891011121314public class SingletonDemo &#123; private static SingletonDemo mSingletonDemo; private SingletonDemo() &#123;&#125; public static SingletonDemo getInstance() &#123; if(mSingletonDemo == null) &#123; mSingletonDemo = new SingletonDemo(); &#125; return mSingletonDemo; &#125;&#125; 明显，在多线程的环境下，上面两种实现方式都不是线程安全的。为了实现线程安全，我们首先可以想到使用synchronized关键字。 线程安全的懒汉模式 123456789101112131415public class SingletonDemo &#123; private static SingletonDemo mSingletonDemo; private SingletonDemo() &#123;&#125; public static synchronized SingletonDemo getInstance() &#123; if(mSingletonDemo == null) &#123; mSingletonDemo = new SingletonDemo(); &#125; return mSingletonDemo; &#125;&#125; 关于synchronized关键字说明一下，synchronized声明的静态方法，同时只能被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。即：两个线程可以同时访问一个对象的两个不同的synchronized方法，其中一个是静态方法，一个是非静态方法。 所以，当有多个线程同时访问getInstance静态方法时，多个其他的线程只能等待，这时只有一个线程能够访问getInstance方法，等这个线程释放后其他线程才能访问。这样就会影响速度和效率。 为了提高懒汉模式的速度和效率，可以减小锁的粒度和次数。 双重校验锁法 123456789101112131415161718public class SingletonDemo &#123; private static SingletonDemo mSingletonDemo; private SingletonDemo() &#123;&#125; public static SingletonDemo getInstance() &#123; if(mSingletonDemo == null) &#123; synchronized (SingletonDemo.class) &#123; if(mSingletonDemo == null) &#123; mSingletonDemo = new SingletonDemo(); &#125; &#125; &#125; return mSingletonDemo; &#125;&#125; 从上面可以看到，只有在第一次访问时才会锁定和创建类的对象，之后的访问都是直接使用已经创建好的对象，这样减少锁定的次数和范围，以达到提高单例模式的效率。 但是，对象的实例化，并不是一个原子性操作。即第11行代码处，它可以分成下面三个步骤：1、new SingletonDemo()，为SingletonDemo实例分配内存2、调用SingletonDemo的构造器，完成初始化工作3、将mSingletonDemo指向分配的内存空间 由于java处理器可以乱序执行，即无法保证2和3的执行顺序。这对双重校验锁法实现的单例模式有什么影响呢？当第一个线程访问getInstance方法时，会锁定临界区（第9行到第13行代码），它实例化对象的顺序是1=&gt;3=&gt;2，而在这时如果有第二个线程来访问getInstance方法，由于第一个线程在处理器中执行完了3未执行2，第二个线程会马上得到实例对象，因为第一个线程的3已经执行完即mSingletonDemo已经不为空。当第二个线程使用没有初始化的对象时就会出现问题。 所以，双重校验锁法也不是完美的，在并发环境下依然可能出现问题。 静态内部类实现123456789101112131415public class SingletonDemo &#123; private static SingletonDemo mSingletonDemo; private SingletonDemo() &#123;&#125; private static class SingletonHolder &#123; private static final SingletonDemo INSTANCE = new SingletonDemo(); &#125; public static SingletonDemo getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 第一次加载SingletonDemo类时并不会实例化INSTANCE，只有在第一次调用getInstance方法时，才会加载SingletonHolder内部类，创建SingletonDemo实例。这种方式不仅确保了线程安全，也保证单例对象的唯一性，同时也实现了单例对象的懒加载。 枚举实现上面几种实现方式，可能会因为反序列化而创建新的实例，所以必须重写readResolve方法，在readResolve方法中返回已经创建的单例。 使用枚举可以很简单的实现单例模式，这也是Effective Java中提倡的方式。因为枚举本身就是类型安全的，并且枚举实例在任何情况下都是单例。 123456public enum SingletonEnumDemo &#123; INSTANCE; public void justDoYourThing() &#123; &#125;&#125; 枚举单例使用 1SingletonEnumDemo.INSTANCE.justDoYourThing(); 容器实现1234567891011121314151617public class SingletonDemo &#123; private static Map&lt;String, Object&gt; singletonMap = new HashMap&lt;String, Object&gt;(); private SingletonDemo() &#123;&#125; public static void registerService(String key, Object instance) &#123; if (!singletonMap.containsKey(key)) &#123; singletonMap.put(key, instance); &#125; &#125; public static Object getService(String key) &#123; return singletonMap.get(key); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://zhangsunyucong.top/tags/java/"}]},{"title":"Android中的retrofit源码分析","slug":"android-retrofit","date":"2018-03-08T05:05:41.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2018/03/08/android-retrofit/","link":"","permalink":"http://zhangsunyucong.top/2018/03/08/android-retrofit/","excerpt":"前言本文基于的retrofit版本是：2.1.0，文章会从retrofit的使用逐渐进入它的源码进行分析。retrofit是一个基于okhttp封装的，具有RESTful风格的HTTP网络请求框架。也就是说，它只负责网络接口配置和调用的封装，实际底层调用的工作还是由okhttp完成的。可以使用它以注解的形式配置请求的地址，请求参数等，还可以添加自定义拦截器、网络拦截器和数据转换器等进行处理和扩展。 源码分析","text":"前言本文基于的retrofit版本是：2.1.0，文章会从retrofit的使用逐渐进入它的源码进行分析。retrofit是一个基于okhttp封装的，具有RESTful风格的HTTP网络请求框架。也就是说，它只负责网络接口配置和调用的封装，实际底层调用的工作还是由okhttp完成的。可以使用它以注解的形式配置请求的地址，请求参数等，还可以添加自定义拦截器、网络拦截器和数据转换器等进行处理和扩展。 源码分析 从使用开始讲起。 创建retrofit实例 1234Retrofit retrofit = new Retrofit.Builder() baseUrl(&quot;https://heyunjian.leanapp.cn/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); 从形式上看，可以知道retrofit的创建使用了建造者模式。下面我们进入它的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public final class Retrofit &#123; // 网络请求配置对象（对使用时的注解进行解析后得到的对象保存在里面） private final Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;(); //网络请求器工厂 final okhttp3.Call.Factory callFactory; //网络请求的基地址 final HttpUrl baseUrl; //数据转换工厂 final List&lt;Converter.Factory&gt; converterFactories; //网络请求适配器 final List&lt;CallAdapter.Factory&gt; adapterFactories; //回调方法执行器 final Executor callbackExecutor; final boolean validateEagerly; Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site. this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; &#125; @SuppressWarnings(&quot;unchecked&quot;) // Single-interface proxy creation guarded by parameter safety. public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; ... public static final class Builder &#123; private final Platform platform; private okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private Executor callbackExecutor; private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform; // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); &#125; public Builder() &#123; this(Platform.get()); &#125; Builder(Retrofit retrofit) &#123; platform = Platform.get(); callFactory = retrofit.callFactory; baseUrl = retrofit.baseUrl; converterFactories.addAll(retrofit.converterFactories); adapterFactories.addAll(retrofit.adapterFactories); // Remove the default, platform-aware call adapter added by build(). adapterFactories.remove(adapterFactories.size() - 1); callbackExecutor = retrofit.callbackExecutor; validateEagerly = retrofit.validateEagerly; &#125; ... public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException(&quot;Base URL required.&quot;); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; &#125;&#125; 在Retrofit#Builder类中的成员变量和Retrofit的基本是一样的，这也正是建造者模式的特点。Retrofit的成员变量已经在源码中有注释。在Builder中，主要看Platform。 Platform的子类： 主要有两个子类，对应着retrofit支持的平台：Android和java8的平台。 Platform子类Android的源码如下： 1234567891011121314151617static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; MainThreadExecutor静态内部类中，创建了主线程的handler，用于将请求处理的结果返回给Android主线程。 1retrofit.create(CSDNAPIService.class); 进入create方法源码 Retrofit#create 1234567891011121314151617181920212223242526@SuppressWarnings(&quot;unchecked&quot;) // Single-interface proxy creation guarded by parameter safety. public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 可以看到，上面使用了动态代理。proxy就是反射创建的类对象，method是对象要调用的方法，args是要调用方法的参数。主要分析loadServiceMethod方法。 Retrofit#loadServiceMethod 12345678910111213ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; serviceMethodCache是一个缓存，首先从缓存中取数据，没有，线程锁定，调用ServiceMethod的相关代码。 1result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); 主要工作在build方法中， ServiceMethod#build 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public ServiceMethod build() &#123; callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError(&quot;&#x27;&quot; + Utils.getRawType(responseType).getName() + &quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;); &#125; responseConverter = createResponseConverter(); for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; if (httpMethod == null) &#123; throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;); &#125; if (!hasBody) &#123; if (isMultipart) &#123; throw methodError( &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;); &#125; if (isFormEncoded) &#123; throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot; + &quot;request body (e.g., @POST).&quot;); &#125; &#125; int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;, parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, &quot;No Retrofit annotation found.&quot;); &#125; parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod); &#125; if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;); &#125; if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;); &#125; if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError(&quot;Multipart method must contain at least one @Part.&quot;); &#125; return new ServiceMethod&lt;&gt;(this);&#125; 这里主要看第11行，这里主要是解析使用时的各种配置注解。 ServiceMethod#parseMethodAnnotation 123456789101112131415161718192021222324252627282930313233343536373839private void parseMethodAnnotation(Annotation annotation) &#123; if (annotation instanceof DELETE) &#123; parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false); &#125; else if (annotation instanceof GET) &#123; parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false); &#125; else if (annotation instanceof HEAD) &#123; parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false); if (!Void.class.equals(responseType)) &#123; throw methodError(&quot;HEAD method must use Void as response type.&quot;); &#125; &#125; else if (annotation instanceof PATCH) &#123; parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true); &#125; else if (annotation instanceof POST) &#123; parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true); &#125; else if (annotation instanceof PUT) &#123; parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true); &#125; else if (annotation instanceof OPTIONS) &#123; parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false); &#125; else if (annotation instanceof HTTP) &#123; HTTP http = (HTTP) annotation; parseHttpMethodAndPath(http.method(), http.path(), http.hasBody()); &#125; else if (annotation instanceof retrofit2.http.Headers) &#123; String[] headersToParse = ((retrofit2.http.Headers) annotation).value(); if (headersToParse.length == 0) &#123; throw methodError(&quot;@Headers annotation is empty.&quot;); &#125; headers = parseHeaders(headersToParse); &#125; else if (annotation instanceof Multipart) &#123; if (isFormEncoded) &#123; throw methodError(&quot;Only one encoding annotation is allowed.&quot;); &#125; isMultipart = true; &#125; else if (annotation instanceof FormUrlEncoded) &#123; if (isMultipart) &#123; throw methodError(&quot;Only one encoding annotation is allowed.&quot;); &#125; isFormEncoded = true; &#125;&#125; 从上面可以看到具体的注解。 分析retrofit的同步和异步请求过程： 异步请求OkHttpCall#enqueue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException(&quot;callback == null&quot;); okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already executed.&quot;); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; failure = creationFailure = t; &#125; &#125; &#125; if (failure != null) &#123; callback.onFailure(this, failure); return; &#125; if (canceled) &#123; call.cancel(); &#125; call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException &#123; Response&lt;T&gt; response; try &#123; response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; callSuccess(response); &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callSuccess(Response&lt;T&gt; response) &#123; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;);&#125; 看第15行，createRawCall()创建了call，call是一个接口，它的子类有RealCall. 123public interface Call extends Cloneablefinal class RealCall implements Call 进入OkHttpCall#createRawCall方法 12345678private okhttp3.Call createRawCall() throws IOException &#123; Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException(&quot;Call.Factory returned null.&quot;); &#125; return call;&#125; 它用参数创建http请求对象，然后创建call，并返回。 分析newCall方法，是callFactory的方法，看Factory 123interface Factory &#123; Call newCall(Request request); &#125; 它被OkHttpClient实现，所以会到OkHttpClient的newCall OkHttpClient#newCall 123@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */); &#125; 现在分析到了RealCall。异步和同步请求调用的方法，都会来到RealCall调用enqueue和execute方法。 看异步的enqueue方法RealCall#enqueue 12345678@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 看第7行，AsyncCall是一个Runnable任务，会提交给线程池执行。responseCallback是异步请求结果的回调。 123final class AsyncCall extends NamedRunnablepublic abstract class NamedRunnable implements Runnable responseCallback是一个Callback 123456public interface Callback &#123; void onFailure(Call call, IOException e); void onResponse(Call call, Response response) throws IOException;&#125; AsyncCall是一个Runnable任务，那它做的任务是什么呢？ AsyncCall#execute 12345678910111213141516171819202122@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 上面的第4行getResponseWithInterceptorChain返回了请求的结果，其实它里面发生了整个请求的过程。等一下会进去分析它是如何责任链的调用拦截器的和它是怎样根据响应结果调用callback的回调方法的。 AsyncCall#execute是重写NamedRunnable中的execute方法的。 12345678910111213141516171819public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; 看到，在任务的主要工作run方法中，调用了execute方法。而主要工作做了什么？就是上面的AsyncCall#execute所做的。 回到前面，RealCall#enqueue，进入第7行的Dispatcher的enqueue Dispatcher#enqueue 12345678synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125;&#125; runningAsyncCalls保存了异步执行的任务，它的解析如下的英文解释。如果同时执行的任务数没有超过线程池的最大可执行次数，就直接放到线程池中执行。 1234567/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); ... private int maxRequests = 64; private int maxRequestsPerHost = 5; 之前在分析AsyncCall#execute时说过，在第4行的getResponseWithInterceptorrChain中完成了整个网络请求的过程，在过程中责任链式的调用了拦截器和网络拦截器。下面从源码上分析拦截器的调用过程。 AsyncCall#getResponseWithInterceptorChain 1234567891011121314151617Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest);&#125; 可以看到，是先将所有的拦截器放到了interceptors列表中。然后在第14到16行调用了拦截器。这里还有一个主要的分析工作，就是各个系统提供的拦截器在网络请求过程负责做了什么。（本篇文章没讲） RealInterceptorChain#proceed 1234567891011121314public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; ... // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next);... return response;&#125; index刚开始是0，从第一个拦截器开始调用，在RealInterceptorChain#proceed中又创建了下一个RealInterceptorChain，然后执行当前拦截器。 到这里暂停一下，先了解一个拦截器是怎么样定义的？ 1234567891011public class CustomInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); ... //做拦截器做的事情 ... return chain.proceed(request); &#125;&#125; 最后那条语句正和AsyncCall#getResponseWithInterceptorChain的最后一句是一样的。这样子就形成了一条链，不断的index + 1即一个一个的按顺序执行完所有的拦截器，而每个拦截器负责自己的责任，这就是责任链模式。 同步请求OkHttpCall#execute 1234567891011121314151617181920212223242526272829303132@Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already executed.&quot;); executed = true; if (creationFailure != null) &#123; if (creationFailure instanceof IOException) &#123; throw (IOException) creationFailure; &#125; else &#123; throw (RuntimeException) creationFailure; &#125; &#125; call = rawCall; if (call == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException e) &#123; creationFailure = e; throw e; &#125; &#125; &#125; if (canceled) &#123; call.cancel(); &#125; return parseResponse(call.execute());&#125; 同异步请求分析中一样，主要都是调用createRawCall方法，这在上面已经分析。然后会到OkHttpClient中调用的execute方法。因为是同步请求，最后在parseResponse中解析了请求返回的结果，回调给Android前端。 OkHttpClient#execute 123456789101112131415@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 第8行，进入源码是 1234/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 将RealCall添加到runningSyncCalls. 12/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 在第9行，同样是调用了getResponseWithInterceptorChain方法得到请求的结果，这个在异步请求分析中已经讲过。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangsunyucong.top/tags/Android/"}]},{"title":"Android中的布局加载器LayoutInflater","slug":"android-layout-inflater","date":"2018-02-23T09:08:04.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2018/02/23/android-layout-inflater/","link":"","permalink":"http://zhangsunyucong.top/2018/02/23/android-layout-inflater/","excerpt":"概述public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) 主要是从源码角度理解下面三段代码的区别： mInflater.inflate(R.layout.item, null);mInflater.inflate(R.layout.item, parent ,false);mInflater.inflate(R.layout.item, parent ,true); 第一句：直接返回了布局，不正确处理布局参数第二句：返回布局，并能正确处理了布局参数第三句：返回布局，能正确处理了布局参数，并将布局添加到parent中","text":"概述public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) 主要是从源码角度理解下面三段代码的区别： mInflater.inflate(R.layout.item, null);mInflater.inflate(R.layout.item, parent ,false);mInflater.inflate(R.layout.item, parent ,true); 第一句：直接返回了布局，不正确处理布局参数第二句：返回布局，并能正确处理了布局参数第三句：返回布局，能正确处理了布局参数，并将布局添加到parent中 源码从下面使用代码开始： 12345678LayoutInflater layoutInflater = LayoutInflater.from(HomeAcivity.this);layoutInflater.inflate(R.layout.layout_rv_photo_item, null);layoutInflater.inflate(R.layout.layout_rv_photo_item, (ViewGroup)findViewById(android.R.id.content), false);layoutInflater.inflate(R.layout.layout_rv_photo_item, (ViewGroup)findViewById(android.R.id.content), true); 最后会都会来到这里： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; //result是根布局 View result = root; try &#123; // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); &#125; final String name = parser.getName(); if (DEBUG) &#123; System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); &#125; if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println(&quot;Creating params from root: &quot; + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) //第二句的关键 temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println(&quot;-----&gt; start inflating children&quot;); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println(&quot;-----&gt; done inflating children&quot;); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. //第三句话的关键 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. //parent为空或者第三个参数为false，都是直接返回第一个参数设置的布局， //否则返回parent if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; final InflateException ie = new InflateException(e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException(parser.getPositionDescription() + &quot;: &quot; + e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; finally &#123; // Don&#x27;t retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; return result; &#125;&#125;","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"HandlerThread和IntentService","slug":"android-intentservice-handlerthread","date":"2018-02-23T01:54:05.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2018/02/23/android-intentservice-handlerthread/","link":"","permalink":"http://zhangsunyucong.top/2018/02/23/android-intentservice-handlerthread/","excerpt":"前言在这一篇文章中，会看HandlerThread和IntentService的源码。为什么一起讲它们呢？在Android中有一条思路，就是从java的线程，到Android中的消息机制，到将java线程和消息机制结合就是HandlerThread，而IntentService就是在HandlerThread基础上再与service结合在一起。 关于Android中的异步的东西，还有AsyncTask，AsyncTask是对java中的线程池的再次封装。进一步，可以联想到Loader.","text":"前言在这一篇文章中，会看HandlerThread和IntentService的源码。为什么一起讲它们呢？在Android中有一条思路，就是从java的线程，到Android中的消息机制，到将java线程和消息机制结合就是HandlerThread，而IntentService就是在HandlerThread基础上再与service结合在一起。 关于Android中的异步的东西，还有AsyncTask，AsyncTask是对java中的线程池的再次封装。进一步，可以联想到Loader. 回到本篇文章主题。 HandlerThread是一个直接继承于Thread的，并在run方法中将线程的Looper进行常规的初始化。而我们要做的就是提供一个Handler，并将Handler与HanderThread的Looper进行关联，通过Handler发送消息和处理消息。 IntentService直接继承于Service，在它的内部封装了HandlerThread的使用过程：提供一个Handler（即：ServiceHandler），并将Handler与HanderThread的Looper进行关联，然后它进一步将启动Service的Intent以消息的形式，通过Handler传给onHandleIntent方法，然后IntentService优雅的结束自己。我们要做的就是在onHandleIntent中做线程要做的事情。 源码HandlerThread.jva 123456789101112131415161718192021222324252627public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; private @Nullable Handler mHandler; ... protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; ...&#125; HandlerThread的run方法做了主要的工作。创建Looper，在onLooperPrepare做开始循环前的初始化工作，开始Looper循环。 在具体使用HandlerThread时，就是创建Handler，将Handler与HandlerThread的Looper进行关联，然后通过Handler发送消息，处理消息。说明，消息是在HandlerThread线程中处理的。 IntentService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; /** * Creates an IntentService. Invoked by your subclass&#x27;s constructor. * * @param name Used to name the worker thread, important only for debugging. */ public IntentService(String name) &#123; super(); mName = name; &#125; ... @Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; /** * You should not override this method for your IntentService. Instead, * override &#123;@link #onHandleIntent&#125;, which the system calls when the IntentService * receives a start request. * @see android.app.Service#onStartCommand */ @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; /** * Unless you provide binding for your service, you don&#x27;t need to implement this * method, because the default implementation returns null. * @see android.app.Service#onBind */ @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; /** * This method is invoked on the worker thread with a request to process. * Only one Intent is processed at a time, but the processing happens on a * worker thread that runs independently from other application logic. * So, if this code takes a long time, it will hold up other requests to * the same IntentService, but it will not hold up anything else. * When all requests have been handled, the IntentService stops itself, * so you should not call &#123;@link #stopSelf&#125;. * * @param intent The value passed to &#123;@link * android.content.Context#startService(Intent)&#125;. * This may be null if the service is being restarted after * its process has gone away; see * &#123;@link android.app.Service#onStartCommand&#125; * for details. */ @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; IntentService是一个service子类,在onCreate中初始化了HandlerThread和ServiceHandler，并将ServiceHandler与HandlerThread的Looper进行关联。在onStart中，将启动服务的Intent封装进Message中，然后发给ServiceHandler。ServiceHandler再将Intent传递给onHandleIntent，最后优雅的结束自己。 在具体使用IntentService时，就是在onHandleIntent中正确的处理启动service的Intent即可。说明，onHandleIntent做的事情是在HandlerThread中进行的，因为HandlerThread的Looper与ServiceHandler已经关联，onHandleIntent是在ServiceHandler中被调用的（好啰嗦）。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"从矩阵来看Android中的一些动画变换","slug":"android-animation-matrix","date":"2018-02-07T06:40:22.000Z","updated":"2020-02-22T12:05:32.000Z","comments":true,"path":"2018/02/07/android-animation-matrix/","link":"","permalink":"http://zhangsunyucong.top/2018/02/07/android-animation-matrix/","excerpt":"开头这篇博客具体的分析过程和android实例。我只是参考和根据自己的理解写的。 在Android中，我们可以从数学的角度来看颜色和动画的变换。这里会从矩阵变换的角度来理解平移，旋转，缩放，对称的变换。 这些变换的完成实际上，是操作一个3X3的矩阵的。而这四种基本变换与操作和这个矩阵有什么样的关系呢？下面会分析。","text":"开头这篇博客具体的分析过程和android实例。我只是参考和根据自己的理解写的。 在Android中，我们可以从数学的角度来看颜色和动画的变换。这里会从矩阵变换的角度来理解平移，旋转，缩放，对称的变换。 这些变换的完成实际上，是操作一个3X3的矩阵的。而这四种基本变换与操作和这个矩阵有什么样的关系呢？下面会分析。 在Android中，已经为每种变换提供了pre、set和post三种操作方式。 set 用于设置Matrix中的值。pre 是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。post 是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。 另外，除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。 平移变换 假设坐标系中有A和B两个点，从A平移到B点，它们之间的关系上图所示。 在x和y轴的移动增量分别是：则易得：它的矩阵表示为： 旋转变换1、围绕坐标原点旋转 由A点顺时针旋转一定角度到B点，如图所示。 由图易知：由上面四个式子，可得：矩阵表示，得： 旋转变换2、围绕某点旋转假设旋转点是：顺时针旋转，结合1、上面的推导结果，可以得到矩阵：可以化为： 可知，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。 缩放变换A点的x，y坐标分别放大a,b倍。则有一下关系：用三维矩阵表示为： 对称变换1、如果对称轴是x轴，则有：用三维矩阵表示为： 2、如果对称轴是y轴，则有：用三维矩阵表示为： 3、如果对称轴是y = x轴，如图由等腰直角三角形可知：已知中点在对称轴上，由中点坐标公式，易得：联合两式子，2式先乘以2，再两式相加和相减，可得：用三维矩阵表示为：4、如果对称轴是y = -x轴。 同理，易推导得： 5、如果对称轴是y = kx时。如图 由图易知：则有：由直线的斜率公式，可得：中点坐标在直线上，结合中点坐标公式，易得：由上面两式，可求得：用三维矩阵表示为： k为任意实数，可以取特殊的值，验证前面对称推导的结果。k为1或者-1时，k为0时，k为无穷大时等等。 6、如果对称轴是y = kx + b时 只需要在5的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"Android中绘制简单几何图形和路径Path","slug":"android-simple-draw-and-path","date":"2018-02-06T05:56:29.000Z","updated":"2020-02-22T13:40:14.000Z","comments":true,"path":"2018/02/06/android-simple-draw-and-path/","link":"","permalink":"http://zhangsunyucong.top/2018/02/06/android-simple-draw-and-path/","excerpt":"背景马上就到2018年过年了，然后我又刚好有兴致，就来玩玩Android中的简单几何图形的绘制和使用Path类来绘制路径。 Path和Canvas在Android中，和我们平时画图一样是有画笔和画布的，Path是画笔，Canvas是画布。与画的样式属性有关，如大小或者颜色等，是由Path来完成的；","text":"背景马上就到2018年过年了，然后我又刚好有兴致，就来玩玩Android中的简单几何图形的绘制和使用Path类来绘制路径。 Path和Canvas在Android中，和我们平时画图一样是有画笔和画布的，Path是画笔，Canvas是画布。与画的样式属性有关，如大小或者颜色等，是由Path来完成的；与画的形状，即画什么东西是由Canva完成的。关于这两个类的各个属性和方法的具体使用，可以浏览爱哥的博客几篇文章。在这里，只是用它们简单的几个函数画一些简单的图形，最后还会给出一个综合一点的demo,主要是为了加强认识绘制时坐标关系。 先贴上我的代码：布局文件： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:id=&quot;@+id/root_draw_view&quot; android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:text=&quot;有点意思&quot;/&gt; &lt;com.example.hyj.ht_test.widget.draw.MyDrawView android:layout_width=&quot;300dp&quot; android:layout_height=&quot;300dp&quot; /&gt;&lt;/LinearLayout&gt; MyDrawView.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class MyDrawView extends View &#123; private Paint mPointPaint; private float[] mFPts; private RectF mRectF; private RectF mRectOvalF; private RectF mRightBottomRectF; private Path mPath; private Path mPath1; public MyDrawView(Context context) &#123; super(context); init(); &#125; public MyDrawView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public MyDrawView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private int mPointStrokeWidth; private void init() &#123; mPointStrokeWidth = 20; mPointPaint = new Paint(); mPointPaint.setColor(Color.RED); mPointPaint.setStrokeWidth(mPointStrokeWidth); mPointPaint.setStyle(Paint.Style.FILL); mPath = new Path(); mPath1 = new Path(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int widthResult = 100; int heightResult = 100; if(widthMode != MeasureSpec.AT_MOST) &#123; widthResult = widthSize; &#125; if(heightMode != MeasureSpec.AT_MOST) &#123; heightResult = heightSize; &#125; int resultSize = widthResult &gt; heightResult ? heightResult : widthResult; setMeasuredDimension(resultSize, resultSize); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mFPts = new float[] &#123; 0, 0, getMeasuredWidth() / 2, 0, getMeasuredWidth(), 0, getMeasuredWidth(), getMeasuredHeight() / 2, getMeasuredWidth(), getMeasuredHeight(), getMeasuredWidth() / 2, getMeasuredHeight(), 0, getMeasuredHeight(), 0, getMeasuredHeight() /2, getMeasuredHeight() / 2, getMeasuredHeight() /2 &#125;; mRectF = new RectF(0, 0, getMeasuredWidth(), getMeasuredHeight()); mRectOvalF = new RectF(mPointStrokeWidth, mPointStrokeWidth, getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() / 2); mRightBottomRectF = new RectF(getMeasuredWidth() / 2, getMeasuredHeight() /2, getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() - mPointStrokeWidth); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawLine(mFPts[0], mFPts[1], mFPts[2], mFPts[2], mPointPaint); mPointPaint.setColor(Color.BLUE); canvas.drawLines(mFPts, mPointPaint); &#125;&#125; MyDrawView中没有考虑padding的影响。 画点几何图形中，最简单的就是点了，首先画点。 drawPoint(float x, float y, Paint paint)drawPoints(float[] pts, Paint paint)drawPoints(float[] pts, int offset, int count, Paint paint) x是点的横坐标，y是点的纵坐标。坐标的点也可以放到数组pts中，可见数组的个数一般是偶数个，offset是开始绘制前，数组中忽略的元素个数。count是忽略了offset个点后，开始取count个元素来绘制点。 123canvas.drawPoints(mFPts, mPointPaint);mPointPaint.setColor(Color.BLUE);canvas.drawPoint(getMeasuredWidth() / 2, 0, mPointPaint); 画线由点组成线，两点确定一条直线。 drawLine(float startX, float startY, float stopX, float stopY, Paint paint)drawLines(float[] pts, int offset, int count, Paint paint)drawLines(float[] pts, Paint paint) 第一个是，直接指定直线的两个点坐标。pts是点的坐标，每两个数组元素确定一个点坐标，每四个元素确定直线的两个点的坐标。 123canvas.drawLine(mFPts[0], mFPts[1], mFPts[2], mFPts[2], mPointPaint);mPointPaint.setColor(Color.BLUE);canvas.drawLines(mFPts, mPointPaint); 画矩形由线可以组成面。矩形可以是长方形，也可以是正方形。 RectF和Rect的区别是参数的类型不同，RectF的参数类型是float，Rect的参数类型是int。 drawRect(float left, float top, float right, float bottom, Paint paint)drawRect(float left, float top, float right, float bottom, Paint paint)drawRect(Rect r, Paint paint)drawRect( RectF rect, Paint paint) 也就是，可以在RectF或者Rect中指定好顶点坐标再传给drawRect，也可以在drawRect方法中直接指定顶点坐标。 12mRectF = new RectF(0, 0, getMeasuredWidth(), getMeasuredHeight());canvas.drawRect(mRectF, mPointPaint); 代码说明，第一行代码是在onSizeChanged重写方法中的，第二行代码是在onDraw方法中的。因为onDraw方法是会不断被调用的，不适合在里面创建对象。 圆角矩形圆角矩形是在矩形的基础上生成的。 drawRoundRect(RectF rect, float rx, float ry, Paint paint)drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint) rx是生成圆角的椭圆的X轴半径ry是生成圆角的椭圆的Y轴半径 1canvas.drawRoundRect(mRectF, getMeasuredWidth() / 4, getMeasuredHeight() / 4, mPointPaint); 画圆圆要指定圆心的坐标和半径的大小。 drawCircle(float cx, float cy, float radius, Paint paint) cx和cy分别是圆心的横坐标和纵坐标，radius为半径。 12canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, getMeasuredHeight() / 2 - mPointStrokeWidth, mPointPaint); 画椭圆椭圆是在矩形基础上生成的，以矩形的长为长轴，矩形的宽为短轴。特殊的，当长轴等于短轴时，椭圆就是圆。 drawOval(RectF oval, @NonNull Paint paint)drawOval(float left, float top, float right, float bottom, Paint paint) 1234mRectOvalF = new RectF(mPointStrokeWidth, mPointStrokeWidth, getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() / 2); canvas.drawOval(mRectOvalF, mPointPaint); 画弧弧是在椭圆上按一定角度截取的一部分。 drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) oval是椭圆基于的矩形顶点的矩阵，或者在方法中直接指定四个顶点，startAngle是截取的起始角度，sweepAngle是弧持续的角度，useCenter是否显示长短半径。 1canvas.drawArc(mRectOvalF, 0, 90, true, mPointPaint); 1canvas.drawArc(mRectOvalF, 0, 90, false, mPointPaint); Path在View的绘制过程中，有一个类叫做Path，Path可以帮助我们实现很多自定义形状的路径，特别是配合xfermode属性来使用的时候，可以实现很多效果。 moveTo路径开始绘制的点叫起始点坐标，默认是（0，0）。可以使用moveTo将绘制路径的起始点移动到某个位置。moveTo不进行绘制，一般用来移动画笔。 lineTolineTo用来绘制一条直线路径。 123mPath.moveTo(getMeasuredWidth()/ 2, getMeasuredHeight() / 2);mPath.lineTo(getMeasuredWidth(), getMeasuredHeight());canvas.drawPath(mPath, mPointPaint); 直线路径的起始点是(getMeasuredWidth()/ 2, getMeasuredHeight() / 2)，终点是(getMeasuredWidth(), getMeasuredHeight()) quadToquadTo用来画由一个控制点控制的贝塞尔曲线。 123mPath.moveTo(mPointStrokeWidth, getMeasuredHeight() / 2);mPath.quadTo(0, 0, getMeasuredWidth() / 2, mPointStrokeWidth);canvas.drawPath(mPath, mPointPaint); 起始点是(mPointStrokeWidth, getMeasuredHeight() / 2)，控制点是（0， 0），终点是（getMeasuredWidth() / 2, mPointStrokeWidth） cubicTocubicTo用来画由两个控制点控制的贝塞尔曲线。 1234mPath.moveTo(mPointStrokeWidth, getMeasuredHeight() / 2);mPath.cubicTo(0, 0, getMeasuredWidth() / 2, mPointStrokeWidth, getMeasuredWidth(), getMeasuredHeight() / 2);canvas.drawPath(mPath, mPointPaint); 起始点是(mPointStrokeWidth, getMeasuredHeight() / 2)，两个控制点是（0， 0）和（getMeasuredWidth() / 2, mPointStrokeWidth），终点是（getMeasuredWidth(), getMeasuredHeight() / 2）。 arcToarcTo用来画一条圆弧路径。与前面画圆弧一样的，圆弧是截取椭圆的一部分，而椭圆是基于矩形的。 1234mRectOvalF = new RectF(mPointStrokeWidth, mPointStrokeWidth, getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() / 2);mPath.arcTo(mRectOvalF, 0, 90, false);canvas.drawPath(mPath, mPointPaint); 和刚开始的圆弧参数定义一样，指定基于的矩形的四个顶点，startAngle截取的起始角度，sweepAngle弧持续的角度，useCenter是否显示长短半径。 Path的addArc、addRoundRect、addOval、addRect、addCircle它们实现的几何路径,可以自己尝试一下。 Path.Op在开头，mPointPaint首先设置画笔的样式为描边STROKE，后面为了更好看出Path.Op的效果会改为FILL填充。 1234567mRightBottomRectF = new RectF(getMeasuredWidth() / 2, getMeasuredHeight() /2, getMeasuredWidth() - mPointStrokeWidth, getMeasuredHeight() - mPointStrokeWidth);mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, getMeasuredHeight() / 2 - mPointStrokeWidth, Path.Direction.CCW);canvas.drawPath(mPath, mPointPaint);mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);canvas.drawPath(mPath1, mPointPaint); Path.Op.DIFFERENCE123456mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, getMeasuredHeight() / 2 - mPointStrokeWidth, Path.Direction.CCW);mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);mPath.op(mPath1, Path.Op.DIFFERENCE);canvas.drawPath(mPath, mPointPaint); Path.Op.INTERSECT123456mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, getMeasuredHeight() / 2 - mPointStrokeWidth, Path.Direction.CCW);mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);mPath.op(mPath1, Path.Op.INTERSECT);canvas.drawPath(mPath, mPointPaint); Path.Op.REVERSE_DIFFERENCE123456mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, getMeasuredHeight() / 2 - mPointStrokeWidth, Path.Direction.CCW);mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);mPath.op(mPath1, Path.Op.REVERSE_DIFFERENCE);canvas.drawPath(mPath, mPointPaint); Path.Op.XOR123456mPath.addCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, getMeasuredHeight() / 2 - mPointStrokeWidth, Path.Direction.CCW);mPath1.addRect(mRightBottomRectF, Path.Direction.CCW);mPath.op(mPath1, Path.Op.XOR);canvas.drawPath(mPath, mPointPaint); 最后，例子###（一）例子一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class MyDrawView extends View &#123; private Paint mGraphPaint; private Paint mPointPaint; private Paint mRectPaint; private RectF mRectF; private Paint mLinesPaint; private float mFPts[]; private float mFLinePts[]; private Path mPath; public MyDrawView(Context context) &#123; super(context); init(); &#125; public MyDrawView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public MyDrawView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private int mPointStrokeWidth; private void init() &#123; mGraphPaint = new Paint(); mGraphPaint.setColor(Color.GREEN); mGraphPaint.setStrokeWidth(5); mGraphPaint.setStyle(Paint.Style.STROKE); mGraphPaint.setShadowLayer(50, 30,30, Color.BLUE); mPointStrokeWidth = 20; mPointPaint = new Paint(); mPointPaint.setColor(Color.RED); mPointPaint.setStrokeWidth(mPointStrokeWidth); mPointPaint.setStyle(Paint.Style.FILL); mRectPaint = new Paint(); mRectPaint.setColor(Color.BLACK); mRectPaint.setStrokeWidth(5); mRectPaint.setStyle(Paint.Style.STROKE); mLinesPaint = new Paint(); mLinesPaint.setColor(Color.GRAY); mLinesPaint.setStrokeWidth(5); mLinesPaint.setStyle(Paint.Style.STROKE); mPath = new Path(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int widthResult = 100; int heightResult = 100; if(widthMode != MeasureSpec.AT_MOST) &#123; widthResult = widthSize; &#125; if(heightMode != MeasureSpec.AT_MOST) &#123; heightResult = heightSize; &#125; int resultSize = widthResult &gt; heightResult ? heightResult : widthResult; setMeasuredDimension(resultSize, resultSize); &#125; private int num = 30; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRectF = new RectF( num - mPointStrokeWidth / 2, num - mPointStrokeWidth / 2, getMeasuredWidth() - num + mPointStrokeWidth / 2, getMeasuredHeight() - num + mPointStrokeWidth / 2); mFPts = new float[] &#123; getMeasuredWidth() / 2, num, getMeasuredWidth() - num, getMeasuredHeight()/ 2, getMeasuredWidth() / 2 ,getMeasuredHeight() - num, num, getMeasuredHeight()/ 2 &#125;; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle( getMeasuredHeight() / 2, getMeasuredHeight() / 2, getMeasuredHeight() / 2 - num, mGraphPaint); canvas.drawRect(mRectF, mRectPaint); canvas.drawPoints(mFPts, mPointPaint); canvas.drawLines(mFPts, mLinesPaint); mPath.moveTo(mFPts[0], mFPts[1]); mPath.lineTo(mFPts[2], mFPts[3]); mPath.lineTo(mFPts[4], mFPts[5]); mPath.lineTo(mFPts[6], mFPts[7]); mPath.close(); canvas.drawPath(mPath, mLinesPaint); canvas.drawLine(mFPts[0], mFPts[1], mFPts[4], mFPts[5], mLinesPaint); canvas.drawLine(mFPts[2], mFPts[3], mFPts[6], mFPts[7], mLinesPaint); mPath.moveTo(mFPts[6], mFPts[7]); mPath.quadTo(mFPts[0], mFPts[1], mFPts[2], mFPts[3]); canvas.drawPath(mPath, mLinesPaint); mPath.moveTo(num - mPointStrokeWidth / 2, getMeasuredHeight() - num + mPointStrokeWidth / 2); mPath.cubicTo(mFPts[4], mFPts[5], getMeasuredWidth() - num + mPointStrokeWidth / 2, getMeasuredHeight() - num + mPointStrokeWidth / 2, mFPts[2], mFPts[3]); canvas.drawPath(mPath, mLinesPaint); &#125;&#125; 效果图： （二）例子二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class MyDrawView extends View &#123; private Paint mPaint; private int mOffsetX; private int mOffsetY; public MyDrawView(Context context) &#123; super(context); init(); &#125; public MyDrawView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public MyDrawView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStrokeWidth(5); mPaint.setStyle(Paint.Style.STROKE); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int widthResult = 100; int heightResult = 100; if(widthMode != MeasureSpec.AT_MOST) &#123; widthResult = widthSize; &#125; if(heightMode != MeasureSpec.AT_MOST) &#123; heightResult = heightSize; &#125; int resultSize = widthResult &gt; heightResult ? heightResult : widthResult; setMeasuredDimension(resultSize, resultSize); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mOffsetX = w / 2; mOffsetY = h / 2 - 55; &#125; private Point getHeartPoint(float angle) &#123; float t = (float) (angle / Math.PI); float x = (float) (19.5 * (16 * Math.pow(Math.sin(t), 3))); float y = (float) (-20 * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t))); return new Point(mOffsetX + (int) x, mOffsetY + (int) y); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float angle = 10; while (angle &lt; 180) &#123; Point p = getHeartPoint(angle); canvas.drawPoint(p.x, p.y, mPaint); angle = angle + 0.02f; &#125; &#125;&#125; 关于画笔和画布的使用，到这里是未完的，其他的效果，以后有时间再补充。谢谢大家的观看。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"初始Promise/A+规范","slug":"node-async-promise","date":"2018-02-02T02:19:32.000Z","updated":"2020-02-23T04:49:52.000Z","comments":true,"path":"2018/02/02/node-async-promise/","link":"","permalink":"http://zhangsunyucong.top/2018/02/02/node-async-promise/","excerpt":"前言这篇文章主要讲两个内容，一是，初步认识Promise，二是，Async模块和Async/Await的使用","text":"前言这篇文章主要讲两个内容，一是，初步认识Promise，二是，Async模块和Async/Await的使用 什么是PromisePromise表示一个异步操作的最终结果。一个Promise对象有一个then方法，then方法中返回一个Promise。 相关的概念 promise是一个包含了兼容promise规范then方法的对象或函数， thenable 是一个包含了then方法的对象或函数。 value 是任何Javascript值。 (包括 undefined, thenable, promise等). exception 是由throw表达式抛出来的值。 reason 是一个用于描述Promise被拒绝原因的值。 Promise的状态Promise有三种状态：pending, fulfilled 或 rejected。pending是等待执行状态，fulfilled是成功执行状态，rejected是失败执行状态。 Promise只能从pending到fulfilled或者从pending到rejected状态，当状态发生改变时，promise.then(onFulfilled, onRejected)方法将被调用。Promise可以使用resolve或者reject将value或者reason作为下一个Promise的第一个回调参数。 来个简单的Promise基本用法： 1234567891011121314var promise = new Promise(function(resolve, reject)&#123; //do something if(success)&#123; resolve(value); &#125; else &#123; reject(value); &#125;&#125;);promise.then(function(value)&#123; //成功时调用&#125;, function(value)&#123; //失败时调用&#125;); 上面的代码只是表示Promise用法的流程. 使用Promise/A+规范实现以下几个功能 上一步的结果可以作为下一步的参数 出现异常时，能够捕获到异常 可以在每一步进行流程控制 Promise的具体知识，可以参考这里 下面介绍Async模块和ES7的Async/Await的使用 Async模块Async模块的github地址：https://github.com/caolan/async/ 配置好node的环境后（具体过程，自己百度），安装Async模块 npm install –save async Async模块提供了很多关于集合，流程控制，工具方法，这里只体验几个常见的流程控制方法：series，parallel，waterfall，auto。其他方法的用法，可以查看官方文档：文档地址 series的使用 series(tasks, callback) tasks可以是数组或者对象 series是串行执行tasks中的任务，如果有一个任务执行返回了错误信息，则不再继续执行后面未执行的任务，并将结果以数组或者对象的形式传给callback。具体结果的格式由你定义tasks时使用的是数组还是对象。 1234567891011121314151617181920212223async.series([ function (callback) &#123; setTimeout(function () &#123; console.log(&quot;one&quot;); callback(null, &#x27;one&#x27;); &#125;, 300); &#125;, function (callback) &#123; setTimeout(function () &#123; console.log(&quot;two&quot;); callback(null, &#x27;two&#x27;); &#125;, 200); &#125;, function (callback) &#123; setTimeout(function () &#123; console.log(&quot;three&quot;); callback(null, &#x27;three&#x27;); &#125;, 100); &#125;], function (err, results) &#123; console.log(err); console.log(results);&#125;); 运行结果： onetwothreenull[ ‘one’, ‘two’, ‘three’ ] 当tasks是对象： 1234567891011121314151617181920212223242526async.series(&#123; one: function (callback) &#123; setTimeout(function () &#123; console.log(&quot;one&quot;); callback(null, &#x27;one&#x27;); &#125;, 300); &#125;, two: function (callback) &#123; setTimeout(function () &#123; console.log(&quot;two&quot;); callback(null, &#x27;two&#x27;); &#125;, 200); &#125;, three: function (callback) &#123; setTimeout(function () &#123; console.log(&quot;three&quot;); callback(null, &#x27;three&#x27;); &#125;, 100); &#125; &#125;, function (err, results) &#123; if(err) &#123; console.log(&quot;异常结束&quot; + &#x27;结果为：&#x27; + results); return; &#125; console.log(results); &#125;); 运行结果： onetwothree{ one: ‘one’, two: ‘two’, three: ‘three’ } 上面代码中，从上到下的函数开始执行时间是逐渐减小的，而运行结果的输出顺序是one，two，three，说明series是串行执行任务的。 将第二个任务的代码改为以下的样子： 123456function (callback) &#123; console.log(&quot;two&quot;); setTimeout(function () &#123; callback(&quot;errMsg&quot;, &#x27;two&#x27;); &#125;, 200);&#125; 运行的结果为： onetwoerrMsg[ ‘one’, ‘two’ ] 可以看到，当第二个任务返回了错误信息，则不会再继续执行后面未执行的任务 parallel的使用 parallel(tasks, callback) tasks可以是一个数组或者对象 parallel是并行执行多个任务，如果有一个任务执行返回了一个错误信息，则不再继续执行后面未执行的任务，并将结果以数组或者对象的形式传给callback。 1234567891011121314151617181920212223async.parallel([ function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;one&#x27;); callback(null, &#x27;one&#x27;); &#125;, 500); &#125;, function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;two&#x27;); callback(null, &#x27;two&#x27;); &#125;, 200); &#125;, function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;three&#x27;); callback(null, &#x27;three&#x27;); &#125;, 100); &#125; ], function (err, results) &#123; console.log(err); console.log(results); &#125;); 运行结果为： threetwoonenull[ ‘one’, ‘two’, ‘three’ ] 结果中的输出顺序是three,two,one，说明parallel是并行执行任务的。 同样，将第二个任务的代码改为：（数组定义tasks） 123456function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;two&#x27;); callback(&quot;errMsg&quot;, &#x27;two&#x27;); &#125;, 200);&#125;, 运行的结果为： threetwoerrMsg[ &lt;1 empty item&gt;, ‘two’, ‘three’ ]one 将第二个任务代码改为：（数组定义tasks） 123456function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;two&#x27;); callback(&quot;errMsg&quot;, &#x27;two&#x27;); &#125;, 200);&#125;, 将第三个任务代码改为：（数组定义tasks） 123456function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;three&#x27;); callback(null, &#x27;three&#x27;); &#125;, 200);&#125; 也就是，第三个的开始执行时间改成和出现错误信息的第二个任务的时间一样。 运行的结果为： twoerrMsg[ &lt;1 empty item&gt;, ‘two’ ]threeone 从结果中可以看出，当前面执行的未完成的任务会占一个位置，而后面未完成的任务不会占数组的位置。 parallelLimit(tasks, limit, callback) parallelLimit和parallel差不多，区别是它可以指定同时并行执行任务的最大数量。 1234567891011121314151617181920212223async.parallelLimit(&#123; one: function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;one&#x27;); callback(null, &#x27;one&#x27;); &#125;, 200); &#125;, two: function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;two&#x27;); callback(error, &#x27;two&#x27;); &#125;, 200); &#125;, three: function (callback) &#123; setTimeout(function() &#123; console.log(&#x27;three&#x27;); callback(null, &#x27;three&#x27;); &#125;, 100); &#125;&#125;, 2, function (err, results) &#123; console.log(err); console.log(results);&#125;); 运行的结果为： onetwoerrMsg{ one: ‘one’, two: ‘two’ }three 如果是tasks是数组时，运行的结果是： twoerrMsg[ &lt;1 empty item&gt;, ‘two’ ]one 由于同时并行执行任务的最大数量是2，由于第二个任务产生错误信息，第三个任务还没开始执行。另外如果要取最后回调结果中的值，对象定义tasks可能会更好。 waterfall的使用 waterfall(tasks, callback) tasks只能是数组类型 waterfall会串行执行tasks中的任务，前一个任务的结果可以作为下一个任务的参数。 1234567891011121314151617181920212223242526async.waterfall([ function (callback) &#123; console.log(&quot;one&quot;); setTimeout(function() &#123; callback(null, &#x27;one&#x27;, &#x27;two&#x27;); &#125;, 200); &#125;, function (arg1, arg2, callback) &#123; console.log(&quot;two&quot; + &#x27;参数：&#x27; + &quot;arg1是&quot; + arg1 + &quot;arg2是&quot; + arg2); setTimeout(function() &#123; callback(null, &#x27;three&#x27;); &#125;, 200); &#125;, function (arg3, callback) &#123; console.log(&quot;three&quot; + &#x27;参数：&#x27; + &quot;arg3是&quot; + arg3); setTimeout(function() &#123; callback(null, &#x27;done&#x27;, &#x27;done1&#x27;); &#125;, 200); &#125;], function (err, results) &#123; if(err) &#123; console.log(&quot;异常结束&quot; + &#x27;结果为：&#x27; + results); return; &#125; console.log(results);&#125;); 运行的结果是： onetwo参数：arg1是onearg2是twothree参数：arg3是threedone 输出的结果的顺序是one，two， three，是串行执行的。前一个任务的结果可以作为下一个任务的参数。 注意一下，代码中控制台输出的one，two，three代码是移到了定时器的外面。 auto的使用 auto(tasks, concurrencyopt, callback) auto可以串行和并行执行任务，可以定义任务之间的依赖关系。没有依赖关系的任务会尽可能快的开始并行执行，串行是由于任务的依赖关系而实现的。concurrencyopt指定的是并行执行任务的最大数量。tasks只能是对象类型。 123456789101112131415161718192021222324252627282930313233async.auto(&#123; task1: function(callback) &#123; setTimeout(function() &#123; console.log(&#x27;task1&#x27;); callback(null, &#x27;data&#x27;, &#x27;data1&#x27;); &#125;, 200); &#125;, task2: function(callback) &#123; setTimeout(function () &#123; console.log(&#x27;task2&#x27;); callback(null, &#x27;data2&#x27;); &#125;, 100) &#125;, task3: [&#x27;task1&#x27;, &#x27;task2&#x27;, function(results, callback) &#123; console.log(&#x27;task3&#x27;, JSON.stringify(results)); setTimeout(function () &#123; console.log(&#x27;task3&#x27;); callback(null, &#x27;data3&#x27;); &#125;, 200); &#125;], task4: [&#x27;task3&#x27;, function(results, callback) &#123; console.log(&#x27;task4&#x27;, JSON.stringify(results)); setTimeout(function () &#123; console.log(&#x27;task4&#x27;); callback(null, &#123;&#x27;task2&#x27;:results.task2, &#x27;task4&#x27;:&#x27;data4&#x27;&#125;); &#125;, 100); &#125;]&#125;, function(err, results) &#123; console.log(&#x27;err = &#x27;, err); console.log(&#x27;results = &#x27;, results);&#125;); 运行的结果是： task2task1task3 {“task2”:”data2”,”task1”:[“data”,”data1”]}task3task4 {“task2”:”data2”,”task1”:[“data”,”data1”],”task3”:”data3”}task4err = nullresults = { task2: ‘data2’, task1: [ ‘data’, ‘data1’ ], task3: ‘data3’, task4: { task2: ‘data2’, task4: ‘data4’ } } task1和task2是不依赖于任何其他任务的，它们会尽可能的开始，而且由于它们是并行执行的，task2的开始时间较短，所以task2比task1先开始。task3依赖于task1和task2，所以task3等到task1和task2执行完毕后再执行。task4依赖task3，所以task4要等到task3执行完毕后再执行。 ES7的Async/Await主要看它们的用法 1234567891011121314151617var task1 = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(&quot;result&quot;); &#125;, 1000); &#125;);&#125;;var excTask1 = async function () &#123; console.log(&quot;start&quot;); console.log(await task1()); console.log(&quot;end&quot;);&#125;;function awaitDemo() &#123; excTask1();&#125; 连续点击运行四次，运行的结果为： startstartstartstartresultendresultendresultendresultend async代表是一个async函数，await只能用在async函数中，await等待一个Promise的返回，直到Promise返回了才会继续执行await后面的代码。这里的Promise利用setTimeout模拟异步任务。 从输出结果中可以看出，每次执行都是到await时，就停止等待Promise的返回，后再继续执行await后面的代码。","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://zhangsunyucong.top/tags/node-js/"}]},{"title":"Android中的消息机制","slug":"android-handler","date":"2018-02-01T00:36:36.000Z","updated":"2020-02-22T12:12:12.000Z","comments":true,"path":"2018/02/01/android-handler/","link":"","permalink":"http://zhangsunyucong.top/2018/02/01/android-handler/","excerpt":"前言 Android中的消息机制是指线程之间的通信机制。我们都知道，如果我们在UI主线程中做耗时的操作而无法及时处理时，程序会弹出ANR全名Application Not Responding, 也就是”应用无响应”的对话框。 首先来一张图，从整体上来看一下android消息机制。 Handler：用于发送消息和处理消息MessageQueue: 一个先进先出的消息队列Looper：循环者，它不断的循环的遍历查询消息队列","text":"前言 Android中的消息机制是指线程之间的通信机制。我们都知道，如果我们在UI主线程中做耗时的操作而无法及时处理时，程序会弹出ANR全名Application Not Responding, 也就是”应用无响应”的对话框。 首先来一张图，从整体上来看一下android消息机制。 Handler：用于发送消息和处理消息MessageQueue: 一个先进先出的消息队列Looper：循环者，它不断的循环的遍历查询消息队列 Looper中会创建一个消息队列，并进入消息循环，不断的从消息队列中取出消息，然后分发消息给对应的消息处理函数，如果消息队列为空，它会进入阻塞等待，直到有新的消息到来，然后被唤醒。 源码分析Looper123456 private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 这就是Looper的创建函数，它创建了一个Looper实例并放到ThreadLocal中。ThreadLocal是一个线程共享和线程安全的，ThreadLocal变量在不同的线程中有不同的副本。 这里，首先检查线程是否有Looper，如果已经有，就报”Only one Looper may be created per thread”异常。也就是说一个线程只能有一个Looper，不能重复创建。 进入Looper的构造函数 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; Looper的构造函数中主要是创建了一个消息队列，和赋值当前线程变量。 开启消息循环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static void loop() &#123; //取出循环者 final Looper me = myLooper(); //开始循环之前，必须先创建循环者 if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; //从循环者中取出消息队列 final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); //进入循环，不断的从消息队列中取出消息，如果没有消息会进入阻塞状态 for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; //将消息分发给对应的handler处理 msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot; + Thread.currentThread().getName() + &quot;, h=&quot; + msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&#x27;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; //释放资源 msg.recycleUnchecked(); &#125;&#125; Looper#loop方法的工作，在代码中已经进行注释说明。 Looper#loop中会将消息分发给对应的handler处理。 1msg.target.dispatchMessage(msg); 现在我们进入handler。 Handler1Handler handler = new Handler(Looper.myLooper()); 首先看Handler的构造函数，可以知道Handler是怎么和Looper取得关联的。 1234567public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 主要为Handler的四个变量赋值，其中确定了Handler是和哪一个Looper关联，和Handler发送消息到对应的哪个消息队列。可以知道，一个Handler只有一个Looper和对应的MessageQueue。而不同的Handler可以共享同一个Looper和MessageQueue，这就看你在初始化Handler时与哪个Looper关联了。 Handler无参数的构造函数是和哪个Looper关联呢？ 123456789101112131415161718192021222324public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; //取出当前线程的循环者 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; Handler无参数的构造函数仍然主要是为那四个变量赋值。它会首先取出当前线程的消息循环者，如果线程没有循环者，会报一个异常。 发送消息到循环队列 1234567891011121314151617181920212223public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125; public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; sendMessage中会调用sendMessageDelayed，sendMessageDelayed再调用sendMessageAtTime，最后会调用enqueueMessage将消息入队。post开头的方法是调用相应send开头的方法的。 进入Handler#enqueueMessage 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 在分析Looper#loop时，其中有将消息的分发给相应的Handler处理的逻辑，而正是在第2行代码时，它们取得联系的。然后将消息放入Handler关联的Looper中的消息队列。 在MessageQueue#enqueueMessage中，消息入队时，如果消息队列是阻塞休眠状态，会唤醒消息队列。 123456if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked;&#125; 在Looper#loop中，会将消息分发给对应的Handler处理函数dispatchMessage处理 1msg.target.dispatchMessage(msg); 进入Handler#dispatchMessage 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; java.lang.Callback 123public interface Runnable &#123; public abstract void run();&#125; Handler#Callback 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 优先调用Message的callback接口，如果Handler有Callback，调用Callback，否则会调用handleMessage方法。 Handler#handleMessage 12public void handleMessage(Message msg) &#123;&#125; 这是一个空方法，具体的消息逻辑由我们自己定义。 到此，这个流程已经解释完毕 后话在非UI线程中只要找好时机也是可以更新UI的。这个会在源码再分析。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"Android中Activity的启动流程","slug":"android-activity-start-up","date":"2018-01-31T05:08:09.000Z","updated":"2020-02-22T12:05:40.000Z","comments":true,"path":"2018/01/31/android-activity-start-up/","link":"","permalink":"http://zhangsunyucong.top/2018/01/31/android-activity-start-up/","excerpt":"前言在这篇文章中，将会基于android 26源码上分析Activity从启动到显示到屏幕和Decorview添加到Window中的过程。另外在本文中，省略了很多内容，目的只是从源码中找到一条启动的线索。迟点再补充上流程图。 从startActivity开始说起在应用层开发时，Acitvity跳转会写出下面的代码： 123456public static void startAtcivity(BaseActivity activity) &#123; if(activity != null) &#123; Intent intent = new Intent(activity, HomeAcivity.class); activity.startActivity(intent); &#125; &#125;","text":"前言在这篇文章中，将会基于android 26源码上分析Activity从启动到显示到屏幕和Decorview添加到Window中的过程。另外在本文中，省略了很多内容，目的只是从源码中找到一条启动的线索。迟点再补充上流程图。 从startActivity开始说起在应用层开发时，Acitvity跳转会写出下面的代码： 123456public static void startAtcivity(BaseActivity activity) &#123; if(activity != null) &#123; Intent intent = new Intent(activity, HomeAcivity.class); activity.startActivity(intent); &#125; &#125; 首先看下activity的继承关系： 第一张图，知道activity是context的子类，第二张图，我们可以知道各种activity的关系。另外会写一片文章，介绍context。 现在我们进入activity#startActivity 123456789101112131415@Overridepublic void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125; 接着调用activity#startActivityForResult 1234567891011121314151617181920public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); //1、Instrumentation Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; ... &#125; else &#123; ... &#125;&#125; 在1、中，出现了Instrumentation，并调用了execStartActivity方法进入Instrumentation#execStartActivity 123456789101112131415161718192021222324252627282930313233public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ... if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; ... &#125; &#125; &#125; try &#123; ... //1、进入ActivityManagerService中 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //2、检查创建actiity过程是否产生了异常 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125; 在1、中，出现了ActivityManager。取到IActivityManager，这里有涉及binder机制，ActivityManager.getService()得到的就是ActivityManagerService，ActivityManagerService实现了IActivityManager.Stub，而ActivityManager中有IActivityManager.Stub.asInterface的远程调用。ActivityManager#getService 12345678910111213 public static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125;private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 在2、中，Instrumentation#checkStartActivityResult方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** @hide */public static void checkStartActivityResult(int res, Object intent) &#123; if (!ActivityManager.isStartResultFatalError(res)) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) //1、出现没有注册异常 throw new ActivityNotFoundException( &quot;Unable to find explicit activity class &quot; + ((Intent)intent).getComponent().toShortString() + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;); throw new ActivityNotFoundException( &quot;No Activity found to handle &quot; + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException(&quot;Not allowed to start activity &quot; + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( &quot;PendingIntent is not an activity&quot;); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( &quot;Starting under voice control not allowed for: &quot; + intent); case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startVoiceActivity does not match active session&quot;); case ActivityManager.START_VOICE_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start voice activity on a hidden session&quot;); case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startAssistantActivity does not match active session&quot;); case ActivityManager.START_ASSISTANT_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start assistant activity on a hidden session&quot;); case ActivityManager.START_CANCELED: throw new AndroidRuntimeException(&quot;Activity could not be started for &quot; + intent); default: throw new AndroidRuntimeException(&quot;Unknown error code &quot; + res + &quot; when starting &quot; + intent); &#125;&#125; 这是检查在启动activity过程中，可能出现的异常。比如，启动的Acitivity没有在AndroidManifest.xml中注册，会出现代码中1、的异常。 继续，回到在execStartActivity的1、进入ActivityManagerService#startActivity 123456789101112131415161718192021222324@Overridepublic int startActivity(IBinder whoThread, String callingPackage, Intent intent, String resolvedType, Bundle bOptions) &#123; checkCaller(); int callingUser = UserHandle.getCallingUserId(); TaskRecord tr; IApplicationThread appThread; synchronized (ActivityManagerService.this) &#123; tr = mStackSupervisor.anyTaskForIdLocked(mTaskId); if (tr == null) &#123; throw new IllegalArgumentException(&quot;Unable to find task ID &quot; + mTaskId); &#125; //1、IApplicationThread appThread = IApplicationThread.Stub.asInterface(whoThread); if (appThread == null) &#123; throw new IllegalArgumentException(&quot;Bad app thread &quot; + appThread); &#125; &#125; //2、ActivityStarter return mActivityStarter.startActivityMayWait(appThread, -1, callingPackage, intent, resolvedType, null, null, null, null, 0, 0, null, null, null, bOptions, false, callingUser, null, tr, &quot;AppTaskImpl&quot;);&#125; 在1、处，出现了IApplicationThread，这里涉及到了binder机制，IApplicationThread的实现是在ActivityThread中的内部类ApplicationThread ActivityThread#ApplicationThread 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129 private class ApplicationThread extends IApplicationThread.Stub &#123; ... private void updatePendingConfiguration(Configuration config) &#123; ... &#125; public final void schedulePauseActivity(IBinder token, boolean finished, ... &#125; public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) &#123; ... &#125; public final void scheduleWindowVisibility(IBinder token, boolean showWindow) &#123; ... &#125; ... public final void scheduleResumeActivity(IBinder token, int processState, boolean isForward, Bundle resumeArgs) &#123; ... &#125; public final void scheduleSendResult(IBinder token, List&lt;ResultInfo&gt; results) &#123; ... &#125; @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; ... &#125; @Override public final void scheduleRelaunchActivity(IBinder token, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, int configChanges, boolean notResumed, Configuration config, Configuration overrideConfig, boolean preserveWindow) &#123; ... &#125; public final void scheduleNewIntent( List&lt;ReferrerIntent&gt; intents, IBinder token, boolean andPause) &#123; ... &#125; public final void scheduleDestroyActivity(IBinder token, boolean finishing, int configChanges) &#123; ... &#125; public final void scheduleReceiver(Intent intent, ActivityInfo info, CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras, boolean sync, int sendingUser, int processState) &#123; ... &#125; ... public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; ... &#125; public final void scheduleBindService(IBinder token, Intent intent, boolean rebind, int processState) &#123; ... &#125; public final void scheduleUnbindService(IBinder token, Intent intent) &#123; ... &#125; public final void scheduleServiceArgs(IBinder token, ParceledListSlice args) &#123; List&lt;ServiceStartArgs&gt; list = args.getList(); ... &#125; public final void scheduleStopService(IBinder token) &#123; ... &#125; public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial) &#123;... &#125; ... public void scheduleConfigurationChanged(Configuration config) &#123; updatePendingConfiguration(config); ... &#125; ... public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; ... &#125; ... @Override public void scheduleActivityConfigurationChanged( IBinder token, Configuration overrideConfig) &#123; ... &#125; ... &#125; 在ApplicationThread中，有很多与Activity，service，Application生命周期有关的方法。其中scheduleLaunchActivity()应该就是负责Activity创建的。 ActivityManagerService#startActivity的2、处，调用了ActivityStarter的startActivityMayWait方法，它又调用了startActivityLocked方法 12345678910111213141516171819202122232425262728293031323334353637383940414243 1、 int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, ... mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, container, inTask); ... return mLastStartActivityResult; &#125; 2、private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; ... return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask, outActivity); &#125; 3、 private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, ... try &#123; mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); &#125; finally &#123; ... &#125; ... return result; &#125; 在3、中，调用了startActivityUnchecked方法，startActivityUnchecked又调用了ActivityStackSupervisor#resumeFocusedStackTopActivityLocked方法， ActivityStackSupervisor#resumeFocusedStackTopActivityLocked 1234567891011121314boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; else if (r.state == RESUMED) &#123; // Kick off any lingering app transitions form the MoveTaskToFront operation. mFocusedStack.executeAppTransition(targetOptions); &#125; return false;&#125; 上面方法中，接着调用ActivityStack的resumeTopActivityUncheckedLocked方法，ActivityStack#resumeTopActivityUncheckedLocked 123456789101112131415161718boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don&#x27;t even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125;... return result;&#125; 接着调用resumeTopActivityInnerLocked方法，在resumeTopActivityInnerLocked中调用ActivityStackSupervisor的startSpecificActivityLocked方法 ActivityStackSupervisor#startSpecificActivityLocked 1234567891011121314151617181920void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; ... if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) &#123; ... &#125; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; ... &#125; &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true);&#125; 方法中调用了realStartActivityLocked方法，它里面有下面的代码： ActivityStackSupervisor#realStartActivityLocked 123456789app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global and // override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); 上面的app.thread就是ApplicationThread,并调用scheduleLaunchActivity。 上面曾经说过ApplicationThread是AcitivityThread的内部类。 进入ApplicationThread的scheduleLaunchActivity方法，它最后会发送一个消息给名为H的handler 1sendMessage(H.LAUNCH_ACTIVITY, r); H.LAUNCH_ACTIVITY的消息处理逻辑是： 123456789case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 调用handleLaunchActivity方法。在handleLaunchActivity主要是分别调用performLaunchActivity和handleResumeActivity方法 进入ActivityThread#performLaunchActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;); //1、收集创建Acitivity的信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ... //2、创建Context的实现者ContextImpl ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; //3、通Instrumentation创建activity java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); ... &#125; catch (Exception e) &#123; ... &#125; try &#123; //4、创建Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) &#123; ... appContext.setOuterContext(activity); //5、调用activity的attach方法 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); ... if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; //6、调用Activity的OnCreate方法 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... //7、调用Activity的OnStart方法 if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; ... &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; return activity; &#125; 在3、中，会调用Instrumentation#newActivity 123456public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance(); &#125; 可以看出是通过类加载器通过反射创建Activity实例的。 在4、中，调用了LoadedApk#makeApplication方法， 12app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); makeApplication方法中，和newActivity差不多，也是由Instrumentation的newApplication方法，通过反射创建Application的 5、中调用Acitivty的attach方法， Acitivty#attach 12345678910111213141516171819202122232425262728293031final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); ... mUiThread = Thread.currentThread(); ... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode);&#125; 在该方法中，主要是会创建PhoneWindow。 在6和7中，分别调用了acitivity的生命周期方法，onCreate和onStart。 已经分析了在handleLaunchActivity的performLaunchActivity方法。现在分析handleLaunchActivity的handleResumeActivity，在handleResumeActivity中会调用acitivity的生命周期方法onResume和将Decorview添加到Window中，并在makeVisible中显示出来。 Activity#handleResumeActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (!checkAndUpdateLifecycleSeq(seq, r, &quot;resumeActivity&quot;)) &#123; return; &#125; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; //1、会调用Acitvity的onResume生命周期方法 // TODO Push resumeArgs into the activity for consideration r = performResumeActivity(token, clearHide, reason); if (r != null) &#123; final Activity a = r.activity; ... if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManager.getService().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); //2、设置decor不可见 decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; //3、将Decorviewt添加到Window wm.addView(decor, l); &#125; else &#123; // The activity will get a callback for this &#123;@link LayoutParams&#125; change // earlier. However, at that time the decor will not be set (this is set // in this method), so no action will be taken. This call ensures the // callback occurs with the decor set. a.onWindowAttributesChanged(l); &#125; &#125; // If the window has already been added, but during resume // we started another activity, then don&#x27;t yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; &#125; // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r, false /* force */); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; if (r.newConfig != null) &#123; performConfigurationChangedForActivity(r, r.newConfig); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.activity.mCurrentConfig); r.newConfig = null; &#125; if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) &#123; l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) &#123; ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); &#125; &#125; r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; //4、调用makeVisible r.activity.makeVisible(); &#125; &#125; ... &#125; else &#123; ... &#125; &#125; 在1、处的performResumeActivity方法中，会调用以下代码： 1r.activity.performResume(); 即调用activity的onResume生命周期方法。 在2、中，设置了Decorview为不可见在3、中，将Decorview添加到window中，由于2中设置了Decorview为不可见，这时view还看不到。在4、中，调用Activity的makeVisible方法。Activity#makeVisible 12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; 上面代码中，将Decorview设置为可见的。 剩下问题在上面过程中的哪里开始涉及视图绘制。迟点再看。分析追溯到Zygote中。本篇文章的排版还有点乱。 优秀文章：http://blog.csdn.net/dd864140130/article/details/60466394","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"Android中view的位置坐标和view的滑动","slug":"android-view-positon-and-scroll","date":"2018-01-25T01:57:38.000Z","updated":"2020-02-22T12:16:58.000Z","comments":true,"path":"2018/01/25/android-view-positon-and-scroll/","link":"","permalink":"http://zhangsunyucong.top/2018/01/25/android-view-positon-and-scroll/","excerpt":"view体系结构？","text":"view体系结构？ View是Android中界面层控件的一个抽象。从上图中可以看出控件层的继承关系，TextView是View的直接子类，LinearLayout是ViewGroup的直接子类，ViewGroup是View的直接子类，所以TextView和LinearLayout都是一个view，都直接或者间接继承于View。View是所有控件和控件组的子类。 View相关的坐标 Android手机屏幕的坐标原点（0，0）在屏幕的左上角，向右为x轴的正方向，向下为y轴的正方向。 View的位置由四个顶点确定，且View的位置都是相对于父控件来说的。 View的四个顶点分别对应于View类中的mLeft，mTop，mRight，mBottom，它们在View中都提供了相应的get方法。 View的坐标和宽度为：左上角坐标为（left， top），右下角坐标为（right，bottom）宽度 = mRight - mLeft高度 = mBottom - mTop 相应的，改变View位置（四个顶点）的方法有： （1）View的layout(int left, int top, int right, int bottom)（2）水平方向：offsetLeftAndRight，改变mLeft和mRight——-垂直方法：offsetTopAndBottom，改变mTop和mBottom 关于View的坐标，Android也提供了x，y，translationX，translationY参数，它们也是相对于父控件而言的，与上面的参数有以下关系： x = mLeft + translationXy = mTop + translationY刚开始时，translationX和translationY的默认值都是0。 Android中的scrollX和scrollY，它们和View的边缘以及View内容的边缘有关，产生于scrollTo和scrollBy。 当view内容的上边缘在view的上边缘的上面，scrollY为正值，反之为负值当view内容的左边缘在view的左边缘的左面，scrollX为正值，反之为负值 MotionEvent相关的坐标MotionEvent相关的坐标是用于表示事件MotionEvent发生的坐标，有getX，getY，getScrollX，getScrollY。 相对于所在控件，有event.getX()和event.getY()相对于屏幕，有event.getScrollX()和event.getScrollY() 实现View滑动的几种方法 （1）使用View的scrollTo和scrollBy（2）使用View的布局参数，改变外边距（3）使用View的layout、offsetLeftAndRight和offsetTopAndBottom方法（4）使用动画 (1) 使用View的scrollTo和scrollByscrollTo和scrollBy都是View中的方法，scrollTo是view的绝对运动，scrollBy是相对于view当前位置的相对运动。它们滑动的是View的内容。 从源码分析，scrollTo和scrollBy的关系 View#scrollTo 12345678910111213public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125; View#scrollBy 123public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; 从上面可以看出，scrollTo是直接赋值给mScrollX和mScrollY，并回调onScrollChanged。在scrollBy中是在原来值的基础上相加然后调用scrollTo的，即是相对于view当前位置的。 （2）使用View的布局参数，改变外边距这种方法就是通过设置View布局参数的Margin值实现的。如： 123MarginLayoutParams mlp = (MarginLayoutParams)view.getLayoutParams();mlp.leftMargin =+ 100;view.setLayoutParams(mlp); 向右滑动100个像素，但滑动效果几乎是瞬间完成的。 （3）使用View的layout、offsetLeftAndRight和offsetTopAndBottom方法上面，我们已经知道View的位置是由四个顶点决定的，通过改变它的顶点坐标就可以改变view的位置。View的layout、offsetLeftAndRight和offsetTopAndBottom都可以直接改变view顶点的值。 （4）使用动画使用动画是使用位移动画，改变translationX和translationY的值。位移动画要注意View动画和属性动画的区别，view动画并不能改变view的位置。属性动画是在Android3.0之后引入的，为了兼容之前的系统版本，可以使用nineoldandroids库。 实现弹性的滑动 （1）使用动画实现滑动（2）使用scroller （1）使用动画实现滑动动画本来就是在一定时间内完成的，所以使用动画可以实现弹性的滑动。 （2）使用scrollerscroller实现弹性滑动的原理和动画是差不多的，都是在一定的时间内，从初始值到终值点，不断的改变scrollX和scrollY。 scroller实现滑动的经典代码段 12345678910111213141516171819202122//1、初始化ScrollermScroller = new Scroller(context);//2、设置初始值、终点值、滑动的时间 public void smoothScrollTo(int destX,int destY)&#123; int scrollX=getScrollX(); int delta=destX-scrollX; //1000秒内滑向destX mScroller.startScroll(scrollX,0,delta,0,1000); invalidate();&#125;//3、重写computeScroll@Overridepublic void computeScroll() &#123; super.computeScroll(); if(mScroller.computeScrollOffset())&#123; ((View) getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); //通过不断的重绘不断的调用computeScroll方法 invalidate(); &#125; &#125; scroller是如何不断的改变scrollX和scrollY呢？ 首先看View#startScroll 12345678910111213public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; mMode = SCROLL_MODE; mFinished = false; mDuration = duration; mStartTime = AnimationUtils.currentAnimationTimeMillis(); mStartX = startX; mStartY = startY; mFinalX = startX + dx; mFinalY = startY + dy; mDeltaX = dx; mDeltaY = dy; mDurationReciprocal = 1.0f / (float) mDuration;&#125; startScroll其实只是设置滑动的始点值和根据滑动的距离计算终点值、及滑动的总时间等。接着就调用invalidate方法重绘，重绘会调用view的draw方法。在view的draw方法中会调用computeScroll方法。 进入computeScroll方法，首先是看computeScrollOffset源码Scroller#computeScrollOffset 1234567891011121314151617181920212223242526272829303132333435public boolean computeScrollOffset() &#123; //返回false，结束 if (mFinished) &#123; return false; &#125; //计算消逝的时间 int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime); if (timePassed &lt; mDuration) &#123; switch (mMode) &#123; case SCROLL_MODE: //有点类似插值器，根据消逝的事件计算百分比 final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal); //有点类似估值器，根据消逝的时间百分比计算实际值 mCurrX = mStartX + Math.round(x * mDeltaX); mCurrY = mStartY + Math.round(x * mDeltaY); break; case FLING_MODE: ... if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123; mFinished = true; &#125; break; &#125; &#125; else &#123; mCurrX = mFinalX; mCurrY = mFinalY; mFinished = true; &#125; return true;&#125; computeScrollOffset判断滑动是否结束和计算滑动的值，而在computeScroll中接着会不断获取计算后的滑动值，使用scrollTo进行滑动，然后再调用invalidate方法重绘，即再调用view的draw方法。在view的draw方法中会调用computeScroll方法，如此反复…","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangsunyucong.top/tags/Android/"}]},{"title":"自定义波纹WaveView","slug":"android-wave-view","date":"2018-01-18T07:48:15.000Z","updated":"2020-02-23T05:09:40.000Z","comments":true,"path":"2018/01/18/android-wave-view/","link":"","permalink":"http://zhangsunyucong.top/2018/01/18/android-wave-view/","excerpt":"效果图首先直接上效果图： 源码和分析简单分析，首先画一个半径固定为R的颜色填充的圆，再画一些半径从R逐渐增大的圆就形成圆形不断的向外扩大的效果，并且这些圆形的透明度是与半径的相关的。最后在圆形的中心画文本。","text":"效果图首先直接上效果图： 源码和分析简单分析，首先画一个半径固定为R的颜色填充的圆，再画一些半径从R逐渐增大的圆就形成圆形不断的向外扩大的效果，并且这些圆形的透明度是与半径的相关的。最后在圆形的中心画文本。 自定义属性 attrs.xml 123456&lt;declare-styleable name=&quot;waveView&quot;&gt; &lt;attr name=&quot;text&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;color&quot; format=&quot;color&quot;/&gt;&lt;/declare-styleable&gt; text是圆形中心的文本，textSize是文本的大小，textColor是文本的颜色，color是WaveView的颜色。 WaveView.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class WaveView extends View &#123; private int mRippleViewWidth; private int mRippleViewRadius; private Paint mRipplePaint = new Paint(); private boolean isStartRipple; private int rippleFirstRadius = 0; private int rippleSecondRadius = -33; private int rippleThirdRadius = -66; private Paint textPaint = new Paint(); private String mText=&quot;扫描中...&quot;; private int mDefaultColor = Color.parseColor(&quot;#54FF9F&quot;); private int mColor = mDefaultColor; private int mDefaultTextColor = Color.WHITE; private int mTextColor = mDefaultTextColor; private float mDefaultTextSize = 26; private float mTextSize = mDefaultTextSize; private int mDefaultWidth = 300; private Handler handler = new Handler(); /** * @param context */ public WaveView(Context context) &#123; super(context); init(context); &#125; /** * @param context * @param attrs */ public WaveView(Context context, AttributeSet attrs) &#123; super(context, attrs); getAttrs(context, attrs); init(context); &#125; /** * @param context * @param attrs * @param defStyleAttr */ public WaveView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); getAttrs(context, attrs); init(context); &#125; private void getAttrs(Context context, AttributeSet attrs) &#123; TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.waveView); for(int i = 0; i &lt; a.getIndexCount(); i++) &#123; int attrIndex = a.getIndex(i); switch (attrIndex) &#123; case R.styleable.waveView_text: mText = a.getString(attrIndex); break; case R.styleable.waveView_textColor: mTextColor = a.getColor(attrIndex, mDefaultTextColor); break; case R.styleable.waveView_textSize: mTextSize = a.getDimension(attrIndex, mDefaultTextSize); break; case R.styleable.waveView_color: mColor = a.getColor(attrIndex, mDefaultColor); break; &#125; &#125; a.recycle(); &#125; private void init(Context context) &#123; mRipplePaint.setColor(mColor); mRipplePaint.setAntiAlias(true); mRipplePaint.setStyle(Paint.Style.FILL); textPaint.setTextSize(mTextSize); textPaint.setAntiAlias(true); textPaint.setStyle(Paint.Style.FILL); textPaint.setColor(mTextColor); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); if(handler != null) &#123; handler.removeCallbacksAndMessages(null); handler = null; &#125; &#125; private Runnable mRunnable = new Runnable() &#123; @Override public void run() &#123; invalidate(); if (isStartRipple) &#123; rippleFirstRadius++; if (rippleFirstRadius &gt; 100) &#123; rippleFirstRadius = 0; &#125; rippleSecondRadius++; if (rippleSecondRadius &gt; 100) &#123; rippleSecondRadius = 0; &#125; rippleThirdRadius++; if (rippleThirdRadius &gt; 100) &#123; rippleThirdRadius = 0; &#125; &#125; if(handler != null) &#123; handler.postDelayed(mRunnable, 1); &#125; &#125; &#125;; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // TODO Auto-generated method stub super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = 0; int measureHeight = 0; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); measureWidth = widthSize; measureHeight = heightSize; if(widthMode == MeasureSpec.AT_MOST) &#123; measureWidth = mDefaultWidth; &#125; if(heightMode == MeasureSpec.AT_MOST) &#123; measureHeight = mDefaultWidth; &#125; mRippleViewWidth = Math.min(measureWidth, measureHeight); float f1 = 7 * mRippleViewWidth / 20; mRippleViewRadius = (mRippleViewWidth - (2*(int)(Math.floor(f1))))/2 ; setMeasuredDimension(mRippleViewWidth, mRippleViewWidth); &#125; @Override protected void onDraw(Canvas canvas) &#123; // TODO Auto-generated method stub super.onDraw(canvas); if (isStartRipple) &#123; float f1 = 7 * mRippleViewWidth / 20; mRipplePaint.setAlpha(255); //固定半径的圆形 canvas.drawCircle(mRippleViewWidth / 2, mRippleViewWidth / 2, mRippleViewRadius, mRipplePaint); //第一个扩散的圆形 int i1 = (int) (220.0F - (220.0F - 0.0F) / 100.0F * rippleFirstRadius); mRipplePaint.setAlpha(i1); canvas.drawCircle(mRippleViewWidth / 2, mRippleViewWidth / 2, mRippleViewRadius + f1 * rippleFirstRadius / 100.0F - 2, mRipplePaint); //第二个扩散的圆形 if (rippleSecondRadius &gt;= 0) &#123; int i3 = (int) (220.0F - (220.0F - 0.0F) / 100.0F * rippleSecondRadius); mRipplePaint.setAlpha(i3); canvas.drawCircle(mRippleViewWidth / 2, mRippleViewWidth / 2, mRippleViewRadius + f1 * rippleSecondRadius / 100.0F - 2, mRipplePaint); &#125; //第三个扩散的圆形 if (rippleThirdRadius &gt;= 0) &#123; int i2 = (int) (220.0F - (220.0F - 0.0F) / 100.0F * rippleThirdRadius); mRipplePaint.setAlpha(i2); canvas.drawCircle(mRippleViewWidth / 2, mRippleViewWidth / 2, mRippleViewRadius + f1 * rippleThirdRadius / 100.0F -2, mRipplePaint); &#125; &#125; float length = textPaint.measureText(mText); canvas.drawText(mText, (mRippleViewWidth - length) / 2, mRippleViewWidth / 2 + 5, textPaint); &#125; public void stratWave() &#123; isStartRipple = true; handler.post(mRunnable); &#125;&#125; 一共画了三个不断扩散的圆形。用了R的二十分之六的宽度作为第一个固定圆形的半径，三个圆形从固定半径向两边增大至R。三个圆形从里到外的时间相隔33个单位，透明度是从220递减到0。减去2是为了扩散的效果更好看一点。 布局 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.christmas.stickyheaderview.WaveView android:id=&quot;@+id/rippleview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_centerInParent=&quot;true&quot; app:text=&quot;正在扫描中啦&quot;/&gt; &lt;/LinearLayout&gt; WaveActivity.java中使用 12mWaveView =(WaveView) findViewById(R.id.rippleview);mWaveView.stratWave();","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"Androiod中View的工作原理","slug":"view-meassure","date":"2018-01-15T07:14:46.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2018/01/15/view-meassure/","link":"","permalink":"http://zhangsunyucong.top/2018/01/15/view-meassure/","excerpt":"前言这篇文章主要讲解view的工作原理中的三大流程，包括测量流程，布局流程，绘制流程。这些都是自定义控件的基础。下面先对三大流程的职责做简要的概述： 测量流程确定了控件的测量的大小；布局流程确定了控件在父控件中的四个位置的坐标和控件的实际大小；绘制流程负责控件的绘制并显示在屏幕上。 view的绘制流程是从哪里开始的？View的绘制流程是从ViewRoot的performTraversals开始的。在performTraversals经过一堆的逻辑，会分别调用performMeasure，performLayout，performDraw。然后在view树中，先后调用一下的方法：","text":"前言这篇文章主要讲解view的工作原理中的三大流程，包括测量流程，布局流程，绘制流程。这些都是自定义控件的基础。下面先对三大流程的职责做简要的概述： 测量流程确定了控件的测量的大小；布局流程确定了控件在父控件中的四个位置的坐标和控件的实际大小；绘制流程负责控件的绘制并显示在屏幕上。 view的绘制流程是从哪里开始的？View的绘制流程是从ViewRoot的performTraversals开始的。在performTraversals经过一堆的逻辑，会分别调用performMeasure，performLayout，performDraw。然后在view树中，先后调用一下的方法： performMeasure，measure onMeasureperformLayout，layout, onLayoutperformDraw, draw, onDraw, dispatchDraw(绘制子view) ViewRoot的实现类是ViewRootImpl，在ActivityThread中创建。 MeasureSpecMeasureSpec是view的测量规格，是一个int数值。在java中的int是32位的，所以MeasureSpec可以利用32位的一个数值来表示view的大少size和规格mode。在ViewRootImpl.java中提供了MeasureSpec组合和分解的方法。MeasureSpec是ViewRootImpl.java中的一个公开静态内部类，源码如下： ViewRootImpl#MeasureSpec 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** @hide */ @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode &#123;&#125; /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; ... @MeasureSpecMode public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; ...&#125; 在上面，MODE_SHIFT为什么是30？因为它是使用高2位表示mode，低30为表示size。MODE_MASK为0x3，二进制表示是 10000 0000 0000 0000 0000 0000 0000 0011 它左移30位后为 11100 0000 0000 0000 0000 0000 0000 0000 由MODE_MASK理解组合makeMeasureSpec中的(size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK) 12345678910size &amp; ~MODE_MASK，就是size &amp; ~MODE_MASK = size &amp; 0011 1111 1111 1111 1111 1111 1111 1111当size=32时，100000 &amp; ~MODE_MASK = 100000 &amp; 0011 1111 1111 1111 1111 1111 1111 1111 = 0000 0000 0000 0000 0000 0000 0010 0000 = 32同理可知mode最后做与运算，将它们相加 从源码中可以看出，mode有UNSPECIFIED，EXACTLY，AT_MOST。其中UNSPECIFIED等于0，AT_MOST是小于0，EXACTLY等于0。 MeasureSpec的创建和测量流程MeasureSpec是由父容器的约束和布局参数LayoutParams共同决定的。它在DecorView和普通view中创建也是不一样的。DecorView的父容器是Window，所以DecorView的MeasureSpec由窗口大小和布局参数共同决定的。普通view是由父容器的MeasureSpec和布局参数共同决定的。 （1）在DecorView中 ViewRootImpl#measureHierarchy 12childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); 123456789101112131415161718192021ViewRootImpl#getRootMeasureSpecprivate static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&#x27;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec; &#125; 当view设置MATCH_PARENT时，measureSpec的mode是MeasureSpec.EXACTLY，size是windowSize窗口大小。当view设置WRAP_CONTENT时，measureSpec的mode是MeasureSpec.AT_MOST，size是windowSize窗口大小。当view设置具体大小时，measureSpec的mode是MeasureSpec.EXACTLY，size是view设置的具体大小。 （2）在普通view中 ViewGroup#measureChildWithMargins 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 在ViewGroup#getChildMeasureSpec 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&#x27;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&#x27;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 在getChildMeasureSpec中列出了在父容器MeasureSpec和view的布局参数下创建MeasureSpec的各种情况。得到MeasureSpec后，在measureChildWithMargins中将它传递给child的measure方法。在measure方法再传给onMeasure方法。这就是onMeasure方法中两个参数的来源。 View#onMeasure 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; View#setMeasuredDimension中会调用setMeasuredDimensionRaw方法View#setMeasuredDimensionRaw 123456private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; &#125; 到这里就已经确定的view测量的大小。通过getMeasuredWidth()和getMeasuredHeight()就可以得到它们的值。 View#getSuggestedMinimumWidth 123protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; 这里是说，控件是否设置了背景和最小大小。对应于android:background和android:minWidth。 View#getDefaultSize 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; UNSPECIFIED据说一般是用于表示内部正处于测量的状态。在普通view中我们只要关注AT_MOST和EXACTLY。当view设置match_parent和具体大小时，是EXACTLY，wrap_content时是AT_MOST。为什么会是这样？可以看getChildMeasureSpec方法中各种情况。 所以当我们自定义view时，如果不处理AT_MOST情况，即wrap_content时，控件的大少就是父控件的大小。EXACTLY是可以正常被getDefaultSize处理的。 在ViewGroup中是没有重写onMeasure方法的，因为ViewGroup的大小还与ViewGroup的具体的布局特性有关。如LinearLayout和RelativeLayout的onMeasure不一样的。所以自定义ViewGroup时，要重写onMeasure方法。 但是，ViewGroup提供了测量子view的方法的，measureChildren和measureChildWithMargins，measureChild。 ViewGroup#measureChildren 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; ViewGroup#measureChild 1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; ViewGroup#measureChildWithMargins 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; measureChild在measureChildren被循环遍历子view时调用。measureChildren和measureChildWithMargins的区别是，measureChildren是减去父控件的padding，而measureChildWithMargins减去了父控件的padding和view的margin。这直接影响了测量的大小是否包含了padding和margin。也就是view可以设置的最大大小是减去父控件的padding和view的内边距。 综上所述，在view中，就可以确定view的大小，提供了默认的onMeasure方法，但是默认的onMeasure方法不能正确处理AT_MOST（Wrap_content）的情况。在ViewGroup中，因为ViewGroup的具体大小和ViewGroup的布局特性有关，自定义ViewGroup要重写该方法。 布局流程View#layout 12345678910111213141516171819public void layout(int l, int t, int r, int b) &#123; ... int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ... &#125; ...&#125; 在layout中分别调用了setFrame或者setOpticalFrame和onLayout。 setFrame或者setOpticalFrame中，赋值给mLeft，mTop，mRight，mBottom，确定了view的四个顶点，通过它们的get方法可以得到相应的值。这就确定了view在父控件中的位置坐标和view的宽和高。 View#onLayout是一个空实现。因为view只需要确定自己在父控件的位置即可。onLayout是用于在ViewGroup中确定子view的位置的。而onLayout的实现同样是与具体的ViewGroup的布局特性有关的。需要在自定义ViewGroup实现。 绘制流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void draw(Canvas canvas) &#123; ... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&#x27; layers to prepare for fading * 3. Draw view&#x27;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); ... &#125; ... &#125; draw过程就是主要就是，上面源码所说的那几个步骤。 1、如果需要背景，绘制背景2、onDraw中，绘制自身3、dispatchDraw中，绘制子view4、onDrawForeground中绘制装饰 在自定义ViewGroup时，可以在dispatchDraw中遍历子view进行绘制。 实例布局 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.example.hyj.ht_test.widget.custom.CustomViewGroup xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.example.hyj.ht_test.widget.custom.CustomViewGroup1 android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:padding=&quot;10dp&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;com.example.hyj.ht_test.widget.custom.CustomView android:id=&quot;@+id/btn&quot; android:background=&quot;@color/common_color&quot; android:layout_margin=&quot;10dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/com.example.hyj.ht_test.widget.custom.CustomViewGroup1&gt;&lt;/com.example.hyj.ht_test.widget.custom.CustomViewGroup&gt; CustomViewGroup1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class CustomViewGroup1 extends ViewGroup &#123; private Context mContext; private static final String TAG = &quot;CustomViewGroup&quot;; ....构造函数... public static class CustomLayoutParams extends MarginLayoutParams &#123; public CustomLayoutParams(MarginLayoutParams source) &#123; super(source); &#125; public CustomLayoutParams(android.view.ViewGroup.LayoutParams source) &#123; super(source); &#125; public CustomLayoutParams(Context c, AttributeSet attrs) &#123; super(c, attrs); &#125; public CustomLayoutParams(int width, int height) &#123; super(width, height); &#125; &#125; /** * 生成默认的布局参数 */ @Override protected CustomLayoutParams generateDefaultLayoutParams() &#123; return new CustomLayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); &#125; /** * 生成布局参数 * 将布局参数包装成我们的 */ @Override protected android.view.ViewGroup.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams p) &#123; return new CustomLayoutParams(p); &#125; /** * 生成布局参数 * 从属性配置中生成我们的布局参数 */ @Override public android.view.ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new CustomLayoutParams(getContext(), attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //measureChildren(widthMeasureSpec, heightMeasureSpec); int parentWidth = 0; int parentHeight = 0; int childCount = getChildCount(); if(childCount &gt; 0) &#123; for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(0); measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); CustomLayoutParams clp = (CustomLayoutParams) child.getLayoutParams(); if (child.getVisibility() != View.GONE) &#123; parentWidth = getPaddingLeft() + getPaddingRight() + child.getMeasuredWidth() + clp.leftMargin + clp.rightMargin ; parentHeight = getPaddingTop() + getPaddingBottom() + child.getMeasuredHeight() + clp.topMargin + clp.bottomMargin; &#125; &#125; &#125; setMeasuredDimension(parentWidth, parentHeight); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); int paddingTop = 0; if(childCount &gt; 0) &#123; for(int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); if(child.getVisibility() != View.GONE) &#123; int measuredHeight = child.getMeasuredHeight(); int measuredWidth = child.getMeasuredWidth(); CustomLayoutParams clp = (CustomLayoutParams) child.getLayoutParams(); paddingTop = paddingTop + child.getPaddingTop(); child.layout(getPaddingLeft() + clp.leftMargin, getPaddingTop() + clp.topMargin, getPaddingLeft() + clp.leftMargin + measuredWidth, getPaddingTop() + clp.leftMargin + measuredHeight); &#125; &#125; &#125; &#125; &#125; CustomViewGroup是默认的实现可以 12345678910111213141516171819202122232425262728293031323334353637383940public class CustomView extends View &#123; public CustomView(Context context) &#123; super(context); init(); &#125; public CustomView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public CustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getSize(600, widthMeasureSpec), getSize(600, heightMeasureSpec)); &#125; private int getSize(int size, int measureSpec) &#123; int result = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if(specMode != MeasureSpec.EXACTLY) &#123; result = size; &#125; else &#123; result = specSize; &#125; return result; &#125;&#125; 其实这些代码是《Android的MotionEvent事件分发机制》中用的代码基础上加的.","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"Android的MotionEvent事件分发机制","slug":"android-event","date":"2018-01-10T00:41:26.000Z","updated":"2020-02-22T12:10:40.000Z","comments":true,"path":"2018/01/10/android-event/","link":"","permalink":"http://zhangsunyucong.top/2018/01/10/android-event/","excerpt":"android事件的源头在哪里？当用户触摸屏幕或者按键等时，形成事件，事件经过linux底层Event节点捕获之后，一直传到android应用层。中间传递的过程不是本文的重点，我也不是很清楚（哈哈哈）。本文的重点是事件在应用层的分发机制。 事件在View树中的分发过程View树： 在Android中，事件的分发过程就是MotionEvent在view树分发的过程。默认是中从上而下，然后从下而上的传递的，直到有view、viewgroup或者Activity处理事件为止。","text":"android事件的源头在哪里？当用户触摸屏幕或者按键等时，形成事件，事件经过linux底层Event节点捕获之后，一直传到android应用层。中间传递的过程不是本文的重点，我也不是很清楚（哈哈哈）。本文的重点是事件在应用层的分发机制。 事件在View树中的分发过程View树： 在Android中，事件的分发过程就是MotionEvent在view树分发的过程。默认是中从上而下，然后从下而上的传递的，直到有view、viewgroup或者Activity处理事件为止。 为什么要先从上而下？是为了在默认情况下，屏幕上层叠的所有控件都有机会处理事件。这个阶段我们称为事件下发阶段。 为什么要从下而上？是为了在从上而下分发时，事件没有控件处理时，再从下而上冒泡事件，是否有控件愿意处理事件。如果中间没有控件处理，事件就只能由Acitivity处理了。这个阶段我们称为事件的冒泡阶段。 准备事件序列：从用户手指触摸屏幕开始，经过滑动到手指离开屏幕。这个操作产生了一个dowm事件，一系列move事件，最后一个up事件结束。我们把这一个操作产生的事件称为一个事件序列。 Acitivity中和事件传递有关的函数事件分发：dispatchTouchEvent事件处理：onTouchEvent ViewGrop中和事件传递有关的函数事件分发：dispatchTouchEvent事件拦截：onInterceptTouchEvent事件处理：onTouchEvent View中和事件传递有关的函数事件分发：dispatchTouchEvent事件处理：onTouchEvent 从上面可以看出，ViewGrop中多了事件拦截onInterceptTouchEvent函数，是为了询问自己是否拦截事件（在事件分发中询问），如果没有拦截就传递事件给直接子view，如果拦截就将事件交给自己的事件处理函数处理。View中没有事件拦截函数，因为view是在view树中的叶节点，已经没有子view。 下面是先进行源码分析，然后再验证得出一些结论。代码迟点上传github。用图表示布局的层级关系： 这里分析事件的分发过程，是从down事件的分发开始，以及分析它在两个阶段的传递过程：下发阶段和冒泡阶段。 事件下发阶段（1）在Acitvity中的源码分析： Activity#dispatchTouchEvent 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 在第4行，Acivity将事件传递给了Window，Window是一个抽象类。在手机系统中它的实现是PhoneWindow.下面进入PhoneWindow中。 PhoneWindow#superDispatchTouchEvent 1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 从上面可以看出，事件已经从Acitivity到PhoneWindow，再传到了DecorView。DecorView是一个继承FrameLayout的ViewGroup，从而事件进入了View树的传递。 重写在Acitvity中的事件传递方法 重写Activity#dispatchTouchEvent：1、返回false，事件不分发，所有事件在Acitivity的分发函数中就中断（真的不见了），连Acitivity的事件处理函数都到达不了。2、返回true，所有事件在Acitivity的分发函数中就中断，和false一样3、返回父函数方法，事件就传给直接子view分发 进一步的，DecorView是一个FrameLayout，也即是一个ViewGruop。 （2）在ViewGruop中的源码分析：ViewGruop#dispatchTouchEvent 12345678910111213141516171819202122232425262728final int action = ev.getAction();final int actionMasked = action &amp; MotionEvent.ACTION_MASK;// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();&#125;// Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; 在5-11行，是每个新的事件系列开始前，会重置事件相关的状态。这里我们关注两个地方。第一个是第17行的disallowIntercept标志，第二个是第19行调用了事件拦截函数，询问是否拦截事件。 ViewGruop#onInterceptTouchEvent 123456789public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123; return true; &#125; return false;&#125; onInterceptTouchEvent的代码很简单。 重写在ViewGroup中的事件传递方法重写ViewGroup#dispatchTouchEvent：1、返回false，不分发，down事件给父ViewGroup处理，以后的事件全部直接通过父ViewGroup分发函数给父ViewGroup的事件处理函数处理。2、返回true，则所有的事件都从头来到这里就中断，不见了。3、返回父函数方法，看下面拦截函数 重写ViewGroup#onInterceptTouchEvent（询问是否拦截）：1、返回true，就调用处理函数，在处理函数中是否消耗down事件2、返回false，是否是最后一个view？否，down事件就分发给子View；是，就调用一次它的处理函数，进入冒泡阶段（就是一寸事件处理函数调用）3、返回父函数的方法，和返回false一样 重写ViewGroup的onTouchEvent，当down事件来到中onTouchEvent时，1、返回true，就消耗down事件，后面全部事件从头分发到处理函数（不用再询问是否拦截）。后面的事件根据是否消耗而是否消失（不消耗就消失），消失的所有事件由Acitivity处理（注意消失的事件也是从头传递到这里再传给Acitivity的）。2、返回false，将down事件冒泡回去，看谁会处理。3、返回父函数方法，是默认不消耗。 （3）在View中的源码分析：View#dispatchTouchEvent 12345678910111213141516if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125;&#125; 这里关注的地方是，第9行和第13行。第9行是当前view如果设置了onTouch事件，并且它返回了true，那它就直接将result设置为true，事件就消耗了，不会再继续传递下去，只到达onTouch。第13行，是事件处理函数。可以看出onTouch是优先于onTouchEvent的。 View#onTouchEvent 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162....final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;... if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; handleTooltipUp(); &#125; if (!clickable) &#123; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; &#125; boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don&#x27;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; ... &#125; ... &#125; return true;&#125; view根据是否可以点击等等一系列判断什么的。这里关注up事件中的第42-53行，有performClick。 View#performClick 1234567891011121314151617public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result;&#125; 如果view设置了mOnClickListener，即点击事件，会调用view的点击事件。如果在父view中拦截了up事件，使up事件到达不了这里，会使view的点击事件失效。 可以知道，onTouch是优先于onTouchEvent，onTouchEvent优先于onclick。 事件冒泡阶段当down事件到达了最后一个子view，如果仍然没有view愿意处理它，就调用一次最后一个子view的事件处理函数，是否处理dowm事件，如果不处理，就一直冒泡回去，直到有view的onTouchEvent处理为止。如果都不处理，就只有Acitivity自己处理了。整个事件冒泡阶段就是一串onTouchEvent的回溯过程，自下而上。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"《火影忍者》--鸣人和雏田","slug":"huoying","date":"2017-12-28T07:45:26.000Z","updated":"2020-02-22T12:43:30.000Z","comments":true,"path":"2017/12/28/huoying/","link":"","permalink":"http://zhangsunyucong.top/2017/12/28/huoying/","excerpt":"那个时候所有人只是把鸣人当做孤儿看待。他长相最多只能算一般，成绩吊车尾，缺家教，没才华，家世没有，血统没有，智商没有，然后还调皮爱恶作剧。","text":"那个时候所有人只是把鸣人当做孤儿看待。他长相最多只能算一般，成绩吊车尾，缺家教，没才华，家世没有，血统没有，智商没有，然后还调皮爱恶作剧。 除非傻子才会喜欢那时的鸣人。但是雏田硬是喜欢上了，这一喜欢，不仅坚持了好多年，而且还因为这份喜欢，改变了自己。 雏田她硬是透过了种种外在因素，一眼就看清楚了鸣人的内在：阳光，乐观，有梦想，能努力，坚持到底，不服输。可以看出她是多么强大的主见，不理会别人看法的主见。 雏田总是在默默注视着鸣人，一直支持着他，追赶着他。 你知道当你一个人面临绝望的时候，此时却有一个义无反顾的身影挡在你面前，保护你，是什么感觉吗？ 在佩恩来袭，鸣人最为脆弱的时候，挡在他身前保护他。鸣人在十尾的木遁下无处可逃时，她也毅然决然的挡在他身前。那么一个弱弱小小的女孩子，她的勇敢和坚毅却超乎寻常的强大。 两个人第一次去约会，鸣人却因为没钱请不起高级料理，不知道怎么开口。雏田用白眼看鸣人的钱包，然后主动说去吃一乐拉面。 忍界大战开始中。《宁次之死》，让雏田和鸣人打击沉重，鸣人的意志开始动摇，在鸣人内心的防线即将崩溃时，雏田强忍失去亲人的伤痛，一巴掌打醒鸣人，告诉鸣人是宁次用生命换取他活下去的用意，告诉鸣人要清醒，要秉持自己的信念，不要放弃自己的忍道，鼓励他带领大家继续战斗。雏田她看似弱不禁风的外表下其实有着很强大的内心和很坚强的意志。 忍界大战胜利后，鸣人成为救世主。 多年之后，鸣人的儿子博人问鸣人：“爸爸，你年轻的时候干了什么伟大的事啊？”鸣人摸了摸他的头，然后说：“我用了十五年，帮我曾经最喜欢的女生追回了她的丈夫。”儿子又问：“那妈妈呢？”鸣人眼里光线都温柔了：“妈妈坚持爱到了我爱她的那一天。“","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://zhangsunyucong.top/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"android和nodejs搭建一个应用","slug":"android-encryption","date":"2017-12-25T06:47:12.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2017/12/25/android-encryption/","link":"","permalink":"http://zhangsunyucong.top/2017/12/25/android-encryption/","excerpt":"背景为什么想写这一篇文章呢？做android的开发也有两年的时间了，就想把以前学到的一些东西记录下来。于是首先就想在github.com上开一个项目MVPDemo,将一些自己认为比较好的知识点都串联起来。 主要目的：1、初步认识和使用MVP、dagger2和rxJava22、使用对称和非对称加密加强前端与后台的安全机制3、前后台的socket交互实现 其中3、中的socket实现，我专门建了一个github仓库NodeTestDemo，这个仓库不仅仅实现了前端的普通接口，还提供了一个socket服务。","text":"背景为什么想写这一篇文章呢？做android的开发也有两年的时间了，就想把以前学到的一些东西记录下来。于是首先就想在github.com上开一个项目MVPDemo,将一些自己认为比较好的知识点都串联起来。 主要目的：1、初步认识和使用MVP、dagger2和rxJava22、使用对称和非对称加密加强前端与后台的安全机制3、前后台的socket交互实现 其中3、中的socket实现，我专门建了一个github仓库NodeTestDemo，这个仓库不仅仅实现了前端的普通接口，还提供了一个socket服务。 android端实现1、采用了MVP架构，使用dagger2对象依赖注入框架解耦MVP的各个组件2、界面采用了autolayout进行兼容适配，UI尺寸标准是720*1080.页面效果仿微信。3、rxjava2、rxlifecycle2，rxbinding2等Rx系列的初级使用4、与后台服务器接口交互使用了retrofit2，交互的数据格式为json5、自定义retrofit2的ConverterFactory和Interceptor实现统一加解密交互的数据流程6、事件总线eventbus3、控件注入框架butterknife、GreenDao3对象关系映射数据库的使用7、socket的前端简单实现8、PDF文档库android-pdf-viewer的使用9、使用jsoup解析csdn网站的html页面获取博主的博客信息10、接入bugly。可以使用budly跟踪异常奔溃信息和bugly基于tinker的热修复。11、接入腾讯X5内核浏览器服务代替原生的webview12、页面路由Arouter的初步使用13、app端出现异常，在杀死应用前，启动异常页面并允许用户点击重启14、Cmake的使用。可以将敏感或者需要保密的数据使用jni保护，如第三方开发者平台的appid等 后台安全数据安全交互机制1、后台服务器使用了leancloud和nodejs搭建。nodejs服务器源码2、android端的数据加密流程： nodejs使用的是node-rsa模块 （1）生成RSA加解密的公钥和私钥 123456var rsa = require(&#x27;node-rsa&#x27;);//create RSA-keyvar key = new rsa(&#123;b: 1024&#125;);console.log(&quot;私：\\n&quot; + key.exportKey(&#x27;private&#x27;));console.log(&quot;公：\\n&quot; + key.exportKey(&#x27;public&#x27;)); 将服务器公钥分发给前端，私钥保存好放到服务器端。 （2）后台为一个前端生成一对AppId和AppScrect。前后端各保存一份，建议在android端将它们放到JNI中保护。 AppId用于在前端参与参数签名，AppScrect用于服务器返回数据的AES加密密钥。 （3）在Android端，应用每次启动时生成用于参数AES加密的密钥。这样可以使AES加密密钥是动态变化的。 （4）、将请求参数按照key的自然顺序进行排序，构造源串。然后在源串追加AppId得到签名字符串signString，用AES密钥加密signString，得到签名sign。 12345678910111213141516171819202122232425262728293031/** 按照key的自然顺序进行排序，并返回 */private Map&lt;String, Object&gt; getSortedMapByKey(Map&lt;String, Object&gt; map) &#123; Comparator&lt;String&gt; comparator = new Comparator&lt;String&gt;() &#123; @Override public int compare(String lhs, String rhs) &#123; return lhs.compareTo(rhs); &#125; &#125;; Map&lt;String, Object&gt; treeMap = new TreeMap&lt;&gt;(comparator); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; treeMap.put(entry.getKey(), entry.getValue()); &#125; return treeMap;&#125; /** 构造源串 */ public String getSignParamsString(Map&lt;String, Object&gt; map) &#123; //map.put(&quot;nonce&quot;, getRndStr(6 + RANDOM.nextInt(8))); //map.put(&quot;timestamp&quot;, &quot;&quot; + (System.currentTimeMillis() / 1000L)); StringBuilder sb = new StringBuilder(); for (Map.Entry&lt;String, Object&gt; entry : getSortedMapByKey(map).entrySet()) &#123; sb.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue()).append(&quot;&amp;&quot;); &#125; return sb.toString();&#125;/** 构造源串 */ public String getSign(Map&lt;String, Object&gt; map) &#123; String sign = getSignParamsString(map) + &quot;appId=&quot; + AppConfig.AppId; return sign;&#125; 说明：如果要求服务器只允许一定时间范围内的请求，可以在getSignParamsString方法中添加时间戳作为接口签名的一部分，防止重放攻击。 （4）将签名sign和签名的字符串signString进行AES加密，将AES加密密钥用服务器公钥加密，后传给服务器. 123RSAUtils.encryptByServerPublicKey(App.getApp().getAESKey());AESUtils.encryptData(App.getApp().getAESKey(), signString);AESUtils.encryptData(App.getApp().getAESKey(), sign); signString为什么在前端生成呢？为了在服务器重新生成签名字符串时，防止由于前后端开发语言的不同而产生不一致。 （5）服务器解密 12345678910111213141516171819202122232425262728293031323334function valideReqSign(req) &#123; var sourceSign = req.body.sign; var signString = req.body.signString; var key = req.body.aesKey; if(paramUtility.isEnpty(key) || paramUtility.isEnpty(sourceSign) || paramUtility.isEnpty(signString)) &#123; return false; &#125; //a、步骤 key = serverPrivateKey.decrypt(key, &#x27;utf-8&#x27;); //b、步骤 signString = aesUtils.AESDec(key, signString); //c、步骤 signString = signString + &quot;appId=&quot; + decAndEncConfig.getAppId(); var localSign = aesUtils.AESEnc(key, signString); //d、步骤 if(sourceSign !== localSign) &#123; var resJson = &#123; &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;签名不正确&quot;, &quot;status&quot;: 205 &#125;; if(!paramUtility.isNULL(res)) &#123; res.end(jsonUtil.josnObj2JsonString(resJson)); &#125; return false; &#125; return true;&#125; a、取出参数，用服务器RSA私钥解密AES密钥b、用AES密钥解密签名和签名字符串c、签名字符串追加分发给前端的AppScrect后，用a、得到的AES加密重新生产签名。d、对比前端传来的签名和重新生成的签名是否一致。 （5）根据AppId找到对应的AppScrect，用AppScrect对服务器返回的结果进行AES加密。 注意：确保前后端在不同开发语言情况下，AES算法的结果是一样的。 后面会给出我用到的java和nodejs版本的RSA和AES加解密算法源码。 （6）前端从JNI中取出AppScrect对响应结果进行解密即可。 前后端加解密算法源码java的RSA加解密算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.math.BigInteger;import java.security.Key;import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.PublicKey;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.InvalidKeySpecException;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.RSAPrivateKeySpec;import java.security.spec.RSAPublicKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.HashMap;import java.util.Map;import java.util.Properties;import javax.crypto.Cipher;public class RSAUtils &#123; public static final String PRIVATE_KEY = &quot;填写自己的private ky&quot;; private static final String PUBLIC_KEY = AppConfig.RSA_SERVER_PUBLIC_KEY_STR; /** RSA最大加密明文大小 */ private static final int MAX_ENCRYPT_BLOCK = 117; /** RSA最大解密密文大小 */ private static final int MAX_DECRYPT_BLOCK = 128; /** 加密算法RSA */ private static final String KEY_ALGORITHM = &quot;RSA&quot;; /** * 生成公钥和私钥 * * @throws Exception * */ public static void getKeys() throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;); keyPairGen.initialize(1024); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); String publicKeyStr = getPublicKeyStr(publicKey); String privateKeyStr = getPrivateKeyStr(privateKey); System.out.println(&quot;公钥\\r\\n&quot; + publicKeyStr); System.out.println(&quot;私钥\\r\\n&quot; + privateKeyStr); &#125; /** * 使用模和指数生成RSA公钥 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，不同JDK默认的补位方式可能不同，如Android默认是RSA * /None/NoPadding】 * * @param modulus * 模 * @param exponent * 公钥指数 * @return */ public static RSAPublicKey getPublicKey(String modulus, String exponent) &#123; try &#123; BigInteger b1 = new BigInteger(modulus); BigInteger b2 = new BigInteger(exponent); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); RSAPublicKeySpec keySpec = new RSAPublicKeySpec(b1, b2); return (RSAPublicKey) keyFactory.generatePublic(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 使用模和指数生成RSA私钥 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，不同JDK默认的补位方式可能不同，如Android默认是RSA * /None/NoPadding】 * * @param modulus * 模 * @param exponent * 指数 * @return */ public static RSAPrivateKey getPrivateKey(String modulus, String exponent) &#123; try &#123; BigInteger b1 = new BigInteger(modulus); BigInteger b2 = new BigInteger(exponent); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(b1, b2); return (RSAPrivateKey) keyFactory.generatePrivate(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; public static String encryptByServerPublicKey(String data) &#123; try &#123; return RSAUtils.encryptByPublicKey(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;&quot;; &#125; &#125; public static String decryptByClentPrivateKey(String data) &#123; try &#123; return RSAUtils.decryptByPrivateKey(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;// private String schel = &quot;RSA/ECB/OAEPWithSHA1AndMGF1Padding&quot;; /** * 公钥加密 *&quot;RSA/ECB/PKCS1Padding&quot; * @param data * @return * @throws Exception */ private static String encryptByPublicKey(String data) throws Exception &#123; byte[] dataByte = data.getBytes(); byte[] keyBytes = Base64Utils.decode(PUBLIC_KEY); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); // 对数据加密 // Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;); cipher.init(Cipher.ENCRYPT_MODE, publicK); int inputLen = dataByte.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(dataByte, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(dataByte, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return Base64Utils.encode(encryptedData); &#125; /** * 私钥解密 * * @param data * @return* * @throws Exception */ private static String decryptByPrivateKey(String data) throws Exception &#123; byte[] encryptedData = Base64Utils.decode(data); byte[] keyBytes = Base64Utils.decode(PRIVATE_KEY); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM, &quot;BC&quot;); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); // Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;); cipher.init(Cipher.DECRYPT_MODE, privateK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher .doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher .doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return new String(decryptedData); &#125; /** * 获取模数和密钥 * * @return */ public static Map&lt;String, String&gt; getModulusAndKeys() &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); try &#123; InputStream in = RSAUtils.class .getResourceAsStream(&quot;/rsa.properties&quot;); Properties prop = new Properties(); prop.load(in); String modulus = prop.getProperty(&quot;modulus&quot;); String publicKey = prop.getProperty(&quot;publicKey&quot;); String privateKey = prop.getProperty(&quot;privateKey&quot;); in.close(); map.put(&quot;modulus&quot;, modulus); map.put(&quot;publicKey&quot;, publicKey); map.put(&quot;privateKey&quot;, privateKey); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return map; &#125; /** * 从字符串中加载公钥 * * @param publicKeyStr * 公钥数据字符串 * @throws Exception * 加载公钥时产生的异常 */ public static PublicKey loadPublicKey(String publicKeyStr) throws Exception &#123; try &#123; byte[] buffer = Base64Utils.decode(publicKeyStr); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer); return (RSAPublicKey) keyFactory.generatePublic(keySpec); &#125; catch (NoSuchAlgorithmException e) &#123; throw new Exception(&quot;无此算法&quot;); &#125; catch (InvalidKeySpecException e) &#123; throw new Exception(&quot;公钥非法&quot;); &#125; catch (NullPointerException e) &#123; throw new Exception(&quot;公钥数据为空&quot;); &#125; &#125; /** * 从字符串中加载私钥&lt;br&gt; * 加载时使用的是PKCS8EncodedKeySpec（PKCS#8编码的Key指令）。 * * @param privateKeyStr * @return * @throws Exception */ public static PrivateKey loadPrivateKey(String privateKeyStr) throws Exception &#123; try &#123; byte[] buffer = Base64Utils.decode(privateKeyStr); // X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(buffer); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); return (RSAPrivateKey) keyFactory.generatePrivate(keySpec); &#125; catch (NoSuchAlgorithmException e) &#123; throw new Exception(&quot;无此算法&quot;); &#125; catch (InvalidKeySpecException e) &#123; throw new Exception(&quot;私钥非法&quot;); &#125; catch (NullPointerException e) &#123; throw new Exception(&quot;私钥数据为空&quot;); &#125; &#125; public static String getPrivateKeyStr(PrivateKey privateKey) throws Exception &#123; return new String(Base64Utils.encode(privateKey.getEncoded())); &#125; public static String getPublicKeyStr(PublicKey publicKey) throws Exception &#123; return new String(Base64Utils.encode(publicKey.getEncoded())); &#125; public static void main(String[] args) throws Exception &#123; getKeys(); &#125;&#125; java的AES加解密算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.UUID;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * AES工具类，密钥必须是16位字符串 */public class AESUtils &#123; /**偏移量,必须是16位字符串*/ private static final String IV_STRING = &quot;16-Bytes--String&quot;; /** * 默认的密钥 */ public static final String DEFAULT_KEY = &quot;1bd83b249a414036&quot;; /** * 产生随机密钥(这里产生密钥必须是16位) */ public static String generateKey() &#123; String key = UUID.randomUUID().toString(); key = key.replace(&quot;-&quot;, &quot;&quot;).substring(0, 16);// 替换掉-号 return key; &#125; /** * 加密 * @param key * @param content * @return */ public static String encryptData(String key, String content) &#123; byte[] encryptedBytes = new byte[0]; try &#123; byte[] byteContent = content.getBytes(&quot;UTF-8&quot;); // 注意，为了能与 iOS 统一 // 这里的 key 不可以使用 KeyGenerator、SecureRandom、SecretKey 生成 byte[] enCodeFormat = key.getBytes(); SecretKeySpec secretKeySpec = new SecretKeySpec(enCodeFormat, &quot;AES&quot;); byte[] initParam = IV_STRING.getBytes(); IvParameterSpec ivParameterSpec = new IvParameterSpec(initParam); // 指定加密的算法、工作模式和填充方式 Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;); cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec); encryptedBytes = cipher.doFinal(byteContent); // 同样对加密后数据进行 base64 编码 return Base64Utils.encode(encryptedBytes); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 解密 * @param key * @param content * @return */ public static String decryptData(String key, String content) &#123; try &#123; // base64 解码 byte[] encryptedBytes = Base64Utils.decode(content); byte[] enCodeFormat = key.getBytes(); SecretKeySpec secretKey = new SecretKeySpec(enCodeFormat, &quot;AES&quot;); byte[] initParam = IV_STRING.getBytes(); IvParameterSpec ivParameterSpec = new IvParameterSpec(initParam); Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec); byte[] result = cipher.doFinal(encryptedBytes); return new String(result, &quot;UTF-8&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String[] args) &#123; String plainText = AESUtils.decryptData(&quot;F431E6FF9051DA07&quot;, &quot;q8jHYk6LSbwC2K4zmr/wRZo8mlH0VdMzPEcAzQadTCpSrPQ/ZnTmuIvQxiLOnUXu&quot;); System.out.println(&quot;aes加密后: &quot; + plainText); &#125; &#125; node.js的RSA加解密算法使用”node-rsa”: “^0.4.2”，模块 node.js的AES加解密算法AES算法:aes.js 进一步改进，关注：JIN的签名验证和 JNI_OnLoad() 方法对 APK 签名进行验证","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"}]},{"title":"二进制和种类","slug":"binary-classify","date":"2017-12-22T01:20:13.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2017/12/22/binary-classify/","link":"","permalink":"http://zhangsunyucong.top/2017/12/22/binary-classify/","excerpt":"前言话回我刚刚毕业来到深圳时，作为一个android菜鸟在一个大神波哥的指导下，学到了很多东西。其中，二进制和分类就是我印象最深的。想按自己理解记录一下。 想一下，有这样的需求：一个物体有一个种类属性，它这个属性有很多相互独立可以相加的值，也就是它有很多种情况，而且一个物体可同时具有其中一个或者多个情况。而我们想用一个数字就表示它的所有情况（这就是数学思维，总把东西抽象化）。 来个具体的，用于表示一个人是否有高血压，高血糖，高血脂这种属性。这个属性可以有各种情况的值，一个人可以只是有高血压、高血糖或者高血脂，也可以有“三高”。那我们如何用一个十进制的值来表示一个人的这个属性的各种情呢？ 我们可以让十进制数字的二进制表示的每一位代表一种情况，运用二进制的位运算来表示和判断它的各种情况。","text":"前言话回我刚刚毕业来到深圳时，作为一个android菜鸟在一个大神波哥的指导下，学到了很多东西。其中，二进制和分类就是我印象最深的。想按自己理解记录一下。 想一下，有这样的需求：一个物体有一个种类属性，它这个属性有很多相互独立可以相加的值，也就是它有很多种情况，而且一个物体可同时具有其中一个或者多个情况。而我们想用一个数字就表示它的所有情况（这就是数学思维，总把东西抽象化）。 来个具体的，用于表示一个人是否有高血压，高血糖，高血脂这种属性。这个属性可以有各种情况的值，一个人可以只是有高血压、高血糖或者高血脂，也可以有“三高”。那我们如何用一个十进制的值来表示一个人的这个属性的各种情呢？ 我们可以让十进制数字的二进制表示的每一位代表一种情况，运用二进制的位运算来表示和判断它的各种情况。 思路分析还是上面举的例子。二进制的每一位代表一种情况，三种情况我们可以用二进制的四位表示就可以。其他更多的情况，可以用更多的位来表示。我们约定结果的格式表示为：二进制，十进制。 高血压： 0001，1 。—表示一个人只有高血压高血糖： 0010，2 。—表示一个人只有高血糖高血脂： 0100，4 。—表示一个人只有高血脂 那如何表示其他各种情况呢？ 表示一个人有高血压和高血糖：0001 | 0010 = 0011，3表示一个人有高血压和高血脂：0001 | 0100 = 0101，5表示一个人有高血糖和高血脂：0010 | 0100 = 0110，6表示一个人有高血压、高血糖和高血脂： 0001 | 0010 | 0100 = 0111，7 我们就说，这就是各种情况“相加”。 如果要从多种情况中减除一种或者多种情况，又如何操作呢？比如代表“三高”的7，我们如何从中减除高血压这种情况。 7 &amp; (0001) = 0111 &amp; (0001) = 0111 &amp; 1110 = 0110，6 说明：自身取“非”是为了不影响原来其他的各种情况，只改变自身那种情况的位。减除多种情况，以此类推。这就是情况的“相减” 如果给我们一个十进制：7，我们又如何知道它表示有多少种情况呢？ 1、是否有高血压 0001？7 &amp; 0001 = 0001 即 0111 &amp; 0001 = 00012、是否有高血糖？7 &amp; 0010 = 0010 即 0111 &amp; 0010 = 00103、是否有高血脂？7 &amp; 0100 = 0100 即 0111 &amp; 0100 = 0100 这实际就是，位的与运算是否等于自身。这就是各种情况的判断方法。","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://zhangsunyucong.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"读《人类简史》和《未来简史》","slug":"about-history","date":"2017-12-12T03:31:48.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2017/12/12/about-history/","link":"","permalink":"http://zhangsunyucong.top/2017/12/12/about-history/","excerpt":"读前提取论点 人类因为自然的一次偶然的基础而出现。智人摆脱了基因的宿命，开始用语言交流，可以说故事了，慢慢产生了各种概念，如神，社会，国家，配偶，金钱等等。 智慧的产生，源于人的反思和内心。 现在人只是生活在自己编造的故事里，正是因为故事才赋予人以意义。 从历史谈到现在，指出万物皆是算法，不同的算法，只是意识的有无和不同。","text":"读前提取论点 人类因为自然的一次偶然的基础而出现。智人摆脱了基因的宿命，开始用语言交流，可以说故事了，慢慢产生了各种概念，如神，社会，国家，配偶，金钱等等。 智慧的产生，源于人的反思和内心。 现在人只是生活在自己编造的故事里，正是因为故事才赋予人以意义。 从历史谈到现在，指出万物皆是算法，不同的算法，只是意识的有无和不同。 未来很多东西会被人类写的算法所取代，甚至会出现新的人类阶级：无用阶级和超人类。 超人类甚至可以足够强大，是长生的，可以操作万物，记忆不再只存于大脑，甚至可以存在于“云”中。 最后，这两本书其实也是正在述说着故事。未完待续。。。","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://zhangsunyucong.top/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"使用nginx负载均衡nodejs","slug":"node-and-nginx","date":"2017-12-06T02:59:08.000Z","updated":"2020-02-22T09:42:54.000Z","comments":true,"path":"2017/12/06/node-and-nginx/","link":"","permalink":"http://zhangsunyucong.top/2017/12/06/node-and-nginx/","excerpt":"前言这篇文章适合熟悉nodejs的同学观看。主要是关于如何使用nginx做反向代理和负载均衡nodejs的多个实例的配置流程，nodejs实例可以是分布在同一台主机上或者不同的主机上的多个实例。 主要内容有 在同一主机创建nodejs多个实例 详细讲解ngnix.conf文件的每项配置的作用 在同一主机创建nodejs多个实例我的nodejs环境： window 7 64位 nodejs v8.1.3 webstorm 2017版","text":"前言这篇文章适合熟悉nodejs的同学观看。主要是关于如何使用nginx做反向代理和负载均衡nodejs的多个实例的配置流程，nodejs实例可以是分布在同一台主机上或者不同的主机上的多个实例。 主要内容有 在同一主机创建nodejs多个实例 详细讲解ngnix.conf文件的每项配置的作用 在同一主机创建nodejs多个实例我的nodejs环境： window 7 64位 nodejs v8.1.3 webstorm 2017版 根目录/server.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&#x27;use strict&#x27;;var express = require(&#x27;express&#x27;);var timeout = require(&#x27;connect-timeout&#x27;);var path = require(&#x27;path&#x27;);var cookieParser = require(&#x27;cookie-parser&#x27;);var bodyParser = require(&#x27;body-parser&#x27;);var app = express();// 设置模板引擎,路径在根目录+public中app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;public&#x27;));app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.use(express.static(&#x27;public&#x27;));app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 设置默认超时时间app.use(timeout(&#x27;15s&#x27;));//请求体app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));//cookieapp.use(cookieParser());//注册HTTP消息头部信息app.use( function(req, res, next) &#123; res.set( &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27;, &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;, &#x27;Access-Control-Allow-Rememberme&#x27;: true, &#x27;Access-Control-Allow-HttpOnly&#x27;: false, &#x27;Access-Control-Allow-Methods&#x27;: &#x27;POST, GET, PUT, DELETE, OPTIONS&#x27;, &#x27;Access-Control-Allow-Credentials&#x27;: true, //false, &#x27;Access-Control-Max-Age&#x27;: &#x27;86400&#x27;, // 24 hours &#x27;Access-Control-Allow-Headers&#x27;: &#x27;X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept&#x27; &#125; ); //decodeURI(req.url) console.log(&#x27;%s %s&#x27;, req.method, req.url); next(); &#125;);//首页app.get(&#x27;/&#x27;, function(req, res) &#123; res.render(&#x27;index1&#x27;, &#123; currentTime: new Date() &#125;);&#125;);app.use(function(req, res, next) &#123; // 如果任何一个路由都没有返回响应，则抛出一个 404 异常给后续的异常处理器 if (!res.headersSent) &#123; var err = new Error(&#x27;Not Found&#x27;); err.status = 404; next(err); &#125;&#125;);// 错误处理app.use(function(err, req, res, next) &#123; if (req.timedout &amp;&amp; req.headers.upgrade === &#x27;websocket&#x27;) &#123; // 忽略 websocket 的超时 return; &#125; var statusCode = err.status || 500; if (statusCode === 500) &#123; console.error(err.stack || err); &#125; if (req.timedout) &#123; console.error(&#x27;请求超时: url=%s, timeout=%d, 请确认方法执行耗时很长，或没有正确的 response 回调。&#x27;, req.originalUrl, err.timeout); &#125; res.status(statusCode); // 默认不输出异常详情 var error = &#123;&#125;; if (app.get(&#x27;env&#x27;) === &#x27;development&#x27;) &#123; // 如果是开发环境，则将异常堆栈输出到页面，方便开发调试 error = err; &#125; res.render(&#x27;error&#x27;, &#123; message: err.message, error: error &#125;);&#125;);function catchGlobalError(err) &#123; // 注册全局未捕获异常处理器 process.on(&#x27;uncaughtException&#x27;, function(err) &#123; console.error(&#x27;Caught exception:&#x27;, err.stack); &#125;); process.on(&#x27;unhandledRejection&#x27;, function(reason, p) &#123; console.error(&#x27;Unhandled Rejection at: Promise &#x27;, p, &#x27; reason: &#x27;, reason.stack); &#125;);&#125;//创建两个服务器实体var server = require(&#x27;http&#x27;).createServer(app);var server1 = require(&#x27;http&#x27;).createServer(app);//服务器监听端口var PORT = parseInt(process.env.PORT || 3000);var PORT1 = PORT + 1;server.listen(PORT, function (err) &#123; console.log(&#x27;Node app is running on port:&#x27;, PORT); catchGlobalError(err);&#125;);server1.listen(PORT1, function (err) &#123; console.log(&#x27;Node app is running on port:&#x27;, PORT1); catchGlobalError(err);&#125;); 根目录/views/error.ejs 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Error&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/stylesheets/style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= message %&gt;&lt;/h1&gt; &lt;h2&gt;&lt;%= error.status %&gt;&lt;/h2&gt; &lt;pre&gt;&lt;%= error.stack %&gt;&lt;/pre&gt; &lt;/body&gt;&lt;/html&gt; 根目录/views/index.ejs 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;nodejs 和 nginx&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./stylesheets/style.css&quot;&gt;&lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;h3&gt;Hello world&lt;/h3&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; ngnix配置文件nginx.config 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream nodeproxy &#123; server 192.168.10.137:3000 weight=10; server 127.0.0.1:3001 weight=12; &#125; server &#123; listen 8089; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; proxy_pass http://nodeproxy; #与upstream的名称一致 proxy_redirect default; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; nginx常用命令在nginx的安装根目录下，打开命令行工具，运行。 启动nginx：start nginx重新加载配置：nginx -s reload重新打开日志：nginx -s reopen 关闭nginx：快速停止：nginx -s stop有序关闭：nginx -s quit 如果遇到启动不了nginx，可能是监听的端口被占用。使用命令：netstat -aon | findstr :80查询一下 用浏览器访问localhost:8089,我的测试的结果是： “D:\\WebStorm 2017.2.1\\bin\\runnerw.exe” D:\\nodejs\\node.exe D:\\collect\\leancloud\\jiangebuluo\\NodeTestDemo\\myServer.jsNode app is running on port: 3000Node app is running on port: 3001服务器监听的IP: 192.168.10.137服务器监听的IP: 192.168.10.137服务器监听的IP: 127.0.0.1服务器监听的IP: 127.0.0.1服务器监听的IP: 127.0.0.1服务器监听的IP: 127.0.0.1服务器监听的IP: 127.0.0.1服务器监听的IP: 127.0.0.1服务器监听的IP: 192.168.10.137服务器监听的IP: 192.168.10.137 最后另外贴出一个ubuntu的详细配置讲解。来自猎手家园的博客 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid文件pid /usr/local/nginx/logs/nginx.pid;#指定进程可以打开的最大描述符：数目#工作模式与连接数上限#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误. open_file_cache_errors on;&#125; #设定http服务器，利用它的反向代理功能提供负载均衡支持http&#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream piao.jd.com &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 127.0.0.1:3000 weight=3; server 127.0.0.1:3001 weight=2; #nginx的upstream目前支持4种方式的分配 #1、轮询（默认） #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 #2、weight #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 #例如： #upstream bakend &#123; # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #&#125; #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 #例如： #upstream bakend &#123; # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #&#125; #3、fair（第三方） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend &#123; # server server1; # server server2; # fair; #&#125; #4、url_hash（第三方） #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 #upstream backend &#123; # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #&#125; #tips: #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123; # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #&#125; #在需要使用负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表示单前的server暂时不参与负载 #2.weight为weight越大，负载的权重就越大。 #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 &#125; #虚拟主机的配置 server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.jd.com jd.com; index index.html index.htm index.php; root /data/www/jd; #对******进行负载均衡 location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #日志格式设定 #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;; #定义本虚拟主机的访问日志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 &quot;/&quot; 启用反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数， #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。 #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小 proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置 #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 &#125; #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ &#123; expires 15d; &#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125;","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://zhangsunyucong.top/tags/nodejs/"}]}],"categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://zhangsunyucong.top/tags/Flutter/"},{"name":"android","slug":"android","permalink":"http://zhangsunyucong.top/tags/android/"},{"name":"java","slug":"java","permalink":"http://zhangsunyucong.top/tags/java/"},{"name":"Android","slug":"Android","permalink":"http://zhangsunyucong.top/tags/Android/"},{"name":"node.js","slug":"node-js","permalink":"http://zhangsunyucong.top/tags/node-js/"},{"name":"生活","slug":"生活","permalink":"http://zhangsunyucong.top/tags/%E7%94%9F%E6%B4%BB/"},{"name":"基础知识","slug":"基础知识","permalink":"http://zhangsunyucong.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"阅读","slug":"阅读","permalink":"http://zhangsunyucong.top/tags/%E9%98%85%E8%AF%BB/"},{"name":"nodejs","slug":"nodejs","permalink":"http://zhangsunyucong.top/tags/nodejs/"}]}